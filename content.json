{"meta":{"title":"nova7y","subtitle":null,"description":null,"author":"nova7y","url":"","root":"/yyy/"},"pages":[{"title":"标签","date":"2019-05-09T02:30:30.208Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-09T02:30:19.811Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-05-09T02:30:00.482Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"HTTP协议详解","slug":"HTTP协议详解","date":"2019-05-25T03:53:01.163Z","updated":"2019-05-25T03:54:15.254Z","comments":true,"path":"2019/05/25/HTTP协议详解/","link":"","permalink":"/2019/05/25/HTTP协议详解/","excerpt":"","text":"概要：HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统 引言HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议的主要特点可概括如下： 1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 一、HTTP协议详解之URL篇​ http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下： http://host[&quot;:&quot;port][abs_path] http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。 eg: 1、输入：www.guet.edu.cn 浏览器自动转换成：http://www.guet.edu.cn/ 2、http:192.168.0.116:8080/index.jsp 二、HTTP协议详解之请求篇​ http请求由三部分组成，分别是：请求行、消息报头、请求正文 1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF 其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法（所有方法全为大写）有多种，各个方法的解释如下： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 应用举例： GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF) POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。 eg：POST /reg.jsp HTTP/ (CRLF) Accept:image/gif,image/x-xbit,… (CRLF) … HOST:www.guet.edu.cn (CRLF) Content-Length:22 (CRLF) Connection:Keep-Alive (CRLF) Cache-Control:no-cache (CRLF) (CRLF) //该CRLF表示消息报头已经结束，在此之前为消息报头 user=jeffrey&amp;pwd=1234 //此行以下为提交的数据 HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 2、请求报头后述 3、请求正文(略) 三、HTTP协议详解之响应篇​ 在接收和解释请求消息后，服务器返回一个HTTP响应消息。 HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 1、状态行格式如下： HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 eg：HTTP/1.1 200 OK （CRLF） 2、响应报头后述 3、响应正文就是服务器返回的资源的内容 四、HTTP协议详解之消息报头篇​ HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。 每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 1、普通报头 在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。 eg： Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。 请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached; 响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage. eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”); //response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用 这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache Date普通报头域表示消息产生的日期和时间 Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 2、请求报头 请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 常用的请求报头 Accept Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。 Accept-Charset Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-Encoding Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 Accept-Language Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 Authorization Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Host（发送请求时，该报头域是必需的） Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg： 我们在浏览器中输入：http://www.guet.edu.cn/index.html 浏览器发送的请求消息中，就会包含Host请求报头域，如下： Host：www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号 User-Agent 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。 请求报头举例： GET /form.html HTTP/1.1 (CRLF) Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,/ (CRLF) Accept-Language:zh-cn (CRLF) Accept-Encoding:gzip,deflate (CRLF) If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF) If-None-Match:W/“80b1a4c018f3c41:8317” (CRLF) User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF) Host:www.guet.edu.cn (CRLF) Connection:Keep-Alive (CRLF) (CRLF) 3、响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头 Location Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 Server Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是 Server响应报头域的一个例子： Server：Apache-Coyote/1.1 WWW-Authenticate WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。 eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制。 4、实体报头 请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。 常用的实体报头 Content-Encoding Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip Content-Language Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读 者。eg：Content-Language:da Content-Length Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Content-Type Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg： Content-Type:text/html;charset=ISO-8859-1 Content-Type:text/html;charset=GB2312 Last-Modified Last-Modified实体报头域用于指示资源的最后修改日期和时间。 Expires Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”); 五、利用telnet观察http协议的通讯过程 ​ 实验目的及原理： ​ 利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。 ​ 实验步骤： 1、打开telnet 1.1 打开telnet 运行–&gt;cmd–&gt;telnet 1.2 打开telnet回显功能 set localecho 2、连接服务器并发送请求 2.1 open www.guet.edu.cn 80 //注意端口号不能省略 ​ HEAD /index.asp HTTP/1.0 ​ Host:www.guet.edu.cn ​ /我们可以变换请求方法,请求桂林电子主页内容,输入消息如下/ ​ open www.guet.edu.cn 80 ​ GET /index.asp HTTP/1.0 //请求资源的内容 ​ Host:www.guet.edu.cn 2.2 open www.sina.com.cn 80 //在命令提示符号下直接输入telnet www.sina.com.cn 80 ​ HEAD /index.asp HTTP/1.0 ​ Host:www.sina.com.cn 3 实验结果： 3.1 请求信息2.1得到的响应是: HTTP/1.1 200 OK //请求成功 Server: Microsoft-IIS/5.0 //web服务器 Date: Thu,08 Mar 200707:17:51 GMT Connection: Keep-Alive Content-Length: 23330 Content-Type: text/html Expries: Thu,08 Mar 2007 07:16:51 GMT Set-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/ Cache-control: private //资源内容省略 3.2 请求信息2.2得到的响应是: HTTP/1.0 404 Not Found //请求失败 Date: Thu, 08 Mar 2007 07:50:50 GMT Server: Apache/2.0.54 Last-Modified: Thu, 30 Nov 2006 11:35:41 GMT ETag: “6277a-415-e7c76980” Accept-Ranges: bytes X-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remix Vary: Accept-Encoding Content-Type: text/html X-Cache: MISS from zjm152-78.sina.com.cn Via: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt; X-Cache: MISS from th-143.sina.com.cn Connection: close 失去了跟主机的连接 按任意键继续… 4 .注意事项：1、出现输入错误，则请求不会成功。 ​ 2、报头域不分大小写。 ​ 3、更深一步了解HTTP协议，可以查看RFC2616，在http://www.letf.org/rfc上找到该文件。 ​ 4、开发后台程序必须掌握http协议 六、HTTP协议相关技术补充 ​ 1、基础： ​ 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等 中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。 ​ 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。 网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 ​ 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 2、协议分析的优势—HTTP分析器检测网络攻击 以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。 HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定 3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击 使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。 http://www.cnpaf.net/Class/HTTP/0532918532667330.html 4、利用HTTP协议的特性进行拒绝服务攻击的一些构思 服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。 而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。 19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务 方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。 5、Http指纹识别技术 Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别. ​ 要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。 常用测试请求： 1：HEAD/Http/1.0发送基本的Http请求 2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求 3：GET/Http/3.0发送一个非法版本的Http协议请求 4：GET/JUNK/1.0发送一个不正确规格的Http协议请求 Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。 6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。 HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供 更高效率的连接","categories":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/categories/扩展阅读/"}],"tags":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/tags/扩展阅读/"}]},{"title":"前端文件上传方式总结","slug":"前端文件上传方式总结","date":"2019-05-25T03:41:45.029Z","updated":"2019-05-25T03:44:30.275Z","comments":true,"path":"2019/05/25/前端文件上传方式总结/","link":"","permalink":"/2019/05/25/前端文件上传方式总结/","excerpt":"","text":"第一种：经典的form和input上传。设置form的aciton为后端页面，enctype=”multipart/form-data”，type=‘post’ 123456&lt;form action='uploadFile.php' enctype=\"multipart/form-data\" type='post'&gt; &lt;input type='file'&gt; &lt;input type='hidden' name='userid'&gt; &lt;input type='hidden' name='signature'&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 使用input选择文件，设置好其他input的值，点击提交，将文件数据及签名等认证信息发送到form设置的action对应的页面，浏览器也会跳转到该页面。触发form表单提交数据的方式有2种，一种是在页面上点击button按钮或按钮触发，第二种是在js中执行form.submit()方法。 优点：使用简单方便，兼容性好，基本所有浏览器都支持。 缺点：1. 提交数据后页面会跳转（下面会讲如何禁止页面跳转）。 ​ 2.因为是浏览器发起的请求，不是一个ajax，所以前端无法知道什么时候上传结束。 ​ \\3. form表单里发送除文件外的数据，一般是新建一个type=hidden的input，value=‘需要传的数据’，每发送一个数据就需要一个input，一旦多了就会使得dom看起来比较冗余。 小技巧： form表单提交数据后会自动跳转到action指定的页面，为了禁止页面跳转，可以在页面中新建一个空的ifame，比如name=’upload’，然后设置form的target=”Uploader”，form有一个target的属性，规定在何处打开action，这样form提交数据后就会仍停留在当前页。代码如下： 123456&lt;form action='uploadFile.php' enctype=\"multipart/form-data\" type='post' target=\"uploader1\"&gt; &lt;input type='file'&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;ifrmae name='upload' id='uploader1'&gt;&lt;/iframe&gt; 这样写的另一个好处是，可以知道什么时候上传完成并接收到后端的回调结果。比如上面这个例子，文件数据发送到了 ‘uploadFile.php’，假设该页面处理完数据后返回了一个地址，该地址会被写入到之前的iframe中。所以在ifame的onload函数触发时，也就是上传完成后，可以在iframe中读取到后端返回的数据。 123456var iframe = document.getElementById('upload1');iframe.onload = function () &#123; var doc = window.frames['uploader1'].document; var pre = doc.getElementsByTagName('pre'); var obj = JSON.parse(pre[0].innerHTML);&#125; 使用这种方法时需要注意，iframe有跨域限制，创建出来的iframe的地址如果和当前页面地址不同源，会报错。这种情况下，建议大家在iframe的onload函数中，再次向后端请求一个接口获取文件地址，而不是直接去iframe里读取。或者返回这样的数据。 12345&lt;script type=\"text/javascript\"&gt; window.top.window[callback](data)&lt;/script&gt;callback是和前端约定好的名字，上传完成后触发该函数并返回后端数据。 第二种：使用formData上传。用js构造form表单的数据，简单高效，但最低只兼容IE10，所以需要兼容IE9的童鞋们就略过这个方法吧。 html: 1&lt;input type='file'&gt; js: 12345var formData = new FormData();formData.append(\"userid\", userid);formData.append(\"signature\", signature);formData.append(\"file\", file); //file是blob数据//再用ajax发送formData到服务器即可，注意一定要是post方式上传 说明：第一种方法提到了创建多个type=‘hidden’的input来发送签名数据，这儿可以用formData.append方法来代替该操作，避免了dom中有多个input的情况出现。最后将file数据也append到formData发送到服务器即可完成上传。 优点：由于这种方式是ajax上传，可以准确知道什么时候上传完成，也可以方便地接收到回调数据。 缺点：兼容性差 第三种：使用fileReader读取文件数据进行上传。HTML5的新api，兼容性也不是特别好，只兼容到了IE10。 1234567var fr = new FileReader(); fr.readAsDataURL(file); fr.onload = function (event) &#123; var data= event.target.result; //此处获得的data是base64格式的数据 img.src = data; ajax(url,&#123;data&#125; ,function()&#123;&#125;)&#125; 上面获得的data可以用来实现图片上传前的本地预览，也可以用来发送base64数据给后端然后返回该数据块对应的地址。 优点： 同第二种 缺点：一次性发送大量的base64数据会导致浏览器卡顿，服务器端接收这样的数据可能也会出现问题。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"网页共用头部与尾部方法","slug":"网页共用头部与尾部方法","date":"2019-05-24T13:25:26.977Z","updated":"2019-05-24T13:30:00.861Z","comments":true,"path":"2019/05/24/网页共用头部与尾部方法/","link":"","permalink":"/2019/05/24/网页共用头部与尾部方法/","excerpt":"","text":"一、asp语言和PHP语言首先制作一个头部文件head.asp，或者一个底部文件foot.asp。如主页是index.asp，调用头部代码是在index.asp文件代码的开始位置（第一个标记后面，标记前面）增加如下代码： 1&lt;!– #include file=”head.asp” –&gt; 调用共用底部文件代码是在index.asp文件代码的结束位置（最后一个标记前面）增加如下代码： 1&lt;!– #include file=”foot.asp” –&gt; 如果是PHP文件，文件名改为 footer.php即可。 二、html语言制作一个共用头部文件head.htm或一个共用底部文件foot.htm。如主页文件是index.htm，调用头部和底部文件的方法是：在主页文件代码的开始位置和结束位置分别增加下面的代码： 1&lt;iframe MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no src=”head.htm” height=“auto” width=\"100%\"&gt;&lt;/iframe&gt; 1&lt;iframe MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no src=”foot.htm” height=\"auto\" width=\"100%\"&gt;&lt;/iframe&gt; 比如下面的代码主页面：index.html 123456789101112131415161718&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;&lt;/title&gt;&lt;link href='head.css' rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;script type=\"text/javascript\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body &gt;//主页面index.html&lt;div class='miaov_head'&gt; &lt;iframe MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no src=\"head.html\" width=\"100%\" height=\"auto\"&gt; &lt;/iframe&gt;--------这里调用head.html页面，需要使用div包起来，否则样式会发生改变&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 单独存放的head.html代码如下： 1234567891011121314151617181920212223&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;style&gt;&lt;/style&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;&lt;/title&gt; &lt;link href='head.css' rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body &gt; &lt;div class='miaov_head'&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"http://www.cnblogs.com/jtjds/\"&gt;Mac&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.cnblogs.com/jtjds/\"&gt;iPad&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.cnblogs.com/jtjds/\"&gt;iPhone&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.cnblogs.com/jtjds/\"&gt;Watch&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.cnblogs.com/jtjds/\"&gt;Music&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.cnblogs.com/jtjds/\"&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css样式代码如下： 123456789101112*&#123;margin:0;padding:0;&#125;body&#123;background:white;position:relative;height:100%;color: #777;font-size: 13px;&#125;img&#123;border:none;display:block;&#125;li&#123;list-style:none;text-decoration: none;&#125;.miaov_head&#123;height:36px;width:100%;margin:0 auto;background: black;margin-bottom: 0px;&#125;.miaov_head img&#123;width: 30px ;height: 30px;margin-top: 0;margin-left: 130px;&#125;.miaov_head ul&#123;float: left;width:900px;height: 36px;margin-top: 0px;color: white;position: absolute;top: 0px;margin-left: 200px;&#125;.miaov_head ul li&#123;float: left;padding-left: 80px;margin-left: 0px;color: white;list-style: none; &#125;.miaov_head ul li a&#123;color: white;font-size: 14px;text-decoration: none;&#125;.miaov_head input&#123;position: absolute;top: 5px;margin-left: 1000px;width: 200px;height: 22px;&#125;.miaov_head a&#123;line-height:36px;color:#777;&#125;.miaov_head a:hover&#123;color:#555;&#125; 三、script语言–推荐这种 制作一个共用头部文件head.js和一个共用底部文件foot.js。如主页文件是index.htm，调用头部和底部文件的方法是：在主页文件代码的开始位置和结束位置分别增加下面的代码:和调用共同的网页头部或者网页底部，减少了每个页面都要编写头部或底部的复杂程度，而且方便修改，只要修改一个头部或者底部文件，所有页面的头部或者底部都随之改变，增加了工作效率。 比如：head.js文件——根据上面的head.html，利用转换工具：http://tool.chinaz.com/Tools/Html_Js.aspx html转换为JS: 123456789101112131415161718192021222324document.writeln(\"&lt;!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\"&gt;\");document.writeln(\"&lt;html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"&gt;\");document.writeln(\"&lt;head&gt;\");document.writeln(\"&lt;style&gt;\");document.writeln(\"&lt;/style&gt;\");document.writeln(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\" /&gt;\");document.writeln(\"&lt;title&gt;&lt;/title&gt;\");document.writeln(\" &lt;link href=\\'head.css\\' rel=\\\"stylesheet\\\" type=\\\"text/css\\\" /&gt;\");document.writeln(\"&lt;/head&gt;\");document.writeln(\"&lt;body &gt;\");document.writeln(\" &lt;div class=\\'miaov_head\\'&gt;\");document.writeln(\" &lt;ul&gt;\");document.writeln(\" &lt;li&gt;&lt;a href=\\\"http://www.cnblogs.com/jtjds/\\\"&gt;Mac&lt;/a&gt;&lt;/li&gt;\");document.writeln(\" &lt;li&gt;&lt;a href=\\\"http://www.cnblogs.com/jtjds/\\\"&gt;iPad&lt;/a&gt;&lt;/li&gt;\");document.writeln(\" &lt;li&gt;&lt;a href=\\\"http://www.cnblogs.com/jtjds/\\\"&gt;iPhone&lt;/a&gt;&lt;/li&gt;\");document.writeln(\" &lt;li&gt;&lt;a href=\\\"http://www.cnblogs.com/jtjds/\\\"&gt;Watch&lt;/a&gt;&lt;/li&gt;\");document.writeln(\" &lt;li&gt;&lt;a href=\\\"http://www.cnblogs.com/jtjds/\\\"&gt;Music&lt;/a&gt;&lt;/li&gt;\");document.writeln(\" &lt;li&gt;&lt;a href=\\\"http://www.cnblogs.com/jtjds/\\\"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;\");document.writeln(\" &lt;/ul&gt;\");document.writeln(\"&lt;/div&gt;\");document.writeln(\" \");document.writeln(\"&lt;/body&gt;\");document.writeln(\"&lt;/html&gt;\");document.writeln(\"\"); 以后无论在哪个页面，想调用该头部文件，直接插入head.js文件即可：下面是随便建的一个页面，//MAC.html 12345678910111213&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;style&gt;&lt;/style&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"head.js\"&gt;&lt;/script&gt;-------------------这里调用head.js&lt;/head&gt;&lt;body &gt; &lt;/body&gt;&lt;/html&gt; 四：shtml文件使用ssi技术页面生成shtml文件，只用在头部文件位置加入，然后修改的时候只要修改header.htm文件就可以了。使用shtml的好处是对搜索引擎比较友好，需要处理的文件在服务器端完成的， 不会加重访问者的浏览器负担。 五：本地合并即将HTML硬拆成头、尾、内容三个部分的文件，在预览或者发布之前用脚本手工合并。很久以前用过，没有后台的时候使用效果不错。 六：ajax动态拉取填充七：web服务器（比如IIS）中设定包含比如我们说的SSI，文档后缀名是.shtml的就可以使用include包含。 SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。SSI就是在HTML文件中，可以通过注释行调用的命令或指针，SSI具有 强大的功能，只要使用一条简单的SSI命令就可以实现整个网站的内容更新，时间和日期的动态显示，以及执行shell和CGI脚本程序等复杂的功能。 八：后台模板引擎处理（字符串拼接）","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"js实现表格内容无缝滚动 - v2","slug":"js实现表格内容无缝滚动 - v2","date":"2019-05-24T13:22:04.955Z","updated":"2019-05-24T13:22:31.763Z","comments":true,"path":"2019/05/24/js实现表格内容无缝滚动 - v2/","link":"","permalink":"/2019/05/24/js实现表格内容无缝滚动 - v2/","excerpt":"","text":"直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;table表格无缝向上滚动-jq22.com&lt;/title&gt; &lt;script src=\"https://libs.baidu.com/jquery/1.11.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;style&gt; .tablebox &#123; height: 500px; overflow: hidden; position: relative; width: 1000px; margin: 100px auto; background-color: rgba(6, 26, 103, 1); &#125; .tbl-header &#123; width: 100%; position: absolute; top: 0; left: 0; z-index: 999; &#125; .tbl-body &#123; width: 100%; position: absolute; top: 0; left: 0; &#125; .tablebox table &#123; width: 100%; &#125; .tablebox table th, .tablebox table td &#123; font-size: 24px; color: #7ca6f4; line-height: 45px; text-align: center; &#125; .tablebox table tr th &#123; background-color: #1f1f9c; cursor: pointer; &#125; .tablebox table tr td &#123; background-color: transparent; &#125; .tbl-body tr:nth-child(even) td, .tbl-body1 tr:nth-child(even) td &#123; background-color: rgba(31, 31, 156, .5); &#125; .tablebox table tr td span, .tablebox table tr td span &#123; font-size: 24px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tablebox\"&gt; &lt;div class=\"tbl-header\"&gt; &lt;table border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;地市&lt;/th&gt; &lt;th&gt;销售收入(万元)&lt;/th&gt; &lt;th&gt;同比(%)&lt;/th&gt; &lt;th&gt;环比(%)&lt;/th&gt; &lt;th&gt;销售计划(万元)&lt;/th&gt; &lt;th&gt;计划完成率(%)&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody style=\"opacity:0;\"&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"tbl-body\"&gt; &lt;table border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;地市&lt;/th&gt; &lt;th&gt;销售收入(万元)&lt;/th&gt; &lt;th&gt;同比(%)&lt;/th&gt; &lt;th&gt;环比(%)&lt;/th&gt; &lt;th&gt;销售计划(万元)&lt;/th&gt; &lt;th&gt;计划完成率(%)&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var MyMarhq = ''; clearInterval(MyMarhq); $('.tbl-body tbody').empty(); $('.tbl-header tbody').empty(); var str = ''; var Items = [&#123; \"Ranking\": \"1\", \"City\": \"保定\", \"SaleIncome\": \"2506734.43\", \"SaleRough\": \"296071.96\", \"SalePlan\": \"7200000\", \"PlanFinish\": \"34.82\", \"TonOilincome\": \"264.15\", \"OilTransform\": \"29.62\", \"An\": \"53.00\", \"Mom\": \"-13.00\" &#125;, &#123; \"Ranking\": \"2\", \"City\": \"沧州\", \"SaleIncome\": \"1425935.58\", \"SaleRough\": \"93717.83\", \"SalePlan\": \"3200000\", \"PlanFinish\": \"44.56\", \"TonOilincome\": \"366.59\", \"OilTransform\": \"11.23\", \"An\": \"65.00\", \"Mom\": \"43.00\" &#125;, &#123; \"Ranking\": \"3\", \"City\": \"秦皇岛\", \"SaleIncome\": \"1372207.38\", \"SaleRough\": \"241071.82\", \"SalePlan\": \"3000000\", \"PlanFinish\": \"45.74\", \"TonOilincome\": \"342.32\", \"OilTransform\": \"6.61\", \"An\": \"34.00\", \"Mom\": \"7.00\" &#125;, &#123; \"Ranking\": \"4\", \"City\": \"衡水\", \"SaleIncome\": \"972451.15\", \"SaleRough\": \"87638.60\", \"SalePlan\": \"2700000\", \"PlanFinish\": \"36.02\", \"TonOilincome\": \"246.03\", \"OilTransform\": \"11.56\", \"An\": \"15.00\", \"Mom\": \"-18.00\" &#125;, &#123; \"Ranking\": \"5\", \"City\": \"石家庄\", \"SaleIncome\": \"939010.52\", \"SaleRough\": \"140217.37\", \"SalePlan\": \"7200000\", \"PlanFinish\": \"13.04\", \"TonOilincome\": \"139.44\", \"OilTransform\": \"19.23\", \"An\": \"-57.00\", \"Mom\": \"-48.00\" &#125;, &#123; \"Ranking\": \"6\", \"City\": \"邢台\", \"SaleIncome\": \"774274.70\", \"SaleRough\": \"124693.90\", \"SalePlan\": \"3700000\", \"PlanFinish\": \"20.93\", \"TonOilincome\": \"138.87\", \"OilTransform\": \"9.44\", \"An\": \"-20.00\", \"Mom\": \"-44.00\" &#125;, &#123; \"Ranking\": \"7\", \"City\": \"唐山\", \"SaleIncome\": \"680456.79\", \"SaleRough\": \"50542.14\", \"SalePlan\": \"3600000\", \"PlanFinish\": \"18.90\", \"TonOilincome\": \"243.60\", \"OilTransform\": \"16.95\", \"An\": \"-29.00\", \"Mom\": \"-49.00\" &#125;, &#123; \"Ranking\": \"8\", \"City\": \"张家口\", \"SaleIncome\": \"613319.87\", \"SaleRough\": \"176075.96\", \"SalePlan\": \"3000000\", \"PlanFinish\": \"20.44\", \"TonOilincome\": \"87.09\", \"OilTransform\": \"7.97\", \"An\": \"2.00\", \"Mom\": \"-24.00\" &#125;, &#123; \"Ranking\": \"9\", \"City\": \"中油华奥\", \"SaleIncome\": \"596575.25\", \"SaleRough\": \"387024.26\", \"SalePlan\": \"11000000\", \"PlanFinish\": \"5.42\", \"TonOilincome\": \"93.58\", \"OilTransform\": \"19.06\", \"An\": \"35.00\", \"Mom\": \"6.00\" &#125;, &#123; \"Ranking\": \"10\", \"City\": \"承德\", \"SaleIncome\": \"589048.12\", \"SaleRough\": \"68966.73\", \"SalePlan\": \"2200000\", \"PlanFinish\": \"26.77\", \"TonOilincome\": \"193.24\", \"OilTransform\": \"11.29\", \"An\": \"30.00\", \"Mom\": \"-28.00\" &#125;, &#123; \"Ranking\": \"11\", \"City\": \"廊坊\", \"SaleIncome\": \"515448.14\", \"SaleRough\": \"137934.72\", \"SalePlan\": \"3500000\", \"PlanFinish\": \"14.73\", \"TonOilincome\": \"95.47\", \"OilTransform\": \"8.80\", \"An\": \"-48.00\", \"Mom\": \"-3.00\" &#125;, &#123; \"Ranking\": \"12\", \"City\": \"瑞州\", \"SaleIncome\": \"399875.26\", \"SaleRough\": \"85371.46\", \"SalePlan\": \"2000000\", \"PlanFinish\": \"19.99\", \"TonOilincome\": \"114.42\", \"OilTransform\": \"11.42\", \"An\": \"128.00\", \"Mom\": \"-30.00\" &#125;, &#123; \"Ranking\": \"13\", \"City\": \"石家庄中油\", \"SaleIncome\": \"90543.62\", \"SaleRough\": \"20065.14\", \"SalePlan\": \"430000\", \"PlanFinish\": \"21.06\", \"TonOilincome\": \"213.44\", \"OilTransform\": \"20.45\", \"An\": \"-24.00\", \"Mom\": \"-17.00\" &#125;, &#123; \"Ranking\": \"14\", \"City\": \"辛集中油\", \"SaleIncome\": \"49255.52\", \"SaleRough\": \"8743.12\", \"SalePlan\": \"250000\", \"PlanFinish\": \"19.70\", \"TonOilincome\": \"202.67\", \"OilTransform\": \"29.95\", \"An\": \"19.00\", \"Mom\": \"-6.00\" &#125;, &#123; \"Ranking\": \"15\", \"City\": \"井陉中油\", \"SaleIncome\": \"29682.60\", \"SaleRough\": \"2175.66\", \"SalePlan\": \"140000\", \"PlanFinish\": \"21.20\", \"TonOilincome\": \"730.20\", \"OilTransform\": \"25.55\", \"An\": \"-74.00\", \"Mom\": \"-52.00\" &#125;, &#123; \"Ranking\": \"16\", \"City\": \"保定中油\", \"SaleIncome\": \"11887.73\", \"SaleRough\": \"2944.97\", \"SalePlan\": \"100000\", \"PlanFinish\": \"11.89\", \"TonOilincome\": \"118.12\", \"OilTransform\": \"34.16\", \"An\": \"-64.00\", \"Mom\": \"-72.00\" &#125; ] $.each(Items, function (i, item) &#123; str = '&lt;tr&gt;' + '&lt;td&gt;' + item.Ranking + '&lt;/td&gt;' + '&lt;td&gt;' + item.City + '&lt;/td&gt;' + '&lt;td&gt;' + (+item.SaleIncome / 10000).toFixed(2) + '&lt;/td&gt;' + '&lt;td&gt;' + (+item.An).toFixed(2) + '&lt;/td&gt;' + '&lt;td&gt;' + (+item.Mom).toFixed(2) + '&lt;/td&gt;' + '&lt;td&gt;' + (item.SalePlan / 10000).toFixed(2) + '&lt;/td&gt;' + '&lt;td&gt;' + (+item.PlanFinish).toFixed(2) + '&lt;/td&gt;' + '&lt;/tr&gt;' $('.tbl-body tbody').append(str); $('.tbl-header tbody').append(str); &#125;); if (Items.length &gt; 10) &#123; $('.tbl-body tbody').html($('.tbl-body tbody').html() + $('.tbl-body tbody').html()); $('.tbl-body').css('top', '0'); var tblTop = 0; var speedhq = 50; // 数值越大越慢 var outerHeight = $('.tbl-body tbody').find(\"tr\").outerHeight(); function Marqueehq() &#123; if (tblTop &lt;= -outerHeight * Items.length) &#123; tblTop = 0; &#125; else &#123; tblTop -= 1; &#125; $('.tbl-body').css('top', tblTop + 'px'); &#125; MyMarhq = setInterval(Marqueehq, speedhq); // 鼠标移上去取消事件 $(\".tbl-header tbody\").hover(function () &#123; clearInterval(MyMarhq); &#125;, function () &#123; clearInterval(MyMarhq); MyMarhq = setInterval(Marqueehq, speedhq); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"Linux常用命令大全","slug":"Linux常用命令大全","date":"2019-05-24T13:16:55.117Z","updated":"2019-05-24T13:20:04.487Z","comments":true,"path":"2019/05/24/Linux常用命令大全/","link":"","permalink":"/2019/05/24/Linux常用命令大全/","excerpt":"","text":"系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/ . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name .jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \\; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/ 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ #/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)ip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database GO TOP INDEX ^Microsoft Windows networks (SAMBA)nbtscan ip_addr netbios name resolutionnmblookup -A ip_addr netbios name resolutionsmbclient -L ip_addr/hostname show remote shares of a windows hostsmbget -Rr smb://ip_addr/share like wget can download files from a host windows via smbmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"预览input-file上传的图片","slug":"预览input-file上传的图片","date":"2019-05-23T09:05:02.196Z","updated":"2019-05-23T09:06:29.822Z","comments":true,"path":"2019/05/23/预览input-file上传的图片/","link":"","permalink":"/2019/05/23/预览input-file上传的图片/","excerpt":"","text":"直接上代码12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" onchange=\"display(this)\"/&gt; &lt;img id=\"displayImg\" /&gt; &lt;script&gt; function display(obj) &#123; var file = obj.files[0]; var reader = new FileReader(); //注册相关的回调 //成功后的回调，最重要的一个 reader.onload = function (e) &#123; //展示 var img = document.getElementById(\"displayImg\"); img.src = e.target.result; &#125; //读取 reader.readAsDataURL(file) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"input输入内容，每隔4位空格","slug":"input输入内容，每隔4位空格","date":"2019-05-23T07:49:04.156Z","updated":"2019-05-23T07:50:18.928Z","comments":true,"path":"2019/05/23/input输入内容，每隔4位空格/","link":"","permalink":"/2019/05/23/input输入内容，每隔4位空格/","excerpt":"","text":"直接上代码1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" size=\"50\"&gt; &lt;script&gt; let input = document.querySelector('input') input.onkeydown = function () &#123; let val = this.value this.value = val.replace(/\\s/g, '').replace(/(.&#123;4&#125;)/g, \"$1 \"); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"js-xlsx 读取、写入Excel表","slug":"js-xlsx 读取、写入Excel表","date":"2019-05-20T07:59:27.474Z","updated":"2019-05-22T06:01:12.003Z","comments":true,"path":"2019/05/20/js-xlsx 读取、写入Excel表/","link":"","permalink":"/2019/05/20/js-xlsx 读取、写入Excel表/","excerpt":"","text":"在实际开发中，经常会遇到导入Excel文件的需求，有的产品人想法更多，想要在前端直接判断文件内容格式是否正确，必填项是否已填写 依据HTML5的FileReader，可以使用新的API打开本地文件（参考这篇文章） FileReader.readAsBinaryString(Blob|File) FileReader.readAsText(Blob|File, opt_encoding) FileReader.readAsDataURL(Blob|File) FileReader.readAsArrayBuffer(Blob|File) 通过 readAsBinaryString 虽然能打开二进制文件（.pdf、.doc、*.xls等），但如若要直接通过JS进行判断这些二进制数据是否符合要求，是不行的 所以就需要转换，对于Excel文件的内容分析转换，已经有了比较成熟的解决方案：js-xlsx 其实现方式也用到了上述新特性，看看具体要怎么用 读取excel表1. 首先定义一个文件上传项 1&lt;input type=\"file\" id=\"excel-file\"&gt; 2. 下载js-xlsx的相应的 xlsx.core.min.js 文件后引入 1&lt;script type=\"text/javascript\" src=\"xlsx.core.min.js\"&gt;&lt;/script&gt; 3. 监听文件选择，即时打开文件获取表格内容 使用XLSX.utils.sheet_to_json方法解析表格对象返回相应的JSON数据 12345678910111213141516171819202122232425262728293031323334$('#excel-file').change(function(e) &#123; var files = e.target.files; var fileReader = new FileReader(); fileReader.onload = function(ev) &#123; try &#123; var data = ev.target.result, workbook = XLSX.read(data, &#123; type: 'binary' &#125;), // 以二进制流方式读取得到整份excel表格对象 persons = []; // 存储获取到的数据 &#125; catch (e) &#123; console.log('文件类型不正确'); return; &#125; // 表格的表格范围，可用于判断表头是否数量是否正确 var fromTo = ''; // 遍历每张表读取 for (var sheet in workbook.Sheets) &#123; if (workbook.Sheets.hasOwnProperty(sheet)) &#123; fromTo = workbook.Sheets[sheet]['!ref']; console.log(fromTo); persons = persons.concat(XLSX.utils.sheet_to_json(workbook.Sheets[sheet])); // break; // 如果只取第一张表，就取消注释这行 &#125; &#125; console.log(persons); &#125;; // 以二进制方式打开文件 fileReader.readAsBinaryString(files[0]); &#125;); 上述代码只是简单地获取表格文件的内容，如果要判断，还得根据实际加上一些判断逻辑 js-xlsx只能读取相关的文件，否则会报错 4. 表格文件内容 使用一个excel表格，定义了三张表 1 2 3 5. 查看获取到的数据 红框部分为三个表项的不同之处，看看代码执行之后的结果： 4 第一个红框是每张表的数据范围，由于js-xlsx这个库自身的问题，它是不会直接获取到表头数据保存起来的，而是直接把表头放到最末级的内容对象里面 可自行逐级看看读取到的表格workbook对象内容： 5 如果要判断表头的数量，就需要使用到!ref属性 在excel文件中，A1:D3中的字母指代列待号，紧接其后的数字指代行号，所以判断表头数量，即为判断列号数量 比如第一张表有四个表头，所以为A-D;第三张表有五个表头，所以为A-E，如 123if (fromTo[0] === 'A' &amp;&amp; fromTo[3] === 'D') &#123; excelIsOk = true;&#125; 这只是单单判断表头数量，还得判断表头内容 12345678910console.log(persons);var headStr = '姓名,性别,年龄,学校';for (var i = 0; i &lt; persons.length; i++) &#123; if (Object.keys(persons[i]).join(',') !== headStr) &#123; persons.splice(i, 1); &#125;&#125;console.log(persons); 6 可以看到，倒数第二项的JSON数据，因为表头内容不匹配，被过滤掉了 这里还得注意的是最后一项，虽然有个表头，但因为没有内容，所以得到的JSON是符合要求的，所以就需要用到那个!ref属性来共同判断表格是否符合要求 7 6. 其他 除此之外，还有更多用法如XLSX.readFile、XLSX.writeFile等，具体就看看官方文档吧 代码示例版本1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./xlsx.core.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" onchange=\"importf(this)\" /&gt; &lt;script&gt; var rABS = false; //是否将文件读取为二进制字符串 function importf(obj) &#123; //导入 if (!obj.files) &#123; return; &#125; var f = obj.files[0]; &#123; var reader = new FileReader(); var name = f.name; reader.onload = function (e) &#123; var data = e.target.result; var wb; if (rABS) &#123; wb = XLSX.read(data, &#123; type: 'binary' &#125;); &#125; else &#123; var arr = fixdata(data); wb = XLSX.read(btoa(arr), &#123; type: 'base64' &#125;); &#125; // 结果json输出 console.log(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]])); &#125;; if (rABS) reader.readAsBinaryString(f); else reader.readAsArrayBuffer(f); &#125; &#125; function fixdata(data) &#123; var o = \"\", l = 0, w = 10240; for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w))); o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w))); return o; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 版本2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"./xlsx.core.min.js\"&gt;&lt;/script&gt; &lt;input type=\"file\" id=\"excel-file\"&gt; &lt;script&gt; var file = document.querySelector('input') file.onchange = function (e) &#123; var files = e.target.files; var fileReader = new FileReader(); fileReader.onload = function (ev) &#123; try &#123; var data = ev.target.result, workbook = XLSX.read(data, &#123; type: 'binary' &#125;), // 以二进制流方式读取得到整份excel表格对象 persons = []; // 存储获取到的数据 &#125; catch (e) &#123; console.log('文件类型不正确'); return; &#125; // 表格的表格范围，可用于判断表头是否数量是否正确 var fromTo = ''; // 遍历每张表读取 for (var sheet in workbook.Sheets) &#123; if (workbook.Sheets.hasOwnProperty(sheet)) &#123; // fromTo = workbook.Sheets[sheet]['!ref'] = 'A2:C4' 设置取值范围 fromTo = workbook.Sheets[sheet]['!ref'] = 'A2:C100' persons = persons.concat(XLSX.utils.sheet_to_json(workbook.Sheets[sheet])); // break; // 如果只取第一张表，就取消注释这行 &#125; &#125; console.log(persons); &#125;; // 以二进制方式打开文件 fileReader.readAsBinaryString(files[0]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 导出excel表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=\"downloadExl(jsonDate)\"&gt;导出&lt;/button&gt; &lt;script src=\"./xlsx.core.min.js\"&gt;&lt;/script&gt; &lt;!--调用FileSaver saveAs函数可以实现文件下载--&gt; &lt;!--&lt;script src=\"http://sheetjs.com/demos/Blob.js\"&gt;&lt;/script&gt; &lt;script src=\"http://sheetjs.com/demos/FileSaver.js\"&gt;&lt;/script&gt;--&gt; &lt;script&gt; //如果使用 FileSaver.js 就不要同时使用以下函数 function saveAs(obj, fileName) &#123; //当然可以自定义简单的下载文件实现方式 var tmpa = document.createElement(\"a\"); tmpa.download = fileName || \"下载\"; tmpa.href = URL.createObjectURL(obj); //绑定a标签 tmpa.click(); //模拟点击实现下载 setTimeout(function() &#123; //延时释放 URL.revokeObjectURL(obj); //用URL.revokeObjectURL()来释放这个object URL &#125;, 100); &#125; var jsonDate = [ &#123; //测试数据 \"保质期临期预警(天)\": \"adventLifecycle\", 商品标题: \"title\", 建议零售价: \"defaultPrice\", \"高(cm)\": \"height\", 商品描述: \"Description\", \"保质期禁售(天)\": \"lockupLifecycle\", 商品名称: \"skuName\", 商品简介: \"brief\", \"宽(cm)\": \"width\", 阿达: \"asdz\", 货号: \"goodsNo\", 商品条码: \"skuNo\", 商品品牌: \"brand\", \"净容积(cm^3)\": \"netVolume\", 是否保质期管理: \"isShelfLifeMgmt\", 是否串号管理: \"isSNMgmt\", 商品颜色: \"color\", 尺码: \"size\", 是否批次管理: \"isBatchMgmt\", 商品编号: \"skuCode\", 商品简称: \"shortName\", \"毛重(g)\": \"grossWeight\", \"长(cm)\": \"length\", 英文名称: \"englishName\", \"净重(g)\": \"netWeight\", 商品分类: \"categoryId\", 这里超过了: 1111.0, \"保质期(天)\": \"expDate\" &#125; ]; // 定义导出的格式类型 const wopts = &#123; bookType: 'csv', bookSST: false, type: 'binary' &#125;;//ods // const wopts = &#123; bookType: \"xlsx\", bookSST: false, type: \"binary\" &#125;; //xlsx // const wopts = &#123; bookType: 'ods', bookSST: false, type: 'binary' &#125;;//ods // const wopts = &#123; bookType: 'xlsb', bookSST: false, type: 'binary' &#125;;//xlsb // const wopts = &#123; bookType: 'fods', bookSST: false, type: 'binary' &#125;;//fods // const wopts = &#123; bookType: \"biff2\", bookSST: false, type: \"binary\" &#125;; //xls function downloadExl(data, type) &#123; const wb = &#123; SheetNames: [\"Sheet1\"], Sheets: &#123;&#125;, Props: &#123;&#125; &#125;; wb.Sheets[\"Sheet1\"] = XLSX.utils.json_to_sheet(data); //通过json_to_sheet转成单页(Sheet)数据 saveAs( new Blob([s2ab(XLSX.write(wb, wopts))], &#123; type: \"application/octet-stream\" &#125;), `$&#123;new Date().getTime()&#125;` + \".\" + (wopts.bookType == \"biff2\" ? \"xls\" : wopts.bookType) ); &#125; function s2ab(s) &#123; if (typeof ArrayBuffer !== \"undefined\") &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff; return buf; &#125; else &#123; var buf = new Array(s.length); for (var i = 0; i != s.length; ++i) buf[i] = s.charCodeAt(i) &amp; 0xff; return buf; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在vue中使用npm i xlsx 自定义组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;template&gt; &lt;div class=\"read\"&gt; 上传文件 &lt;input type=\"file\" name=\"file\" id=\"file\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import XLSX from 'xlsx'export default &#123; methods: &#123; init() &#123; let read = document.querySelector('.read') let file = document.querySelector('#file') let that = this read.onclick = function() &#123; file.click() &#125; file.onchange = function(e) &#123; var files = e.target.files var fileReader = new FileReader() fileReader.onload = function(ev) &#123; try &#123; var data = ev.target.result, workbook = XLSX.read(data, &#123; type: 'binary' &#125;), // 以二进制流方式读取得到整份excel表格对象 persons = [] // 存储获取到的数据 &#125; catch (e) &#123; alert('文件类型不正确') return &#125; // 表格的表格范围，可用于判断表头是否数量是否正确 var fromTo = '' // 遍历每张表读取 for (var sheet in workbook.Sheets) &#123; if (workbook.Sheets.hasOwnProperty(sheet)) &#123; // fromTo = workbook.Sheets[sheet]['!ref'] = 'A2:C4' 设置取值范围 fromTo = workbook.Sheets[sheet]['!ref'] = 'A2:C100' persons = persons.concat( XLSX.utils.sheet_to_json(workbook.Sheets[sheet]) ) // break; // 如果只取第一张表，就取消注释这行 &#125; &#125; // console.log(persons) that.$emit('result', persons) &#125; // 以二进制方式打开文件 fileReader.readAsBinaryString(files[0]) &#125; &#125; &#125;, mounted() &#123; this.init() &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.read &#123; width: 500px; height: 50px; line-height: 50px; background: red; text-align: center; user-select: none; cursor: pointer; #file &#123; display: none; &#125;&#125;&lt;/style&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"exports与export的区别","slug":"exports与export的区别","date":"2019-05-20T07:09:41.895Z","updated":"2019-05-20T07:11:43.847Z","comments":true,"path":"2019/05/20/exports与export的区别/","link":"","permalink":"/2019/05/20/exports与export的区别/","excerpt":"","text":"首先我们要明白一个前提，CommonJS模块规范和ES6模块规范完全是两种不同的概念。CommonJS模块规范Node应用由模块组成，采用CommonJS模块规范。 根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 1234var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 exports 与 module.exports为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 1var exports = module.exports; 于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 ES6模块规范不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; export default 命令使用export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log('foo');&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"Vue接入腾讯防水墙","slug":"Vue接入腾讯防水墙","date":"2019-05-17T06:00:57.464Z","updated":"2019-05-22T02:31:47.315Z","comments":true,"path":"2019/05/17/Vue接入腾讯防水墙/","link":"","permalink":"/2019/05/17/Vue接入腾讯防水墙/","excerpt":"","text":"在created中引入JS123456789101112131415161718192021222324 created() &#123; if (window.TencentCaptcha === undefined) &#123; let ele = document.createElement('script') ele.src = 'https://ssl.captcha.qq.com/TCaptcha.js' document.getElementsByTagName('head')[0].appendChild(ele) &#125; &#125;// 如需要前端提供用户IP created() &#123; if (window.TencentCaptcha === undefined) &#123; let txCaptcha = document.createElement('script') txCaptcha.src = 'https://ssl.captcha.qq.com/TCaptcha.js' document.getElementsByTagName('head')[0].appendChild(txCaptcha) let souhuIP = document.createElement('script') souhuIP.src = 'http://pv.sohu.com/cityjson?ie=utf-8' document.getElementsByTagName('head')[0].appendChild(souhuIP) &#125; &#125;// 使用this.ip: returnCitySN['cip'], 在methods中写入方法123456789101112131415login() &#123; var captcha = new TencentCaptcha('AppID', function(res) &#123; // res（未通过验证）= &#123;ret: 1, ticket: null&#125; // res（验证成功） = &#123;ret: 0, ticket: \"String\", randstr: \"String\"&#125; if (res.ret === 0) &#123; //票据 //alert(res.ticket) //随机串 //alert(res.randstr) // submitForm() &#125; &#125;) // 显示验证码 captcha.show()&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"前端文件下载方式总结","slug":"前端文件下载方式总结","date":"2019-05-16T08:50:57.029Z","updated":"2019-05-25T03:41:35.808Z","comments":true,"path":"2019/05/16/前端文件下载方式总结/","link":"","permalink":"/2019/05/16/前端文件下载方式总结/","excerpt":"","text":"api没有任何验证，访问即可下载 api有验证： 通过 header 进行验证 通过 cookie 进行验证 接下来我会针对这三种方式来展示我spike得到的解决方案。 api 没有任何验证 可以直接通过访问该url进行下载，即： 1&lt;a href=\"&#123;download url&#125;\"&gt;download&lt;/a&gt; 使用 download 属性（貌似是html5的新特性），会直接进行文件的下载： 1&lt;a href=\"&#123;download url&#125;\" download=\"&#123;default name&#125;\"&gt;download&lt;/a&gt; 还有一个稍微绕一点的方法（其实是一个东西）： 1234const element = document.createElement('a');element.href = URL.createObjectURL(&#123;download url&#125;);element.download = 'route.xls';element.click(); api 使用 header 进行验证说一点题外话，这个还是花了我一些时间去搞得，因为一提到在前端进行文件下载，很多人提供的解决方案都是没有验证中的第一种。然而目前这种方式并不提供添加 header 功能，所以 html 提供的 download 新特性没法使用。 可以先将文件下载拆解成两个步骤： 获取文件内容 将文件进行保存 step 1 肯定是可行，只需要发送request请求，带上header就可以很好的得到文件内容。 step 2 有一个问题，如何保存文件。由于web端无法直接将文件写到用户的磁盘上，需要通过浏览器来进行。可以使用的一个方法就是上边提到过的那个稍微绕一点的方法的修改版： 将文件写到一个Blob中，然后为这个Blob创建一个新的页面，进入到这个页面，就会进行下载。 12345const element = document.createElement('a');const file = new Blob([data]);element.href = URL.createObjectURL(file);element.download = 'route.xls';element.click(); api 使用 cookie 进行验证这个我还没有进行了解过。。。看到过有人说，如果食用cookie验证的话，前端的实现就同没有验证的实现是相同的。由于我并不了解，不多说。。。。 坑这里记录一下我踩过的大坑。我在获取文件内容的时候使用了一个第三方库，我在之前使用的时候获取到的json都是没有问题的，但是这个库在发送request的时候如果没有设置encoding，会自动将获取的内容转码，这个是事先我不知道的。所以保存下来的文件一直都是乱码。 一个教训就是，在传送像文件这种流的数据（只要不是string的数据），最好不要使用第三方库，而是使用比较原生的方法会比较好。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"Vue - 基础","slug":"Vue - 基础","date":"2019-05-16T08:50:56.998Z","updated":"2019-05-18T05:44:02.069Z","comments":true,"path":"2019/05/16/Vue - 基础/","link":"","permalink":"/2019/05/16/Vue - 基础/","excerpt":"","text":"md格式有问题，需要整理","categories":[{"name":"Vue","slug":"Vue","permalink":"/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"mock.js+easyMock","slug":"mock.js+easyMock","date":"2019-05-16T08:50:56.842Z","updated":"2019-05-18T05:04:21.043Z","comments":true,"path":"2019/05/16/mock.js+easyMock/","link":"","permalink":"/2019/05/16/mock.js+easyMock/","excerpt":"","text":"mock和easymockWHY? mock.js and easymock 对于全端开发工程师在与后台同学协同开发的时候会遇到问题: (问号脸)后台接口都没有,请求个吉尔? 我们只能使用比如Apache/node等后台语言搭建一个服务器,再加上Mysql数据库加上可视化Navicat,给我们提供数据服务. 很烦,因为我们要模拟假数据表,关联数据库,测试运行后台服务并解决跨域等问题,然后才能做 前端开发,很难受,假如有一款在线工具能按照我们的接口文档咔咔往上整数据,然后发送的ajax请求都能响应且数据格式正确, 这就很舒服 ,最好能和Vue等主流框架配合使用那就更舒服了(到vue再说). 面试装逼: Mock.js是一款前端开发中拦截Ajax请求再生成随机数据响应的工具.可以用来模拟服务器响应. 优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型. 思考: 提个简单的开发需求: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051请求后台某个接口,返回10-15条学生数据: 要求包含 姓名,年龄,性别. 成功状态码:200 .成功状态信息: success.`响应数据结构分析:`&#123; status:200, msg:'success', stuInfo: &#123; name:'abc', age:10, gender:0 &#125; , ... , &#123; name:'abc', age:10, gender:0 &#125; ]&#125;`方法1: 模拟后台(node/php + mysql)` 1,搭建node服务器/Apache服务器 2,开启Mysql服务, 制定数据库,数据表,添加表信息(添加姓名,年龄,性别的值 和 值类型) 3,使用node或者php语法关联数据库,声明查询sql语句,并执行sql. 4,将查询db内容处理为json返回代码量: 前端ajax+模板引擎20行左右 + 后台实现代码40行左右 + 繁琐的数据表设计 + 一条条的添加数据库内容 = BOOM心态爆炸!!!// 或者你可以...`方法2: 完全脱离后台和数据库(mockjs配合vue的拦截器),或者 脱离数据库操作(mockjs简单的node后台)` 1,搭建node服务器 2,使用mockjs的mock方法制定随机数据 3,处理为json返回代码量: 前端ajax+模板引擎20行左右 + node服务响应mock数据11行 = 咦嘿嘿很开心!代码: const app = reqire('express') const Mock = require('mockjs') app.get('/someApi',(req,res)=&gt;&#123; var resData = Mock.mock(&#123; 'status':200, 'msg':'success', 'stuData|10-20':[&#123; 'name|1-3':/[a-z][A-Z]/, 'age|+1':10, 'gender|1':true &#125;] &#125;) res.end(JSON.stringify(resData)) &#125;) app.listen(3000) 一 Mockjs怎么用?1 mock.js的使用1.1.1 安装并引入mock.js 创建一个node服务器–server.js文件 123456789101112// 引入expressconst express = require('express');// 创建服务对象const app = express()// 准备数据var data = '123'// 监听路由app.get('/', (req, res) =&gt; &#123; res.end(data);&#125;)// 开启服务app.listen(3000) 1.1.2 安装并引入mock.js 123npm install mockjs 或者 script:src=&quot;http://mockjs.com/dist/mock.js&quot; 1.1.3 mockjs模块模拟数据123456789101112131415161718192021222324// 引进expressconst express = require('express');// 引进mockjsconst Mock = require('mockjs')// 准备服务对象const app = express()// 监听路由app.get('/', (req, res) =&gt; &#123; // 准备随机数据 var data = Mock.mock(&#123; 'list|1-20': [&#123; 'name|3-5': /[a-z][A-Z]/, 'age|10-15': 15, 'gender|1': true, &#125;] &#125;) res.end(JSON.stringify(data));&#125;)// 开启服务app.listen(3000) 1.1.4 测试服务在terminal窗口中运行命令nodemoon server.js在浏览器中请求127.0.0.1:3000 观察响应体 1.1.5 使用这样在ajax请求相关接口就能返回内容随机,结构固定的JSON数据了 2 mockjs语法2.1 Mock.mock()方法 加对象参数就可以生成响应数据 2.2 参数对象模板规则 属性名|生成规则：属性值 name | rule : value name: 生成数据的名字字符串 |: 一定要加 rule: 生成数据的规则|min-max 生成个数min至max条 |count 生成count条 |min-max.dmin-dmax 1-9.2-3 数字值在1-9之间,小数点后保留2-3位 如 2.1 3.74 |min-max.dcount 1-9.2 数字值在1-9之间,小数点后保留2位 如2.13 8.54 |count.dmin-dmax 10.1-2 整数部分是10,小数点部分1-2位 如10.99 10.1 |count.dcount 10.2 整数部分是10,小数点部分2位 如10.11 10.43 |+step &apos;score|+1&apos;:1, 以value 1为基准,递增1 value: 属性值的规则 字符串 &apos;name|min-max&apos;: string 通过重复 string 生成一个字符串，min&lt;=重复次数&lt;=max &apos;name|count&apos;: string 通过重复 string 生成一个字符串，重复次数==count。 数字 &apos;name|+1&apos;: number 属性值自动加 1，初始值为 number。 &apos;name|min-max&apos;: number number确定数据类型,生成值在min-max间的整数 &apos;name|min-max.dmin-dmax&apos;: number number确定数据类型,生成值在min-max间的小数 布尔&apos;name|1&apos;: boolean 随机生成一个布尔值,真假各50% &apos;name|t-f&apos;: true 随机生成一个布尔值,真占t/t+f 假占f/t+f 对象 &apos;name|count&apos;: object 从属性值 object 中随机选取 count 个属性。 &apos;name|min-max&apos;: object 从属性值 object 中随机选取 min 到 max 个属性。 数组 &apos;name|1&apos;: array 从属性值 array 中随机选取 1 个元素，作为最终值。 &apos;name|+1&apos;: array 从属性值 array 中顺序选取 1 个元素，作为最终值。 &apos;name|min-max&apos;: array 通过重复属性值 array 生成一个新数组，重复次数大于等于 min，小于等于 max。 &apos;name|count&apos;: array 通过重复属性值 array 生成一个新数组，重复次数为 count。 var data = mock.mock({ // 将value数组中的项(对象) 重复计算1-10次 添加到新数组返回 &apos;obj|1-10&apos;:[ { &apos;score|+1&apos;:1 } ] }) //生成 { obj: [ { score: 1 }, { score: 2 }, { score: 3 }, { score: 4 } ] } 函数(不用) &apos;name&apos;: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 &apos;name&apos; 所在的对象。 正则&apos;name&apos;: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。/[a-z][A-Z][0-9]/ /\\w\\W\\s\\S\\d\\D/ /\\d{5,10}/ [\\u4e00-\\u9fa5] 2.3 Mock.valid( template, data ) 校验数据(处理请求发送来的数据,如果完全脱离后台就需要该方法) 在vue中可以脱离后台开发(到下个自习说) template 必选, 表示数据模板，可以是对象或字符串 data 必选, 表示真实数据12345678910// 可以用来做基于mock的ajax请求参数的处理var template = &#123; name: 'value1'&#125;var data = &#123; name: 'value2'&#125;Mock.valid(template, data)//返回值是一个校验结果数组// 如果匹配则 返回空数组// 如果不匹配 messages属性表示tteamplate和data不匹配的原因 2.4 Mock.random工具对象 Mock.Random 是一个工具类，用于生成各种随机数据。不用掌握,用到就点击蓝字查 3 easymock的使用 3.1 注册 3.2 注意右侧的使用文档右键新窗口打开 3.3 快速开始 - 创建一个项目 点击左侧演示项目 3.5 打开项目设置 3.6 配置接口点击保存,提示更新成功就OK了 3.7 接口列表配置记录当前项目的基本地址 `Base URL,注意要记录自己项目的啊!` https://www.easy-mock.com/mock/5bcd7381617c6c67bc2a20f8/itcast 点击3.1左侧项目,进入个人项目,点击创建接口 3.8 接口配置页面: 左侧是当前接口返回值设置,右侧接口请求方式,地址等设置 将以下代码粘贴至左侧区域,并配置右侧选项 1234567891011 &#123; //响应状态码 'status': 200, // stus 值为数组 'stus|5-10': [&#123; 'name|2-4': /[\\u4e00-\\u9fa5]/, //生辰任意内容的字符串 'age|+1': 1, 'score|1-100': 100 &#125;]&#125; 3.9创建或更新接口后会返回到列表页面, 点击预览按钮如果能够看到响应的数据,就说明本次请求配置是欧克的 3.10使用 POSTMan测试接口`拼接地址注意: 要使用easymock项目的BaseUrl 和 测试接口的地址&quot;test&quot;拼接` 3.11欧克,现在你可以脱离数据库及后台的配置发送ajax请求直接拿数据啦!","categories":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/categories/扩展阅读/"}],"tags":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/tags/扩展阅读/"}]},{"title":"JS遍历对象、数组总结","slug":"JS遍历对象、数组总结","date":"2019-05-16T08:50:56.826Z","updated":"2019-05-18T05:28:13.615Z","comments":true,"path":"2019/05/16/JS遍历对象、数组总结/","link":"","permalink":"/2019/05/16/JS遍历对象、数组总结/","excerpt":"","text":"对象使用for..in..遍历 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性) 12345var obj = &#123;'0':'a','1':'b','2':'c'&#125;; for(var i in obj) &#123; console.log(i,\":\",obj[i]);&#125; 使用Object.keys()遍历 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性) 12345var obj = &#123;'0':'a','1':'b','2':'c'&#125;; Object.keys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 使用Object.getOwnPropertyNames(obj)遍历 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性) 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 使用Reflect.ownKeys(obj)遍历 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Reflect.ownKeys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;) 数组forEach - 遍历 遍历数组全部元素，利用回调函数对数组进行操作 自动遍历数组.length次数，且无法break中途跳出循环 12345678const arr = [1, 2, 3]arr.forEach((el, index, arr) =&gt; &#123; console.log(`$&#123;el&#125;, $&#123;index&#125;,`, arr)&#125;)// 输出// 1, 0, [ 1, 2, 3, 4, 5 ]// 2, 1, [ 1, 2, 3, 4, 5 ]// 3, 2, [ 1, 2, 3, 4, 5 ] map - 遍历、创建 创建新数组 不改变原数组 输出的是return什么就输出什么新数组 回调函数参数，item(数组元素)、index(序列)、arr(数组本身) 使用return操作输出，会循环数组每一项，并在回调函数中操作 12345678910const arr = [1, 2, 3]const newArr = arr.map((el, index, arr) =&gt; &#123; return el * 2&#125;)console.log(newArr) // [ 2, 4, 6 ]// 如果没有返回值将会返回undefinedconst newArr = arr.map((el, index, arr) =&gt; &#123; // return el * 2&#125;)console.log(newArr) // [ undefined, undefined, undefined ] filter - 筛选、创建 创建新数组 不改变原数组 输出的是判断为true的数组元素形成的新数组 回调函数参数，item(数组元素)、index(序列)、arr(数组本身) 使用return操作输出，会循环数组每一项，并在回调函数中操作 12345const arr = [1, 2, 3, 4, 5]const newArr = arr.filter((el, index, arr) =&gt; &#123; return el &gt; 2&#125;)console.log(newArr) // [ 3, 4, 5 ] includes - 筛选只是判断数组是否含有某值，不用return，不用回调函数，输出一个true或false 123var arr = [1,2,3,4,5] ;var new1 = arr.includes(5); console.log(new1) // true find - 筛选 不创建新数组 不改变原数组 输出的是一旦判断为true则跳出循环输出符合条件的数组元素 回调函数参数，item(数组元素)、index(序列)、arr(数组本身) 使用return操作输出，会循环数组每一项，并在回调函数中操作 12345const arr = [1, 2, 3, 4, 5]const result = arr.find((el, index, arr) =&gt; &#123; return el &gt; 3&#125;)console.log(result) // 4 findIndex - 筛选 不创建新数组 不改变原数组 输出的是一旦判断为true则跳出循环输出符合条件的数组元素序列 回调函数参数，item(数组元素)、index(序列)、arr(数组本身) 使用return操作输出，会循环数组每一项，并在回调函数中操作 12345const arr = [1, 2, 3, 4, 5]const index = arr.findIndex((el, index, arr) =&gt; &#123; return el &gt; 3&#125;)console.log(index) // 4 some - 判断 不创建新数组 不改变原数组 输出的是判断为true则马上跳出循环并return成true 回调函数参数，item(数组元素)、index(序列)、arr(数组本身) 使用return操作输出，会循环数组每一项，并在回调函数中操作 12345const arr = [1, 2, 3, 4, 5]const result = arr.some((el, index, arr) =&gt; &#123; return el &gt; 2&#125;)console.log(result) // true every - 判断 不创建新数组 不改变原数组 输出的是判断为false则马上跳出循环并return成false 回调函数参数，item(数组元素)、index(序列)、arr(数组本身) 使用return操作输出，会循环数组每一项，并在回调函数中操作 12345const arr = [1, 2, 3, 4, 5]const result = arr.every((el, index, arr) =&gt; &#123; return el &gt; 2&#125;)console.log(result) // false reduce / reduceRightreduce / reduceRight比上面的方法复杂一点，其语法如下 array.reduce(callback,[initialValue]) callback接收四个参数 accumulator 上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 数组中正在处理的元素 currentIndex 数组中正在处理的元素索引，如果提供了initialValue ，从0开始；否则从1开始。 array 数组对象本身reduce / reduceRight 方法中，第二个参数（initialValue）是可选的；我们先看一个例子： 12345const arr = [1, 2, 3, 4]const result = arr.reduce((a, b) =&gt; &#123; return a + b&#125;)console.log(result) // 10 接下来分析reduce是如何运行的： 1234567891011const arr = [1, 2, 3, 4]const result = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue&#125;)console.log(result)// output// 1 2 1 [ 1, 2, 3, 4 ]// 3 3 2 [ 1, 2, 3, 4 ]// 6 4 3 [ 1, 2, 3, 4 ]// 10","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"js实现表格内容无缝滚动","slug":"js实现表格内容无缝滚动","date":"2019-05-16T08:50:56.779Z","updated":"2019-05-14T07:43:23.656Z","comments":true,"path":"2019/05/16/js实现表格内容无缝滚动/","link":"","permalink":"/2019/05/16/js实现表格内容无缝滚动/","excerpt":"","text":"直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; table &#123; width: 500px; border: 1px solid gray; border-collapse: collapse; &#125; th, td &#123; line-height: 35px; border: 1px solid gray; text-align: center; width: 120px; &#125; .scroll-box &#123; height: 195px; width: 500px; overflow: hidden; position: relative; &#125; .tab-scroll &#123; position: absolute; left: 0; top: 0; transition: all 1s; border-top: none; &#125; .tab-scroll td &#123; border-top: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table class=\"top\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;住址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;div class=\"scroll-box\"&gt; &lt;table class=\"tab-scroll\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1001&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1002&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1003&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1004&lt;/td&gt; &lt;td&gt;Jack&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1005&lt;/td&gt; &lt;td&gt;小兰&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1006&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1007&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1008&lt;/td&gt; &lt;td&gt;Jack&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1009&lt;/td&gt; &lt;td&gt;小兰&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;td&gt;AAAA&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 2.实现表格滚动(每次滚动一行) var scrollTab = document.getElementsByClassName('tab-scroll')[0]; //滚动的表格 var tbody = scrollTab.getElementsByTagName('tbody')[0]; //tbody var speed = scrollTab.getElementsByTagName('td')[0].offsetHeight + 1; //行高(滚动速度) 加上表格边框 var count = 0; //要追加到表格底部的行索引 setInterval(scrollTop, 1000); //每隔1秒滚动一次 //实现表格向上滚动 function scrollTop() &#123; var t = scrollTab.offsetTop; //top值 scrollTab.style.top = t - speed + 'px'; //滚动 var trs = tbody.getElementsByTagName('tr'); //每次都重新取出所有内容行 var newTr = trs[count].cloneNode(true); //复制行，得到新的行对象 //将滚动的行追加到表格底部 tbody.appendChild(newTr); count++; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"JS获取客户端真实IP","slug":"JS获取客户端真实IP","date":"2019-05-16T08:50:56.779Z","updated":"2019-05-15T07:05:18.876Z","comments":true,"path":"2019/05/16/JS获取客户端真实IP/","link":"","permalink":"/2019/05/16/JS获取客户端真实IP/","excerpt":"","text":"方法一：（所有的平台及浏览器）使用搜狐接口： 1234&lt;script src=\"http://pv.sohu.com/cityjson?ie=utf-8\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;document.write(returnCitySN[\"cip\"]+','+returnCitySN[\"cname\"])&lt;/script&gt; 方法二：（所有的平台及浏览器）使用新浪接口：(我测试过，此方法好像不行。访问网站也不能访问了。) 12345678&lt;script type=\"text/javascript\" src=\"http://counter.sina.com.cn/ip/\" charset=\"gb2312\"&gt;&lt;/script&gt; &lt;!--获取接口数据，注意charset --&gt;&lt;script type=\"text/javascript\"&gt;document.writeln(\"IP地址：\"+ILData[0]+\"&lt;br /&gt;\"); //输出接口数据中的IP地址document.writeln(\"地址类型：\"+ILData[1]+\"&lt;br /&gt;\"); //输出接口数据中的IP地址的类型document.writeln(\"地址类型：\"+ILData[2]+\"&lt;br /&gt;\"); //输出接口数据中的IP地址的省市document.writeln(\"地址类型：\"+ILData[3]+\"&lt;br /&gt;\"); //输出接口数据中的IP地址的document.writeln(\"地址类型：\"+ILData[4]+\"&lt;br /&gt;\"); //输出接口数据中的IP地址的运营商&lt;/script&gt; 方法三：个人Robert Hashemian写的： 12345678&lt;script language=\"JavaScript\" src=\"http://www.hashemian.com/js/visitorIP.js.php\"&gt;&lt;/script&gt;&lt;script language=\"JavaScript\"&gt; VIH_BackColor = \"palegreen\"; VIH_ForeColor = \"navy\"; VIH_FontPix = \"16\"; VIH_DisplayFormat = \"You are visiting from:&lt;br&gt;IP Address: %%IP%%&lt;br&gt;Host: %%HOST%%\"; VIH_DisplayOnPage = \"yes\";&lt;/script&gt; 方法四： （只针对IE且客户端的IE允许AcitiveX运行，通过平台：XP，SERVER03，2000） 利用ActiveXObject控件，ie浏览器里要开启此控件： 123&lt;script language=&quot;JavaScript&quot;&gt;function GetLocalIPAddr()&#123; var oSetting = null; var ip = null; try&#123; oSetting = new ActiveXObject(&quot;rcbdyctl.Setting&quot;); ip = oSetting.GetIPAddress; if (ip.length == 0)&#123; return &quot;没有连接到Internet&quot;; &#125; oSetting = null; &#125;catch(e)&#123; return ip; &#125; return ip; &#125; document.write(GetLocalIPAddr()+&quot;&lt;br/&gt;&quot;)&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"element-ui的table表格不对齐问题","slug":"element-ui的table表格不对齐问题","date":"2019-05-16T08:50:56.733Z","updated":"2019-05-18T05:08:34.998Z","comments":true,"path":"2019/05/16/element-ui的table表格不对齐问题/","link":"","permalink":"/2019/05/16/element-ui的table表格不对齐问题/","excerpt":"","text":"问题： 解决方法：将以下样式代码添加到index.html、或app.vue中 123body .el-table colgroup.gutter&#123; display: table-cell!important;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"cookie、session、WebStorage","slug":"cookie、session、WebStorage","date":"2019-05-16T08:50:56.717Z","updated":"2019-05-24T13:16:19.944Z","comments":true,"path":"2019/05/16/cookie、session、WebStorage/","link":"","permalink":"/2019/05/16/cookie、session、WebStorage/","excerpt":"","text":"Cookies 生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好 12345678910111213141516//Cookie方法&lt;script src=\"../js/cookie.js\"&gt;&lt;/script&gt;//Cookie函数自己封装引入function haxi()&#123; if(getCookie(\"isClose\"))&#123; $(\".header\").hide(); &#125;else&#123; $(\".header\").show(); &#125; $(\".close\").click(function()&#123; $(\".header\").fadeOut(1000); setCookie(\"isClose\", \"1\",\"s10\"); &#125;) &#125; haxi(); 缺点： 大小受限，每个cookie有4k限制 用户可以操作（禁用）cookie，使功能受限 安全性较低 每次访问都要传送cookie给服务器，浪费带宽 cookie数据有路径（path）的概念，限制其只属于某个路径下 优点 通过良好的编程，控制保存在cookie中的session对象的大小。 通过加密和安全传输技术，减少cookie被破解的可能性。 只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。 控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。 Session存储在服务器端、与cookie配合使用 WebStorage H5新技术 存储空间更大：单个item数据大小可以达到5MB 节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取使用 只能存储字符串类型 localStorage localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 sessionStorage sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API： 1234567localStorage.setItem(\"key\",\"value\");//以“key”为名称存储一个值“value”localStorage.getItem(\"key\");//获取名称为“key”的值localStorage.removeItem(\"key\");//删除名称为“key”的信息。localStorage.clear();//清空localStorage中所有信息 作用域不同！！不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。","categories":[{"name":"本地存储","slug":"本地存储","permalink":"/categories/本地存储/"}],"tags":[{"name":"本地存储","slug":"本地存储","permalink":"/tags/本地存储/"}]},{"title":"axios处理多个baseURL","slug":"axios处理多个baseURL","date":"2019-05-16T08:50:56.701Z","updated":"2019-05-25T04:03:45.926Z","comments":true,"path":"2019/05/16/axios处理多个baseURL/","link":"","permalink":"/2019/05/16/axios处理多个baseURL/","excerpt":"","text":"方法一 抛弃axios的基地址设置，使用单独js文件完成api基地址配置，在请求接口时进行字符串拼接 某config.js文件 123456const baseUrl = &#123; api: 'https://111.111.11.111', api2: 'http://222.222.222.222',&#125;export &#123;baseUrl&#125; .vue文件 1234567891011121314&lt;script&gt; import &#123; baseUrl &#125; from '../../../config-url' export default &#123; methods:&#123; getData () &#123; this.axios.post(baseUrl.api + '/login',JSON.stringify(&#123; userName:'', pwd:'' &#125;)) &#125; &#125; &#125;&lt;/script&gt; 方法二准备工作1, 准备一个utls.js 文件 (路径自己存放,我放到main.js同一目录) 123456789// 导出 对应的不同接口的URL地址module.exports = &#123; domain: &#123; Base_M1_URL: 'http://192.168.2.54:8008', //模块一接口地址 Base_M2_URL: 'http://192.168.2.90:8080', //模块二接口地址 Base_M3_URL: 'http://192.168.2.102:6608', //模块三接口地址 Base_M4_URL: 'http://192.168.2.222:9000', //模块四接口地址 &#125; &#125; 准备工作2,准备一个公用的common.js文件 导入的main.js中(路径自己存放,我放到main.js同一目录) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//1-&gt;common.js中引入axiosimport Axios from 'axios'//2-&gt;对get请求传递过来的参数处理function paramsToUrl(url, params) &#123; if (!params) return url for (var key in params) &#123; if (params[key] &amp;&amp; params[key] != 'undefined') &#123; if (url.indexOf('?') != -1) &#123; url += '&amp;' + '' + key + '=' + params[key] || '' + '' &#125; else &#123; url += '?' + '' + key + '=' + params[key] || '' + '' &#125; &#125; &#125; return url&#125;//3-&gt;在common.js中封装公用方法-----封装请求的方法function requireData(url,params,type,item)&#123; if(!url) return false switch(item)&#123; case M1: url=axios.defaults.baseM1URL break; case M2: url=axios.defaults.baseM2URL break; case M3: url=axios.defaults.baseM3URL break; default: url=axios.defaults.baseM4URL &#125; if(type==='get')&#123; url=paramsToUrl(url, params) return new Promise((resolve,reject)=&gt;&#123; Axios.get(url,params).then(res=&gt;&#123; resolve(res.data) &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;) &#125;else&#123; return new Promise((resolve,reject)=&gt;&#123; Axios.post(url,params).then(res=&gt;&#123; resolve(res.data) &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;) &#125;&#125;export default&#123; install(Vue,options)&#123; //-&gt;接口1的请求数据方法 Vue.prototype.reqM1Service=function(url,params,type)&#123; return requireData.call(this,url,params,type,'M1') &#125; //-&gt;接口2的请求数据方法 Vue.prototype.reqM2Service=function(url,params,type)&#123; return requireData.call(this,url,params,type,'M2') &#125; //-&gt;接口3的请求数据方法 Vue.prototype.reqM3Service=function(url,params,type)&#123; return requireData.call(this,url,params,type,'M3') &#125; //-&gt;接口4的请求数据方法 Vue.prototype.reqM4Service=function(url,params,type)&#123; return requireData.call(this,url,params,type,'M4') &#125; &#125;&#125; 第一步，在项目 main.js 引入axios和utls.js和common.js123456789101112131415161718//在main.js中引入axiosimport axios from 'axios'//引入 utls.jsimport &#123;domain&#125; from './utls.js'//引入 common.jsimport common from './common.js'//配置axios//-&gt;1,模块一接口,url地址axios.defaults.baseM1URL = domain.Base_M1_URL//-&gt;2,模块二接口,url地址axios.defaults.baseM2URL = domain.Base_M2_URL//-&gt;3,模块三接口,url地址axios.defaults.baseM3URL = domain.Base_M3_URL//-&gt;4,模块四接口,url地址axios.defaults.baseM4URL = domain.Base_M4_URL 第二步,在组件中直接使用封装好的方法调用服务,请求数据12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;h2&gt;&#123;&#123;test&#125;&#125;&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: function() &#123; return &#123; test: \"这是一个测试案例\" &#125;; &#125;, mounted() &#123; let url = \"/login\"; let params = &#123; username: \"test\", pass: \"123\", token: \"1112212123123\" &#125;; //-&gt;调用第一个接口的请求服务 this.reqM1Service(url, params).then( res =&gt; &#123; console.log(res); &#125; ); //-&gt;调用第2个接口的请求服务 this.reqM2Service(url, params).then( res =&gt; &#123; console.log(res); &#125; ); &#125;&#125;;&lt;/script&gt; 优点:1,在不同的组件调用不同的方法就可以实现,不同的接口请求数据;2,维护接口方便,以后上线之后,把utls.js中的接口全部更换成线上接口即可;","categories":[{"name":"Vue","slug":"Vue","permalink":"/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"jQuery - 基础","slug":"2.2.1.jQuery - 基础","date":"2019-05-16T08:50:56.670Z","updated":"2019-05-16T04:21:12.446Z","comments":true,"path":"2019/05/16/2.2.1.jQuery - 基础/","link":"","permalink":"/2019/05/16/2.2.1.jQuery - 基础/","excerpt":"","text":"隐式迭代、链式编程 jQuery对象 英文 描述 $(‘选择器’); $是一个函数 var $btn = $(‘#btn’); jQuery(‘选择器’); var $btn = jQuery(‘#btn’) $(dom对象); DOM转jq对象 var div = $(‘div’)[0]; jq转DOM对象 通过$符号调用所返回的jQuery对象的本质就是一个集合（==伪数组==）→ jQuery对象 // 通过index()可获取一组标签中的索引 选择器 英文 中文 描述 $(‘#id’) ID选择器 获取指定ID的元素 $(‘.class’) 类选择器 获取同一类class的元素 $(‘div’) 标签选择器 获取同一类标签的所有元素 $(‘div,p,li’) 并集选择器 使用逗号分隔，只要符合条件之一就可。 $(‘div.redClass’) 交集选择器 获取class为redClass的div元素 $(‘ul &gt; li’) 子代选择器 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 $(‘ul li’) 后代选择器 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 $(‘li:eq(2)’).css(‘color’, ‘red’) :eq(index) 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 $(‘li:odd’).css(‘color’, ‘red’) :odd 获取到的li元素中，选择索引号为奇数的元素 $(‘li:even’).css(‘color’, ‘red’) :even 获取到的li元素中，选择索引号为偶数的元素 children(selector) (‘ul’).children(‘li’) 相当于\\$(‘ull &gt; i’)，子类选择器 find(selector) (‘ul’).find(‘li’) 相当于\\$(‘ul li’),后代选择器 siblings(selector) $(‘#first’).siblings(‘li’) 查找兄弟节点，不包括自己本身。 parent() $(‘#first’).parent() 查找父亲 eq(index) $(‘li’).eq(2) 相当于$(‘li:eq(2)’),index从0开始 end() 找上一级的jq对象 next() $(‘li’).next() 找下一个兄弟 nextAll() prev() $(‘li’).prev() 找上一次兄弟 prevAll() 事件相关 英文 中文 描述 jQuery对象.事件名(事件处理程序); 简单方式 $(‘button’).click(function(){ alert(‘nihao’) }); jQuery对象.on(‘事件名’,事件处理程序); on方式注册 jQuery对象.off(‘click’,事件处理程序名称) 解绑简单的事件 jQuery对象.off(‘click’,‘选择器’,事件处理程序名称) 解绑事件委托注册的事件 jQuery对象.trigger(‘事件名’); 触发事件 通常用于定时器，每隔秒 触发一次某个元素的事件 123456// 事件委托 jQuery对象.on('事件名','选择器',事件处理程序);$('ul').on('click', 'li', function () &#123; // this 是谁？ 当前点击的li console.log(this); alert($(this).text());&#125;); 样式、属性、类名、内容控制 英文 中文 描述 jQuery对象.css(name,value); $(‘div’).css(‘width’,500); jQuery对象.css({ name:value, name:value}); $(‘div’).css({ border:’10px solid blue’, background:’pink’, }); jQuery对象.css(‘样式属性名’); var h = $(‘div’).css(‘height’); jQuery对象.addClass(‘类名’); 添加类名 jQuery对象.removeClass(‘类名’); 移除类名 jQuery对象.toggleClass(‘类名’); 类名切换 jQuery对象.hasClass(‘类名’); 检测类名是否存在 返回布尔值 jQuery对象.attr(name,value) 设置标签的属性 $(“img”).attr(“width”,”180”); jQuery对象.attr(name); 获取标签属性值 removeAttr(name); 移除标签的属性 $(‘input’).prop(‘属性名’); prop方法操作属性 针对：selected、checked、disabled jQuery对象.text(); 操作标签内部的文本 jQuery对象.html(); 操作标签内部的所有内容 jQuery对象.val(); 操作表单元素的内容 动画 英文 中文 描述 jQuery对象.show(speed,easing,fn); 显示 - 参数speed，动画时长，数字→毫秒 - easing，运动的方式，默认swing缓冲,linear匀速 jQuery对象.hide(speed,easing,fn); 隐藏 jQuery对象.toggle(speed,easing,fn); 切换 jQuery对象.slideDown(speed,easing,fn); 下拉 卷曲-显示 jQuery对象.slideUp(speed,easing,fn); 下拉 卷曲-隐藏 jQuery对象.slideToggle(speed,easing,fn); 下拉 卷曲-切换 jQuery对象.fadeIn(speed,easing,fn); 淡入淡出 jQuery对象.fadeOut(speed,easing,fn); 淡入淡出 jQuery对象.fadeToggle(speed,easing,fn); 淡入淡出 animate(params,[speed],[easing],[fn]) 自定义动画 animage({ 样式属性名:目标值, 样式属性名:目标值},1000) jQuery对象.stop(clearQueue,jumpToEnd); 停止动画 2个值 是布尔值 标签元素控制 动态创建元素 中文 $(‘‘) 创建元素 新创建jQuery对象.appendTo(‘父选择器’、父对象); 在最后追加元素 父元素jQuery对象.apeend(新创建的jQuery对象); 新创建jQuery对象.prependTo(‘父元素选择器’); 在前面追加元素 父元素jQuery对象.prepend(新创建的jQuery对象); jQuery对象.remove() 删除元素 删谁就让谁调用这个方法 jQuery对象.empty() 清空元素 清空内部的所有元素及元素相关的事件 jQuery对象.html(‘’); 清空元素 不推荐使用，该方式不会清空事件 jQuery对象.clone(布尔值); 返回克隆好的元素 参数：默认是false,表示仅仅克隆内容。 true，克隆内容和事件 $(“选择器”).before(html); $(“选择器”).after(html) 操作元素的尺寸 中文 jQuery对象.width(数字); 仅内容部分 jQuery对象.height(数字); 仅内容部分 jQuery对象.innerWidth(数字); 内容部分 + padding jQuery对象.innerHeight(数字); 内容部分 + padding jQuery对象.outerWidth(数字); 内容部分 + padding + border .outerWidth(true) 额外获取margin jQuery对象.outerHeight(数字); 内容部分 + padding + border 操作元素的位置 中文 jQuery对象.offset() 获取的元素的位置，永远参照文档,返回一个对象，对象中包含了元素的位置 jQuery对象.position(); 返回的一个对象，对象中包含了元素的位置，参照最近的定位元素（和定位有关系） jQuery对象.scrollTop(); $(window).scrollTop() 操作卷去的页面间距 JQ - ajax1234567891011121314151617$.ajax(&#123; key:value &#125;） url：请求地址type：请求方法，默认为 getdataType：服务端响应数据类型contentType：请求体内容类型，默认 application/x-www-form-urlencodeddata：需要传递到服务端的数据，如果 GET 则通过 URL 传递，如果 POST 则通过请求体传递timeout：请求超时时间beforeSend：请求发起之前触发success：请求成功之后触发（响应状态码 200）error：请求失败触发complete：请求完成触发（不管成功与否）async：false （将异步请求改为同步）//或者： $.get(url, data, callback) $.post(url, data, callback) 12345678910$.ajax(&#123; url: \"/greet\", data: &#123;name: 'jenny'&#125;, type: \"POST\", dataType: \"json\", success: function(data) &#123; // data = jQuery.parseJSON(data); //dataType指明了返回数据为json类型，故不需要再反序列化 ... &#125;&#125;); 请求头设置12345678910111213141516// 这个是全局的，所有的ajax请求都会加上这个请求头 $(document).ajaxSend(function (event, xhr) &#123; xhr.setRequestHeader(\"custom-header\", \"custom-info\") ; // 增加一个自定义请求头&#125;);// 局部设置请求头$.ajax(&#123; headers:&#123; \"Referer\": \"http://www.baidu.com\" // 有些浏览器不允许修改该请求头 ,\"User-Agent\": \"newLine\" // 有些浏览器不允许修改该请求头 ,\"X-Power\": \"newLine\" ,\"Accept-Language\": \"en-US\" &#125; //...&#125;) ; 其他 英文 描述 入口函数 $(function(){ // 获取元素}); $(document).ready(function(){ // 获取元素}); window.onload会等页面全部加载完执行 只能存在一个，而jq可以存在多个，dpm树结束后就运行 “这俩都是在jq原型中创建一个方法，让jq对象调用（如果用上了this this代码调用者）$.prototype.createTable = function (shuju) {}$.fn.createTable = function (shuju) {}” 英文 描述 事件对象.clientX/Y 参照浏览器 事件对象.preventDefault(); 阻止默认行为 事件对象.pageX/Y 参照文档 事件对象.stopPropagation(); 阻止事件冒泡 事件对象.offsetX/Y 参照事件源 事件对象.keyCode 返回键码数字 事件对象.target; 事件对象.alt/shift/ctrlKey 返回是布尔值。 检测是否按下（true） 英文 描述 多库共存 jq对象 = jQuery.noConflict(); 不 冲突 释放$，改成自定义的对象 var $1 = jQuery.noConflict(); 深/浅拷贝 $.extend([true],obj1,obj2) 对obj1进行 深拷贝、浅拷贝 英文 描述 *.data() 拿标签中的data-* 自定义属性的值 英文 描述 $(selector).load(function) 当指定的元素（及子元素）已加载时，会发生 load() 事件 jQuery.getJSON(url,data,success(data,status,xhr)) 通过 HTTP GET 请求载入 JSON 数据。 jQuery.getScript(url,success(response,status)) getScript() 方法通过 HTTP GET 请求载入并执行 JavaScript 文件。 $(from表单).serialize() 统一获取表单中的数据，以键值对 呈现（input需要name属性） 代码示例回到页面顶端+获取元素位置12345678910// 窗口卷曲事件$(window).scroll(function () &#123; let b = $(window).scrollTop() // 获取页面卷曲值 let a = $('.jia').offset().top //获取元素距离页面订单的px&#125;)$('button').click(function () &#123; $('html,body').animate(&#123; scrollTop: 0 &#125;) //回到页面顶端&#125;)","categories":[{"name":"jQuery","slug":"jQuery","permalink":"/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"/tags/jQuery/"}]},{"title":"html + css - 基础","slug":"1.html + css - 基础","date":"2019-05-16T08:50:56.639Z","updated":"2019-05-14T08:30:24.754Z","comments":true,"path":"2019/05/16/1.html + css - 基础/","link":"","permalink":"/2019/05/16/1.html + css - 基础/","excerpt":"","text":"HTML+CSS定位 英文 中文 描述 position 位置 absolute 绝对定位 relative 相对定位 fixed 固定定位 Static 静态定位 表格 英文 中文 描述 caption 标题 设置表格的标题 cellpadding 单元格边距 设计单元格之间的距离 cellspacing 单元格间距 去掉边框之间的距离，默认值2 多媒体 英文 中文 描述 source 视频源 audio 音频（同视频标签使用） controls 控制栏 autoplay 视频自动播放 loop 循环播放 表单 英文 中文 描述 action 行动 用于提交表单的程序（form标签中的属性） method 方法 get、post（form标签中的属性） readonly 只读的 设置输入框为只读模式 required 必须的 必填项 / 通过input中的list与其id关联 autofocus 自动 焦点 控件自动获取焦点 radio 单选控件 checkbox 复选框 checked 默认选中项 textarea 文本域 TDK 英文 中文 描述 keywords 关键词 description 网页描述 边框 英文 中文 描述 solid 实线边框 dashed 虚线边框 dotted 点线边框 隐藏 英文 中文 描述 overflow:hidden 超出部分隐藏 display 隐藏：none、显示：block 隐藏元素 不占 位置 visibility: hidden 隐藏元素 占 位置 伪元素 英文 中文 描述 ::before 在。。之前 ::after 在。。之后 content 内容 伪元素必须有content，另外默认是行内元素 :first-letter 第一-字母 选中首字母(例：p:first-letter{color: red;}) :last-child{} :last-child{} :nth-child(){} :nth-child(2n){} H5新增布局标签 英文 中文 描述 nav header footer article 文章区域 section 区域,块 背景相关 英文 中文 描述 opacity:0~1 不透明 设置背景颜色的透明度 即有背景色，又有背景图片：background:#ff0000 url(‘smiley.gif’) 其他 英文 中文 描述 cursor:pointer 设置鼠标模式：小手 italic 倾斜 用于font-style，使字体倾斜 overflow：hidden 解决盒子塌陷 其他办法：给父盒子设置边框、浮动、绝对定位 float 浮动 3种清除浮动：overflow：hidden、clear、伪元素+clear vertical-align 垂直居中 行内块元素都有vertical-align（middle） nth-child(5) nth-child(5n) first-child last-child 结构伪类选择器 nth-child(even) nth-child(ood) [属性] {} 属性选择器 box-sizing:border-box 设置盒子实际尺寸 无视border、padding !important 重要的 设置样式优先级 placeholder 文本框的默认值属性 charset meta里面 控制编码的属性 aglin 对齐方式 text-indent 首行缩进 target 目标 text-decoration 《a》 去掉下划线 underline 下划线 hover 鼠标悬浮 focus 焦点 white-space 元素中的空白 overflow 溢出 scroll 卷形物 transparent 透明的 multiple 下拉框多选 属性 white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width:210px; 布局流式布局 英文 中文 描述 通常让width写百分比 例：winth:100% 需要在mate中设置: 伸缩布局 + 弹性布局 英文 中文 描述 display: flex; 需要设置父盒子为弹性布局 flex-direction: 设置主轴方向 flex-direction: row · row-reverse · column · column-reverse justify-content: 设置在主轴的对齐 justify-content: flex-start(默认值) · flex-end · center · space-between ·space-around align-items 侧轴的对齐方式 align-items: flex-start · flex-end · center · baseline · stretch(默认值) flex-wrap 设置元素是否换行显示 flex-wrap: nowrap · wrap align-content 元素换行后的对齐方式 align-content: flex-start· flex-end · center· space-between · space-around ·stretch(默认对齐方式) flex: ; / default 0 / 子元素的伸缩比 属性定义子项目平均分配剩余空间，该子项目占多少份 order:1 设置子元素的排序方式 数值越小，排列越靠前，默认为0。 align-self 子元素自己的对齐方式 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果父元素没有，则等同于stretch。 响应式布局 英文 中文 描述 通过媒体查询+样式层叠改变页面样式 媒体查询 英文 中文 描述 @media 媒体 @media only screen and (width: 320px) and (height: 568px) {html{font-size: 16px;}} all 所有的设备 print 打印设备 screen 电脑、平板、手机 orientation: portrait 竖屏 orientation: landscape 横屏 only 指定某个特定的媒体类型, 可以省略 and 可以将多个媒体特性链接到一块,相当于且 not 排除某个媒体特性 相当于非,可以省略 动画过度 英文 中文 描述 transition-property: all; 过渡-性质 设置哪些属性有动画效果,连写必填 transition-duration: 1s; 过渡-持续 设置动画完成时间,连写必填 transition-delay: 1s; 过渡-延期 设置动画延时执行时间(可以设置) transition-timing-function:linear 过渡-定时-功能 设置动画速度类型 2D转换 英文 中文 描述 translate(x,y) 位移 transform: translate(100px, 200px) //设置1个值 就是水平 rotate(angle) 旋转 transform-origin 变换-起源、原点 改变旋转点，例：transform-origin: 100px 100px;（top left） scale(x,y) 缩放 transform: scale(0, 0); //值代表倍数，元素缩小：0-1 skew(x-angle,y-angle) 倾斜 3D转换 英文 中文 描述 translateX(n)、translateY(n)、translateZ(n) 位移 rotateX()、rotateY()、rotateZ() 旋转 scaleX()、scaleY() 缩放 skewX()、skewY() 倾斜 perspective 透视 800-1000 transform-style: preserve-3d 转换成3D 动画 英文 中文 描述 @keyframes 关键帧 定义动画 animation-name 动画-名称 规定 @keyframes 动画的名称。 animation-duration 动画-持续时间 规定动画完成一个周期所花费的时间。 animation-timing-function 动画-定时-功能 规定动画的速度曲线。默认是 “ease”。 animation-delay 动画-延迟 规定动画何时开始。默认是 0。 animation-iteration-count 动画-迭代-计数 规定动画被播放的次数。默认是 1。还有 infinite animation-direction 动画-方向 动画是否在下一周期逆向地播放。默认是 “normal”，alternate逆播放 animation-play-state 动画-播放-状态 规定动画是否正在运行或暂停。默认是 “running”。还有“paused” animation-fill-mode 动画-填充-模式 规定动画结束后状态，保持 forwards 回到起始 backwards","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"js实现盒子内容无缝滚动","slug":"js实现盒子内容无缝滚动","date":"2019-05-14T06:00:59.682Z","updated":"2019-05-14T06:03:20.148Z","comments":true,"path":"2019/05/14/js实现盒子内容无缝滚动/","link":"","permalink":"/2019/05/14/js实现盒子内容无缝滚动/","excerpt":"","text":"直接上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style type=\"text/css\"&gt; #box &#123;height: 144px;width: 300px;margin: 100px auto;background: #eee;overflow: hidden;text-align: center;&#125; &lt;/style&gt; &lt;div id=\"box\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var lHeight = 24; var time = 50; box.innerHTML += box.innerHTML; box.scrollTop = 0; var timer; scrollMove() function scrollMove() &#123; box.scrollTop++; timer = setInterval('scroll()', time); &#125; // 间歇滚动 function scrollUp() &#123; if (box.scrollTop % lHeight == 0) &#123; //滚动一行后，延时2秒 clearInterval(timer); setTimeout(\"scrollMove()\", 2000); &#125; else &#123; box.scrollTop++; //判断滚动高度,当滚动高度大于box本身的高度时，使其回到原点重新滚动 if (box.scrollTop &gt;= box.scrollHeight / 2) &#123; box.scrollTop = 0; &#125; &#125; &#125; // 无缝滚动 function scroll() &#123; box.scrollTop++; //判断滚动高度,当滚动高度大于box本身的高度时，使其回到原点重新滚动 if (box.scrollTop &gt;= box.scrollHeight / 2) &#123; box.scrollTop = 0; &#125; &#125; box.onmouseenter = function () &#123; clearInterval(timer) &#125; box.onmouseleave = function () &#123; scrollMove() &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"JS实现文件拖拽上传功能","slug":"JS实现文件拖拽上传功能","date":"2019-05-13T07:22:53.447Z","updated":"2019-05-13T07:23:49.818Z","comments":true,"path":"2019/05/13/JS实现文件拖拽上传功能/","link":"","permalink":"/2019/05/13/JS实现文件拖拽上传功能/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; .upload &#123; text-align: center; position: absolute; top: 50%; left: 50%; margin-left: -250px; margin-top: -25px; &#125; .upload&gt;div &#123; border: 1px solid #ccc; width: 500px; height: 50px; line-height: 50px; border: 1px solid #ccc; box-sizing: border-box; &#125; .upload&gt;div::after &#123; content: '请将文件拖拽到该区域'; display: block; &#125; .upload&gt;a &#123; text-decoration: none; &#125; .upload .uploadInput &#123; display: none; &#125; &lt;/style&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- header --&gt; &lt;div id=\"header\"&gt;&lt;/div&gt; &lt;!-- content --&gt; &lt;div class=\"content-box w\"&gt; &lt;div class=\"upload\"&gt; &lt;div class=\"\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\" ondragleave=\"removeDrop(event)\"&gt;&lt;/div&gt; &lt;!-- &lt;a href=\"javascript:;\" class=\"uploadBtn\"&gt;从电脑中选择 --&gt; &lt;input class=\"uploadInput\" type=\"file\" name=\"uploadFile\" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"./jquery-3.3.1.js\"&gt;&lt;/script&gt; &lt;script&gt; /* 文件拖拽上传 */ var FormData = new FormData //文件移入 function allowDrop(event) &#123; event.preventDefault(); //阻止浏览器默认事件 event.target.style.border = \"1px dotted red\" &#125; //文件移除 function removeDrop(event) &#123; event.preventDefault(); event.target.style.border = \"1px solid black\" &#125; //当鼠标松开文件 function drop(event) &#123; event.preventDefault(); event.target.style.border = \"1px solid green\" var files = event.dataTransfer.files // if(files.length==0)&#123; // 没有文件返回false // return false // &#125; AddFiles(files) &#125; //添加文件，for循环掉多个文件 ，支持多文件添加,这里也可以做是否为图片文件判断 function AddFiles(files) &#123; console.log(files); for (var i = 0; i &lt; files.length; i++) &#123; FormData.append(\"file\", files[i]) FileUpload(FormData) &#125; &#125; //最后将拿到的文件进行ajax上传，暂时没拿服务器测试，实际情况可能会有所出入 function FileUpload(FormData) &#123; console.log(FormData); ///这里用了jQuery的ajax封装方法，这里还没来得及封装自己的ajax 先用了jQuery的 // $.ajax(&#123; // url:url, // type:\"post\", // data:FormData, // processData:false, // contentType:false, // success:function(data)&#123; // &#125; // &#125;); &#125; // 点击上传证书文件包 // $('.uploadBtn').click(function () &#123; // $('.uploadInput')[0].click() // &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"CSS3自定义滚动条样式","slug":"CSS3自定义滚动条样式","date":"2019-05-13T06:00:17.057Z","updated":"2019-05-13T06:03:03.627Z","comments":true,"path":"2019/05/13/CSS3自定义滚动条样式/","link":"","permalink":"/2019/05/13/CSS3自定义滚动条样式/","excerpt":"","text":"前言webkit支持拥有overflow属性的区域，列表框，下拉菜单，textarea的滚动条自定义样式，所以用处还是挺大的。当然，兼容所有浏览器的滚动条样式目前是不存在的。 滚动条组成 ::-webkit-scrollbar 滚动条整体部分 ::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条） ::-webkit-scrollbar-track 滚动条的轨道（里面装有Thumb） ::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。 ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去） ::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处 ::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件 简洁版1234567891011121314151617181920212223/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 16px; height: 16px; background-color: #F5F5F5;&#125; /*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); border-radius: 10px; background-color: #F5F5F5;&#125; /*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); background-color: #555;&#125; 详细设置定义滚动条就是利用伪元素与伪类，那什么是伪元素和伪类呢？ 伪类大家应该很熟悉:link,:focus,:hover，此外CSS3中又增加了许多伪类选择器，如:nth-child，:last-child，:nth-last-of-type()等。 CSS中的伪元素大家以前看过：:first-line,:first-letter,:before,:after。那么在CSS3中，伪元素进行了调整，在以前的基础上增加了一个“：”也就是现在变成了“::first-letter,::first-line,::before,::after”，另外CSS3还增加了一个“::selection”。两个“：：”和一个“：”在css3中主要用来区分伪类和伪元素。 webkit的伪类和伪元素的实现很强，可以把滚动条当成一个页面元素来定义，再结合一些高级的CSS3属性，比如渐变、圆角、RGBa等等。然后如果有些地方要用图片，可以把图片也可以转换成Base64，不然每次都得加载那个多个图片，增加请求数。 任何对象都可以设置：边框、阴影、背景图片等等，创建的滚动条任然会按照操作系统本身的设置来完成其交互的行为。下面的伪类可以应用到上面的伪元素中。有点小复杂，具体怎么写可以看第一个demo，那里也有注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344:horizontal//horizontal伪类适用于任何水平方向上的滚动条 :vertical//vertical伪类适用于任何垂直方向的滚动条 :decrement//decrement伪类适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮 :increment//increment伪类适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮 :start//start伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的前面 :end//end伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的后面 :double-button//double-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。 :single-button//single-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。 :no-buttonno-button伪类表示轨道结束的位置没有按钮。 :corner-present//corner-present伪类表示滚动条的角落是否存在。 :window-inactive//适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。 ::-webkit-scrollbar-track-piece:start &#123;/*滚动条上半边或左半边*/&#125; ::-webkit-scrollbar-thumb:window-inactive &#123;/*当焦点不在当前区域滑块的状态*/&#125; ::-webkit-scrollbar-button:horizontal:decrement:hover &#123;/*当鼠标在水平滚动条下面的按钮上的状态*/&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"CSS 实现隐藏滚动条同时又可以滚动","slug":"CSS 实现隐藏滚动条同时又可以滚动","date":"2019-05-13T05:58:53.333Z","updated":"2019-05-13T06:00:12.490Z","comments":true,"path":"2019/05/13/CSS 实现隐藏滚动条同时又可以滚动/","link":"","permalink":"/2019/05/13/CSS 实现隐藏滚动条同时又可以滚动/","excerpt":"","text":"::-webkit-scrollbar 有兼容问题 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; ::-webkit-scrollbar &#123;display:none&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\" width:200px; height: 200px; overflow-y: scroll;\"&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; 11111&lt;/br&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"盒子设置最小高度值并自适应高度","slug":"盒子设置最小高度值并自适应高度","date":"2019-05-13T01:45:56.894Z","updated":"2019-05-13T01:47:11.315Z","comments":true,"path":"2019/05/13/盒子设置最小高度值并自适应高度/","link":"","permalink":"/2019/05/13/盒子设置最小高度值并自适应高度/","excerpt":"","text":"盒子设置最小高度值并自适应高度一般来说，想让一个DIV盒子的高度能够根据盒子内的内容自动调整，不设置盒子的高度值（height）就行了。 但还有一种情况：为了使盒子布局美观，需要对盒子设置一个初始高度，当盒子中的内容很少时，保持这个初始高度，如果内容超过该盒子初始高度的容量，则盒子的高度根据内容自动调整增高。所以这时需要设置一个具体的DIV盒子高度值，又要使其能够在超过初始高度时自适应。 具体解决办法是（假设DIV盒子的初始高度是500px） 123456789#columnMain&#123;min-height:500px;height:auto !important;height:500px;&#125; 这里，height:500px;适用于IE6，因为IE6不认识前两条CSS语句，但height:500px;对IE6足够了，因为IE6的渲染办法是当已设置的实际高度不够用时，会自动撑开盒子的高度；前两条CSS语句min-height:500px;height:auto !important;是对IE7+、Chrome、FF和Oprea用的，这些版本的浏览器使用min-height:500px;设置了最小高度，如果超过了最小高度，则使用height:auto !important;自动调整高度，注意这条CSS语句中有!important，所以它的优先性是超过其后的height:500px;的。 至此，问题解决。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"JS判断后台返回值是否存在","slug":"JS判断后台返回值是否存在","date":"2019-05-10T09:20:33.674Z","updated":"2019-05-10T09:24:11.185Z","comments":true,"path":"2019/05/10/JS判断后台返回值是否存在/","link":"","permalink":"/2019/05/10/JS判断后台返回值是否存在/","excerpt":"","text":"JS判断json中的某个字段是否存在：12345//hasOwnProperty(String)，存在的话，返回true，否则返回false。代码如下：if (res.data.hasOwnProperty('objectName')) &#123; // 如果存在 ……&#125; JS判断字符串是否为空：长度判断： 1234var strings = ''; if (string.length == 0) &#123; alert('字符串为空'); &#125; 排除空格后，根据长度判断： 1234var strings = ' '; if (strings.replace(/(^s*)|(s*$)/g, \"\").length ==0) &#123; alert('字符串为空'); &#125; 函数判断为空串，字符串为空或全部为空格： 123456789// 字符串为空或全部为空格，返回true；否则，返回falsefunction isNull( str )&#123; if ( str == \"\" ) return true; var regu = \"^[ ]+$\"; var re = new RegExp(regu); return re.test(str);&#125; 后台还是比较喜欢返回null的，如果返回的是null上面就没有办法判断了，下面是我的一些改进。 12345// 判断是nullvar exp = null; if (exp == null) &#123; alert(\"is null\"); &#125; 上面判断的只是null的类型，有可能为空又有可能为null。 1234567// 判断是否为：空、空格、null，是的话返回true。否则falsefunction isNull( str )&#123; if ( str == \"\" ) return true; if ( str == null ) return true; var re = new RegExp(\"^[ ]+$\"); return re.test(str);&#125; 有一个比较简单的写法：要同时判断null和undefined时可使用本法。 如果 exp 为 undefined，或数字零，或 false，也会得到与 null 相同的结果，虽然 null 和二者不一样。 注意：要同时判断 null、undefined、数字零、false 时可使用本法。但是这种方法不能判断出是否为空字符串。 1234var exp = null; if (!exp) &#123; alert(\"is null\"); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"如何让多个li居中于ul中间","slug":"如何让多个li居中于ul中间","date":"2019-05-10T05:27:05.549Z","updated":"2019-05-10T08:32:20.053Z","comments":true,"path":"2019/05/10/如何让多个li居中于ul中间/","link":"","permalink":"/2019/05/10/如何让多个li居中于ul中间/","excerpt":"","text":"解决方法一： 利用margin-left设置； 比如 侧边栏的div宽300px;我有四个li，每个设置height：30px；width：60px；并让这四个li位于侧边栏的头部；就可以设置ul的margin-left：80px； 这样就会使四个li居于中间；如果想使四个li之间有间隔。可以设置li的margin-left:5px;这样就需要改变先前ul的margin-left为（300-240-20）/2-2.5，因为margin-left是透明的，所以才会有上面这个计算式子。可见可能会出现小数，这样是我们要避免的。利用ul的margin-left很简单地设置居中，只是不是强迫症患者的首选。因为这个方法，大家应该都会，而且百度一下，都会出来这样的例子，在此不贴代码。 在这个方法中，我们可以设置ul的高和宽，但只要不让ul的宽超过div的宽，以及不让ul的宽低于四个li的和的宽，就不会出现排版错误。 本人也不喜欢这个方法，于是，就有了第二种方法。 解决方法二： 利用ul的text-align：center属性； 对于第二种方法，首先要说的是，设置ul的display：table，text-align:center。是不是觉得好神奇，怎么会出现display：table，说实话，这也是我第一次用到这个属性，虽然知道有这个属性，但一般还真不用，我们似乎只用none，inline和block，但这里我们必须用这个属性，不然解决不了。下面是一段代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 500px; height: 500px; background-color: red; &#125; #ul1 &#123; display: table; margin: 0 auto; height: 40px; text-align: center; padding: 0; &#125; .li1 &#123; float: left; margin-left: 5px; padding: 0; width: 70px; height: 60px; line-height: 60px; font-size: 20px; background-color: yellow; list-style-type: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;ul id=\"ul1\"&gt; &lt;li class=\"li1\"&gt;11111&lt;/li&gt; &lt;li class=\"li1\"&gt;22222&lt;/li&gt; &lt;li class=\"li1\"&gt;33333&lt;/li&gt; &lt;li class=\"li1\"&gt;44444&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这段代码可以解决居中方法，注意：ul设为display：table；text-align：center；但记住千万千万不可以设置ul的宽，不然无法实现。 解决方法三： 其实这不能用的方法，这方法太渣；就是ul的设为text-align：center； li的设为display：inline； 但这样的话，就无法做出li的宽和高，虽然也会居中，但已经失去了其解决的意义。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"时间格式化、时间戳转换","slug":"时间格式化、时间戳转换","date":"2019-05-09T08:38:53.862Z","updated":"2019-05-09T10:18:17.817Z","comments":true,"path":"2019/05/09/时间格式化、时间戳转换/","link":"","permalink":"/2019/05/09/时间格式化、时间戳转换/","excerpt":"","text":"时间格式化123456789101112131415 var ddd = new Date() var year = ddd.getFullYear() var month = ddd.getMonth() + 1 var day = ddd.getDate() var hours = ddd.getHours() var minutes = ddd.getMinutes() var seconds = ddd.getSeconds() return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;` //or var tempTime = new Date();return tempTime.toLocaleDateString().replace(/\\//g, \"-\") + \" \" + tempTime.toTimeString().substr(0, 8) 时间转时间戳 javascript获得时间戳的方法有四种，都是通过实例化时间对象 new Date() 来进一步获取当前的时间戳 1.var timestamp1 = Date.parse(new Date()); // 结果：1477808630000 不推荐这种办法，毫秒级别的数值被转化为000 console.log(timestamp1); 2.var timestamp2 = (new Date()).valueOf(); // 结果：1477808630404 通过valueOf()函数返回指定对象的原始值获得准确的时间戳值 console.log(timestamp2); 3.var timestamp3 = new Date().getTime(); // 结果：1477808630404 ，通过原型方法直接获得当前时间的毫秒值，准确 console.log(timestamp3); 4.var timetamp4 = Number(new Date()) ; //结果：1477808630404 ,将时间转化为一个number类型的数值，即时间戳 console.log(timetamp4); 如果不需要精确到毫秒，可以 / 1000 时间戳转时间var timestamp4 = new Date(1472048779952);**//直接用 new Date(时间戳) 格式转化获得当前时间 console.log(timestamp4); console.log(timestamp4.toLocaleDateString().replace(/\\//g, “-“) + “ “ + timestamp4.toTimeString().substr(0, 8)); //再利用拼接正则等手段转化为yyyy-MM-dd hh:mm:ss 格式 不过这样转换在某些浏览器上会出现不理想的效果，因为toLocaleDateString()方法是因浏览器而异的，比如 IE为2016年8月24日 22:26:19 格式 搜狗为Wednesday, August 24, 2016 22:39:42 可以通过分别获取时间的年月日进行拼接，比如： 1234567function getdate() &#123; var now = new Date(), y = now.getFullYear(), m = now.getMonth() + 1, d = now.getDate(); return y + \"-\" + (m &lt; 10 ? \"0\" + m : m) + \"-\" + (d &lt; 10 ? \"0\" + d : d) + \" \" + now.toTimeString().substr(0, 8); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"CSS 盒子模型塌陷的解决方法","slug":"CSS 盒子模型塌陷的解决方法","date":"2019-05-09T07:33:02.154Z","updated":"2019-05-10T05:27:02.004Z","comments":true,"path":"2019/05/09/CSS 盒子模型塌陷的解决方法/","link":"","permalink":"/2019/05/09/CSS 盒子模型塌陷的解决方法/","excerpt":"","text":"HTML+CSS一、盒子塌陷是什么？本应该在父盒子内部的元素跑到了外部。 二，为什么会出现盒子塌陷？ 当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。 三，关于盒子塌陷的几种解决方法 最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，这样的好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面，缺点是非自适应，浏览器的窗口大小直接影响用户体验。 给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，但是对页面的布局不是很友好，不易维护。 给父盒子添加overflow属性。 overflow:auto; 有可能出现滚动条，影响美观。 overflow:hidden; 可能会带来内容不可见的问题。 父盒子里最下方引入清除浮动块。最简单的有： &lt;span style=&quot;clear:both;&quot;&gt;&lt;/span&gt; 有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。 after伪类清除浮动。 外部盒子的after伪元素设置clear属性。 12345678#parent:after&#123; clear: both; content: \"\"; width: 0; height: 0; display: block; visibility: hidden;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"Node - 内置模块","slug":"Node - 内置模块","date":"2019-05-09T07:05:02.909Z","updated":"2019-05-09T07:07:01.772Z","comments":true,"path":"2019/05/09/Node - 内置模块/","link":"","permalink":"/2019/05/09/Node - 内置模块/","excerpt":"","text":"fs fs 操作 文件 const fs = require(‘fs’) fs.readFile() 读取 fs.readFile(‘1.txt’,’utf-8’, (err, data) =&gt; {}) fs.writeFlie() 重写 fs.writeFlie(文件路径,data,(err)=&gt;{}) fs.watchFile() 监视fs.watchFile(‘./1.txt’,{interval:200},(curr, prev) =&gt; {}) fs.access(path, (err) =&gt; {}) 存在，如果err是一个对象，就是文件不存在 fs.unlink(‘test.txt’, (err) =&gt; {}) 删除文件 fs.appendFile(file, data, callback) 向文件中追加内容 fs.copyFile(src, callback) 复制文件 fs.mkdir(path, callback) 创建目录 fs.readDir(path, callback) 读取目录列表 fs.rename(oldPath, newPath, callback) 重命名文件/目录 fs.rmdir(path, callback) 只能删除空目录 fs.stat(path, callback) 获取文件/目录信息 fs.watch(filename[, options][, listener]) 监视文件/目录 path path 操作 路径 const path = require(‘path’) path.basename(‘路径’) 获取文件名 path.dirname(‘路径’) 获取路径 path.extname(‘路径’) 获取后缀名 path.parse(‘路径’) 将路径转换成对象，包含各个部分 path.join(‘路径’,’路径’) 拼接多个路径 path.resolve(‘路径’,’路径’) 在当前文件目录基础上 拼接路径 html html 创建服务器 const fs = require(‘html’) server.listen(8080, ‘127.0.0.1’, (err) =&gt; { }) 监听8080端口 server.on(‘request’, (request, response) =&gt; {}) 用户请求后 的处理程序 response.setHeader(‘Content-Type’, ‘text/html’) 设置用户请求文件的content-type request.method === ‘GET’ //POST 判断提交方式 request.on(‘data’, (chunk) =&gt; { }) 如果是表单提交，利用chunk抓数据包 request.on(‘end’, () =&gt; {}) 表单提交抓包后，的处理程序 response.writeHead(302, { Location: ‘/‘ }); 表单提交后，设置302跳转 querystring querystring 字符串 转对象 const qs = require(‘querystring’) querystring.parse(str[, sep[, eq[, options]]]) 将字符串解析成对象 （字符串，默认&amp;，默认=） mime — 第三方模块 mime — 第三方模块 通过后缀名 创建 Content-Type const mime = require(‘mime’) mime.getType(后缀名) mime.getType(.html)","categories":[{"name":"Node.js","slug":"Node-js","permalink":"/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"}]},{"title":"Node - 基础","slug":"Node - 基础","date":"2019-05-09T07:01:40.717Z","updated":"2019-05-09T07:04:53.416Z","comments":true,"path":"2019/05/09/Node - 基础/","link":"","permalink":"/2019/05/09/Node - 基础/","excerpt":"","text":"基础 类型 英文 中文 描述 全局成员 Global Objects __filename console.log(__filename) 获取当前脚本名 __dirname 获取当前脚本所在目录 REPL R：Read 读取 E：Eval 执行 P：Print 输出 L：Loop 循环 执行 打开命令行并定位到 hello.js 文件所属目录 - 在命令行中输入 node hello.js 回车执行 基本 require 要求，命令 用于核心模块的请求,每个核心模块就是个{} request 请求 throw 抛出 init 在里面 ？ install 安装 Sync 同步 statusCode 响应码、状态码 views 导入导出 (用户模块 请求 (./)) (核心、第三方模块 直接名字) module.exports 模块.导出 每个模块都有1个 这个对象 exports 导出 这个是module的对象，但不能导出单个成员 这俩都指向一个{}，可以有属性、方法，但是require给对象新赋值后 会改变对象的指向 JSON JSON.parse(data) 把*.json转化成对象 JSON.stringify(obj) 把对象转换成json字符串 文件读写123456const fs = require('fs')fs.readFile('xx.txt', (err, data) =&gt; &#123; if (err) throw err console.log(data)&#125;) 123456const fs = require('fs')fs.writeFile('message.txt', 'Hello Node.js', (err) =&gt; &#123; if (err) throw err console.log('The file has been saved!')&#125;) 简单服务器1234567891011const http = require('http')const server = http.createServer()// 当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数server.on('request', function (req, res) &#123; res.end('Hello Node.js!')&#125;)// 4. 绑定端口号，启动服务器server.listen(3000, function () &#123; console.log('服务器启动成功，请求访问 http://127.0.0.1:3000/')&#125;)","categories":[{"name":"Node.js","slug":"Node-js","permalink":"/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"}]},{"title":"JavaScript - 高级、ES5、ES6","slug":"2.1.4.JavaScript - 高级、ES5、ES6","date":"2019-05-09T06:05:56.131Z","updated":"2019-05-09T06:39:43.922Z","comments":true,"path":"2019/05/09/2.1.4.JavaScript - 高级、ES5、ES6/","link":"","permalink":"/2019/05/09/2.1.4.JavaScript - 高级、ES5、ES6/","excerpt":"","text":"JS 高级原型-对象 英文 描述 原型中定义的属性或方法，可以被所关联的构造函数所创建的实例对象==共享==。 减少了属性或方法的在内存占的使用，节省了内存空间。 构造函数名.prototype 构造函数可以通过prototype找到原型 .constructor 原型可以通过constructor找到关联的构造函数 原型链：先从对象本身中查找、会通过proto这个属性提供的地址，找到原型对象、会通过proto这个属性提供的地址，找到原型的原型 继承原型方式继承： 可继承方法，但不继承属性 123456789101112131415161718function Person() &#123; this.name = '人类'; this.age = 10; &#125; Person.prototype.eat = function() &#123; console.log(\"我会吃.....\"); &#125;; function Student() &#123; &#125; // 原型继承 Student.prototype = new Person(); // 给原型添加constructor属性 Student.prototype.contructor = Student; // 创建一个学生对象 var stu1 = new Student(); stu1.eat(); 借用继承： call方法改变this的指向，但是不继承函数方法 12345678910111213141516function Person(name,age) &#123; this.name = name; this.age = age;&#125;Person.prototype.eat = function() &#123; console.log(\"我会吃.....\");&#125;;function Student(name,age) &#123; // this 代表的具体的某一个学生的实例 stu1 、stu2 var stu = this; Person.call(stu,name,age)&#125;// 创建一个学生对象var stu1 = new Student('张三',10); 组合继承： 原型继承+借用继承 1234567891011121314151617181920 function Person(name,age) &#123; this.name = name; this.age = age;&#125;Person.prototype.eat = function() &#123; console.log(\"我会吃.....\");&#125;;function Student(name,age) &#123; // 借用继承【借用属性】 Person.call(this,name,age,gender)&#125;// 原型继承【继承方法】Student.prototype = new Person();// 设置原型contructor属性指向StudentStudent.prototype.constructor = Student; // 创建一个学生对象var stu1 = new Student('张三',10,'男'); class 继承12345678910class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 函数其他 英文 描述 函数名.arguments 获取用户传入的实参 函数.length 获取函数形参的个数 函数.name 函数的名字 闭包12345678910111213function bieShu() &#123; var a = '三儿'; var guanJia = function (v) &#123; console.log(a); a = v; console.log(a); &#125;; return guanJia;&#125;var cyqz = bieShu();cyqz('3');cyqz('33'); 递归12345678910function jisuan(n) &#123; if (n == 1) &#123; return 10 &#125; else &#123; return jisuan(n - 1) + 2 &#125;&#125;var a = jisuan(5)console.log(a) 浅拷贝1234567891011121314var father = &#123; name: '张三', age: 52, cars: ['奔驰', '宝马']&#125;var son = &#123; name: '小三'&#125;for (var key in father) &#123; if (!son.hasOwnProperty[key]) &#123; son[key] = father[key] &#125;&#125; 深拷贝12345678910111213141516171819202122232425var father = &#123; name: '张三', age: 52, cars: ['奥迪', '大众']&#125;var son = &#123; name: '小三'&#125;copy(father, son)function copy(fatherOBJ, sonOBJ) &#123; for (var key in fatherOBJ) &#123; if (!sonOBJ.hasOwnProperty[key]) &#123; if (fatherOBJ[key] instanceof Array) &#123; sonOBJ[key] = new Array() copy(fatherOBJ[key], sonOBJ[key]) &#125; else if (fatherOBJ[key] instanceof Object) &#123; sonOBJ[key] = new object() copy(fatherOBJ[key], sonOBJ[key]) &#125; else &#123; sonOBJ[key] = fatherOBJ[key] &#125; &#125; &#125;&#125; new 在内存中申请了一块空间，存放了一个对象。 让构造函数内部的this指向该空间 通过this向内存中空的对象中添加属性和方法 new关键字最后将this返回给外部变量 thisthis通常指向于调用者会找最近的包裹的function 在全局环境下，this 始终指向全局对象（window） 普通函数内部this严格模式：window 非严格模式：undefined 对象内部方法的this指向调用这些方法的对象 原型链中的方法的this仍然指向调用它的对象 构造函数中的this与被创建的新对象绑定。 改变this指向 描述 cell 可以用函数 例如 数组中的push //// 组合继承中也用这个 函数名.call(调用者,参数1…) 函数被借用时，会立即执行，并且函数体内的this会指向借用者或调用者 函数名.apply(调用者,[参数1…]) 函数被借用时，会立即执行，并且函数体内的this会指向借用者或调用者 函数名.bind(调用者,参数1…) 不会立即执行，返回新的函数。并且函数体内的this会指向借用者或调用者 ES6声明 let let 定义变量,变量不可以重名,必须先定义再使用- 具有块级作用域- 没有变量提升 const 常量一旦初始化，不可以重新赋值 const 定义常量，常量不可以重名，必须先定义再使用- 具有块级作用域- 没有变量提升 解构赋值 数组解构 let arr = [5, 9, 10]; let [a, b, c] = arr; 对象解构 let obj = {foo: ‘aaa’, bar: ‘bbb’};let { foo, bar} = obj; // 更改变量的名称 let obj = {foo: ‘aaa’, bar: ‘bbb’};let {foo: a, bar: b } = obj; let obj = { name: ‘zs’, dog: { name: ‘BYD’, age: 1}} let { dog: { name, age } } = obj; 函数箭头函数 不能用于 构造函数 箭头函数 let fn = (x, y) =&gt; { console.log(arguments); x = 2 x; y = 2 y; return x + y;} //若形参只有1个 可省略括号，若代码块只有1个 可省略{} 默认值 function fn(x, y = ‘world’) { } //形参y 的默认值是world，若传值，则会覆盖 —rest function getMax(…values) {} getMax(6, 1, 100, 9, 10) // 写 “ … + 名称 “ 函数调用传参时 多余的参数会放在数组中 Array 扩展 扩展运算符 // 合并两个数组 let arr1 = [1, 2];let arr2 = [3, 4];let arr3 = […arr1, …arr2]; // 把数组展开作为参数，可以替代 apply // 求数组的最大值 let arr = [6, 99, 10, 1];let max = Math.max(…arr); Array.from() //把伪数组转成数组 let fakeArr = { 0: 1, 1: 2, 2: 3, length: 3}; let arr = Array.from(fakeArr);console.log(arr); find() 找到数组中第一个满足条件的成员并返回该成员，如果找不到返回undefined let arr = [1, 3, -5, 6, -2];let result = arr.find((x) =&gt; x &lt; 0); //find 回调函数有 3 个参数 arr.find(function (item, index, ar) { // item 当前的值 // index 当前的值对应的索引 // ar 原数组}); findIndex() 找到数组中第一个满足条件的成员并返回该成员的索引，如果找不到返回 -1 includes() 判断数组是否包含某个值，返回 true / false String 扩展 模板字符串 let name = ‘zs’;let age = 18; // 拼接多个变量 let str = 我是${name}，今年${age}; includes() 返回布尔值，表示是否找到了参数字符串 startsWidth() 返回布尔值，表示参数字符串是否在原字符串的头部 endsWith() 返回布尔值，表示参数字符串是否在原字符串的尾部。 repeat() 返回一个新字符串，表示将原字符串重复n次。 Number 扩展ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 Number.parseInt() Number.parseFloat() Set 的成员 size：属性，获取 set 中成员的个数，相当于数组中的 length add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 新增的内置对象,但是成员都是唯一的 // Set 可以通过一个数组初始化 let set = new Set([1, 2, 1, 5, 1, 6]);// 数组去重 let arr = […set]; promise通常用于ajax，处理异步请求 async、awaitasync await需要配合使用 async函数return值是promise对象，结果需要.then 或调用函数时加上await (若包含ajax、定时器，则推荐使用async+await来处理程序执行顺序) 模块化 英文 中文 描述 默认导出 export default {导出内容} export default {id:uid,name:uname} //导出时default 只能出现一次 按需导出 export *(导出变量、函数等) export var a = 10 export {a:a,b:b} 默认导入 import 接收名称 from ‘模块名称’ import abc{成员, ..} from ‘模块名称’ 存在默认导出（未起名） + 按需导出//导入时可给默认导出的起名 按需导入 import {成员, ..} from ‘模块名称’ import { 成员名称 as 别名,成员名称… } from ‘模块名称’ ？按需和默认的一并导入，必须是默认的在前、按需的在后 三点运算符… 合并数组、对象 //例：let newAry = […ary1,…ary2] / let newObj = {…obj1,…obj2} 对象key名称var keyName = ‘uName’; var obj = { [keyName]: ‘nihao’ } es6中 可以动态自定义对象key名称 其他 类型 英文 中文 不确定es版本 number num.toFixed(3) 保留小数点3位 js错误处理 try{}catch(e){console.log(e.message)} 获取自定义属性 this.dataset.id 转URL编码 encodeURIComponent(q) 转URL编码 querystring.escape(str) 利用json深拷贝 this.todoContent = JSON.parse(JSON.stringify(item)) 数组按照大小排序 ary.sort((a,b)=&gt;(a-b))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"JavaScript - Math、Array、Date、String","slug":"2.1.2.JavaScript - Math、Array、Date、String","date":"2019-05-09T05:49:42.142Z","updated":"2019-05-09T05:49:17.815Z","comments":true,"path":"2019/05/09/2.1.2.JavaScript - Math、Array、Date、String/","link":"","permalink":"/2019/05/09/2.1.2.JavaScript - Math、Array、Date、String/","excerpt":"","text":"JS 对象Math Math Math.* Math.PI 获取圆周率 Math.random() 返回大于等于0小于1之间的随机数 Math.floor() 向下取整，返回一个小于当前数字的整数 Math.ceil() 向上取整，返回一个大于当前数字的整数 Math.round() 四舍五入 Math.abs() 取绝对值 Math.max() 返回一组数中的最大值(不可是数组) Math.min() 返回一组数中的最小值(不可是数组) Math.pow(x,y) 返回x的y次幂 Array Array *.toString() 把数组转换为字符串，使用逗号分隔 *.valueOf() 返回数组对象本身 ？？？ *.ary.push() 数组末尾 增加值 *.ary.pop() 用于删除数组的最后一个元素并返回删除的元素。(会修改数组长度) *.ary.shift() 用于删除数组的第一个元素并返回删除的元素。(会修改数组长度) *.unshift(number) 在数组起始位置添加一个、或多个值 .concat( //可以是 nub、ary ) 拼接字符串、数组（第一个不能是Number类型） *.slice(startindex, endindex) 从当前数组中复制个新的数组，如果第二个值不写，则取到结尾 *.splice(startindex, deletCont, options) 删除或者替换数组中的某些值 *.indexOf(content[,index])，lastIndexof() 查找所传值 在数据中的索引，未找到的话 返回-1 *.join(‘内容’) 在数组中的值 之间 插入内容，并转成字符串 *.reverse() 数组反转 *.filter(function(item,index, ary) {return 不要的值}) //返回一个新数组,可以获取赛选结果 map(function(item,index,ary) {}) //遍历数组,返回一个新数组 *.forEach(function(item,index, ary) {}) //遍历数组,没有返回值 *.sort() 数组排序，默认按升序 排序 var ary = [1500, 2000, 1000, 2100, 900, 1900, 3000] ary.filter(function(item, index) { if (item &gt;= 2000) { ary.splice(index, 1) } }) var ary = [‘a’, ‘b’, ‘c’, ‘d’, ‘a’, ‘e’, ‘f’, ‘a’, ‘g’, ‘h’] ary.forEach(function(item, index) { if (item == ‘a’) { console.log(index) } }) Date Date var * = new Date() *.toString(); 转化成字符串(Sat Nov 03 2018 19:04:20 GMT+0800 (中国标准时间)) *.toDateString(); 转换成日期字符串(Sat Nov 03 2018) *.toTimeString(); 转换成时间字符串(19:04:20 GMT+0800 (中国标准时间)) *.toLocaleDateString(); 返回本地的日期格式 （不同浏览器不同效果） *.toLocaleTimeString(); 返回本地的时间格式 （不同浏览器不同效果） *.getSeconds() 获取秒 *.getMinutes() 获取分钟 *.getHours() 获取小时 *.getDay() 返回周几 （0表示周日） *.getDate() 返回当前月的第几天 *.getMonth() 返回月份 （从0开始） *.getFullYear() 返回年份 *.valueOf() 获取当前时间毫秒 *.getTime() Date.now() toLocaleString() 格式化 String String *.charAt(索引) 获取指定位置处的字符 *.str[index] 获取指定位置的字符 （H5中的方法） .concat( //可以是 nub、ary ) 拼接字符串、数组（第一个不能是Number类型） *.slice(索引,索引) 从指定位置开始，截取字符串到结束位置，end值取不到 *.substring(start,end) 从指定位置开始，截取字符串到结束位置， end值取不到 *.substr(start,length) 从指定位置开始，截取length长度个字符 .indexOf(字符,从索引开始找) 返回字符在字符串中的位置 lastIndexOf(字符) 从后往前找，只找第一个匹配的字符 *.trim() 只能去除字符串前后空白 *.toLocaleUpperCase() 转化为大写 *.toLocaleLowerCase() 转化为小写 *.replace(a,b) 用b替换a *.split() 以一个分割符,将一个字符串串分割成一个数组 indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"JavaScript - DOM、BOM操作、事件","slug":"2.1.3.JavaScript - DOM、BOM操作、事件","date":"2019-05-09T05:45:46.181Z","updated":"2019-05-09T06:05:32.744Z","comments":true,"path":"2019/05/09/2.1.3.JavaScript - DOM、BOM操作、事件/","link":"","permalink":"/2019/05/09/2.1.3.JavaScript - DOM、BOM操作、事件/","excerpt":"","text":"DOM获取元素 英文 中文 描述 document.getElementById(‘id’) 文档.得到 元素 通过 ID 根据id值获取单个元素 document.getElementsByTagName(‘标签名’) 文档.得到 元素 通过 TagName 根据标签名获取一组元素 document.querySelector(‘选择器’) 文档.查询 选择 根据选择器获取单个元素 document.querySelectorAll(‘选择器’) 文档.查询 选择 所有 根据选择器获取一组元素 常见属性 英文 中文 描述 id、title、href、src、className \\ innerText、innerHTML textContent(标准，不兼容ie8) a标签 英文 中文 描述 return false 取消默认行为 href = javascript: 表单 英文 中文 描述 元素.value 值 表单元素的内容 元素.disabled （若是其他标签则需要.style.） 使 xxx失去能力 操作表单元素是否禁用（true→禁用，false→不禁用） 不加引号 *.checked 选中的 操作表单元素是否选中（true→选中，false→不选中） *.selected 挑选出来的 操作表单元素的是否选中（true→选中，false→不选中） 注意:原生js中没有:selcted这个选择器 var options = document.querySelectorAll(‘#sel1 option:checked’); //js 筛选选中的option options[i].selected = false; //设置被选中的option的选中状态 节点层级 英文 中文 描述 子节点.parentNode 父节点 子节点获取父节点 父节点.childNodes 子节点 父节点获取子节点 - 获取的节点包含了文本和元素 父元素.children 孩子们 父节点获取子节点 - 获取仅仅是元素，不包含文本 父节点.firstElementChild 第一个 元素 孩子 父节点.lastElementChild 最后一个 元素 孩子 节点.nextElementSibling 下一个 元素 兄弟 获取上一个兄弟 节点.previousElementSibling 以前 元素 兄弟 获取下一个兄弟 节点的nodeType、nodeName、nodeValue的属性 节点属性nodeType的作用，获取节点类型: 元素节点的nodeType→ 1 ， 文本节点的nodeType→3 节点属性nodeName的作用，获取节点的名称： 元素节点→标签名（大写H2）， 文本节点→ #text 节点属性nodeValue的作用，获取节点的值： 元素节点→null 文本节点→ 文本值比如换行”↵ “ 动态控制元素 英文 中文 描述 元素.innerHTML = ‘内容’; 通过innerHTML创建元素 (性能差) document.createElement(‘标签名’); 文档.创建 元素 创建元素，并返回新元素对象 var * = document.createElement(‘li’); 父元素.appendChild(子元素); 添加 子节点 动态追加元素 父元素.removeChild(子元素); 移除 子节点 动态删除元素 父节点.insertBefore(新的节点,旧的子节点) 插入 节点 在*位置上插入新元素 旧子阶段获取：var 旧节点 = 盒子.children[0]; 父节点.replaceChild(新的节点,旧的子节点) 替换 节点 替换元素 元素.cloneNode(true或false); 克隆 节点 克隆元素。返回克隆后的元素，默认false（仅克隆外层）；true，克隆所有内容 自定义行内属性 英文 中文 描述 元素.getAttribute(name); 获取 属性 获取 元素.setAttribute(name,value); 设置 属性 设置 元素.removeAttribute(name,value); 移除 属性 移除 控制元素样式 英文 描述 元素.style.样式属性名 = ‘样式属性值’; 通过style属性设置样式 元素.className = ‘类名’ 通过class 控制标签样式 BOMwindow对象 英文 描述 window 顶级对象 全局变量或全局函数本质上都是window的属性或方法 window.innerWidth 获取浏览器宽度 var * = window.pageYOffset 获取页面卷曲高度 window.setTimeout(callback, time); 定时器，仅执行一次，可返回一个标识 用变量接收 window.clearTimeout(定时器的标识); 清除定时器 window.setInterval(callback, time) 定时器，重复执行 直到取消，可返回标识 用变量接收 window.clearInterval(定时器的标识); 清除定时器 location对象 英文 描述 location.href 设置或获取地址栏地址 location.reload() 刷新页面 history对象 英文 描述 history.length 获取历史记录的长度 history.back() 回退上一个历史记录 history.forward() 前进下一个历史记录 history.go(数字) 正数，表示前进； 负数，表示回退 navigator对象 英文 描述 navigator.userAgent 获取浏览器的信息 其他 英文 描述 window.onload = function(){} 等页面资源全部加完毕后，要执行的程序(一般不用) 对象名.hasOwnProperty( 键名 ) 检测该属性、方法是否属于x对象 offset 描述 元素.offsetWidth 返回的是数字。 大小包含： 内容 + padding + border; 只读，不可赋值 元素.offsetHeight 元素.offsetLeft 返回的是数字。（参照谁？看定位关系） 元素.offsetTop 元素.offsetParent 获取“父元素”， 按照定位关系 scroll 描述 元素.scrollWidth 获取的元素的大小 ,包含 【内容+ padding + 溢出】 元素.scrollHeight 元素.scrollLeft 获取被卷起的页面间距 元素.scrollTop client（不常用） 描述 元素.clientWidth 获取元素的大小，包含 【内容 + padding】 元素.clientHeight 元素.clientLeft 获取边框的厚度 元素.clientTop 123window.onscroll = function () &#123; var sc = document.body.scrollTop || document.documentElement.scrollTop&#125; 1234//点击按钮 回到页面顶端toTop.onclick = function () &#123; document.body.scrollTop = 0; document.documentElement.scrollTop = 0;&#125;; 事件相关 事件对象 :事件源.事件类型 = function(e){ // 第一个形参e就是事件对象 } 鼠标事件 英文 中文 描述 *.onclick 点击 鼠标点击事件 *.onmousemove 鼠标 移动 document.onmousemove = function(){} *.onmousedown 鼠标 按下 *.onmouseup 鼠标 弹起 onmosueenter/onmosueleave 鼠标进入 离开 不支持冒泡 onmosueover/onmouseout 鼠标进入 离开 支持冒泡 事件对象.clientX / 事件对象.clientY 参照是==浏览器== client：客户 事件对象.pageX / 事件对象.pageY 参照是==文档== page：页面 事件对象.offsetX / 事件对象.offsetY 参照是==当前的元素== offset：抵消？ screenX 屏幕 键盘事件 英文 中文 描述 onkeydown 键入 按下 键盘按下事件 onkeyup 键入 抬起 键盘弹起事件 事件对象.keyCode 获取键盘按键对应的键码值 事件对象.altKey 表示alt键是否按下，返回布尔值。 事件对象.shiftKey 表示shift键是否按下，返回布尔值。 事件对象.ctrlKey 表示ctrl键是否按下，返回布尔值。（true按下，false没有按下） 事件监听(官宣)老IE不兼容，建议在web使用 英文 中文 描述 事件源.addEventListener(‘类型’,处理程序,捕获); 添加 事件 监视器 捕获，可选参数，默认为false。 true→ 捕获，false→冒泡 事件源.removeEventListener(‘类型’,处理程序名称) 移除 事件 监视器 若要通过事件监听的方式移除事件，需单独将事件处理程序 抽取出来命名 12345var btn = document.querySelector('button');// 事件监听注册事件 btn.addEventListener('click',function()&#123; console.log(1); &#125;); 12345var btn = document.querySelector('button');var fn1 = function() &#123;console.log(1);&#125;;btn.addEventListener('click',fn1);btn.removeEventListener('click',fn1) 事件委托 英文 中文 给一组元素父级标签设置事件委托，提高性能 减少事件绑定 通过事件对象.target的nodeName 属性检测触发元素 document.onclick = function(e) { var _e = e \\ \\ window.event } //解决ie低版本兼容性 事件对象.target this指向事件源，target指向事件触发点 touch事件 英文 中文 描述 touchstart 触摸 开始 手指按下 ，需要用事件监听的方式注册 touchmove 触摸 移动 手指移动 ，需要用事件监听的方式注册 touchend 触摸 结束 手指松开 ，需要用事件监听的方式注册 事件对象.touches 触摸s 位于屏幕上的所有手指的列表，伪数组 事件对象.targetTouches 目标 触摸s 位于该元素上的所有手指的列表，伪数组 事件对象.changedTouches 改变 触摸 被改变的手指列表。touchstart时包含刚与屏幕接触的触点，touchend时包含离开屏幕的触点，伪数组 手指对象.clientX/Y 手指相对于layout viewport的水平/垂直像素距离 手指对象.pageX/Y 手指相对于layout viewport的水平/垂直像素距离 在移动端推荐使用clientX/Y 其他 英文 中文 描述 事件对象.preventDefault(); 防止 默认 阻止默认行为 事件对象.stopPropagation(); 停止 传播 停止冒泡传播 *.oninput 输入 通常用于文本框输入时 触发 transitionend事件 过度 结束 css中过渡结束后检测的行为 *.onfocus 获取 焦点 获取焦点（通常用于表单 的事件） *.onblur 获取 模糊？？ （on 布尔） 失去焦点（通常用于表单 的事件） *.submit 表单的触发事件 提交表单时 按键盘enter 也可以提交，但是需要注意 必须有 submit按钮 window.onhashchange = ()=&gt;{} url改变监听 window.location.hash 监听url/锚点 改变后的值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"JavaScript - 基础","slug":"2.1.1.JavaScript - 基础","date":"2019-05-09T05:39:37.307Z","updated":"2019-05-09T05:45:36.510Z","comments":true,"path":"2019/05/09/2.1.1.JavaScript - 基础/","link":"","permalink":"/2019/05/09/2.1.1.JavaScript - 基础/","excerpt":"","text":"JS 基础js组成 英文 中文 描述 ECMAScript JavaScript的核心 描述了语言的基本语法和数据类型，ECMAScript是一套标准 BOM 浏览器对象模型 操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM 文档对象模型 一套操作页面元素的API 简单数据类型 英文 中文 描述 Number String Boolean 布尔 true(1) false(0) Undefined 未下定义的 Null 复杂数据类型 英文 中文 描述 Object 目标 其他1 英文 中文 描述 Infinity 无穷大 -Infinity 无穷小 NaN not a number isNaN(x) 判断是否是数字 typeof * 类型 .length 长度 document.write(); 文件 写作 新增一个标签 document.write(‘‘); console.log(‘’); 控制台 日志 在浏览器控制台打印内容 console.dir(*) *代表标签 显示一个对象所有的属性和方法 alert(); 警告 浏览器弹窗 alert(‘你好’); confirm(‘’); 证实 和alert()差不多，但是带“取消”按钮 prompt(‘’) prompt(‘’,’’) 提示 浏览器弹窗，可输入内容；var msg = prompt(‘主题’,’提示’) 转换数据类型 英文 中文 描述 .toString() 不可转换undefined和null String() 可以转换undefined和null Number() 如果目标含非数字，则返回NaN parseInt() 解析整数 转换整数，遇到非数字后停止 parseFloat() 解析浮点数 可以转换浮点数，遇到非数字后停止 Boolean() false：0 ‘’(空字符串) null undefined NaN true：其他都会转换成true + - 、 *+’’ 采用隐式转换，但是需要注意数据类型 三元运算符 英文 中文 描述 表达式 ? true : false 三元表达式 如果表达式成立，则返回true 运算符（按先后排序） 英文 中文 描述 ++ – 一元运算符 + - * / % 算数运算符 &lt; &gt; &gt;= &lt;= 关系运算符 == != === !== 相等运算符 &amp;&amp; \\ \\ ! 逻辑运算符 与、或、非 = += -= *= /= %= 赋值运算符 判断 英文 中文 描述 if else 如果 其他 switch (expression){ case 常量1: 语句; break; default: 语句; break;} switch：开关 case：情况 break：打断 default: 其他默认 break若省略，则会穿透 case:kas default:difo 循环 英文 中文 描述 while (循环条件) { //循环体 } 当什么的时候 xxxx 音标：wil do { // 循环体; } while (循环条件); 不管条件是否成立，均先执行一次 for (初始化表达式1; 判断表达式2; 自增表达式3) { // 循环体4 } 为，为了；因为；给；对于；至于 for (var i = 0; i &lt; 10; i++) {循环体} break 打断 立即跳出整个循环，即循环结束，开始执行循环后面的内容 continue 继续 立即跳出当前循环，继续下一次循环 数组 英文 中文 描述 var * = new Array() 数组 数组.splice(索引，删除数量) 拼接 删除数据中的数据 *.join(‘内容’) 加入 在数组中的值 之间 插入内容 *.indexOf(值、变量名) 查找所传值 在数据中的索引，未找到的话 返回-1 函数 英文 中文 描述 function * (){} 函数 形参、实参 (function (){})() 匿名函数、自调用函数 return 返回 一个函数中 只能返回一个return的值 对象 英文 中文 描述 var * ={} 字面量 创建 var * = new Object() Object 创建 function (变量名,变量名){ var = new Object() .name = ‘’ return } 工厂方式创建 function * (变量名,变量名){ this.name = ‘’ return this;//可以不写return} 自定义 构造函数 arguments.length 参数 函数声明的时候不写形参，通过这个 来获取数量 delete 对象名.属性名 删除对象中的值 for (变量名(key) in 对象名) 循环遍历 对象 for (变量名(key) in 对象名) {console.log(key); console.log(zs[key]);}","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"SQL","slug":"4.SQL","date":"2019-05-09T04:57:17.451Z","updated":"2019-05-09T04:57:44.191Z","comments":true,"path":"2019/05/09/4.SQL/","link":"","permalink":"/2019/05/09/4.SQL/","excerpt":"","text":"SQLint 整数、double 浮点数、varchar(255) 字符串、text 文本、datetime 日期、float 浮点数 数据库操作 数据库操作 //这里不要大写 create database 数据库名 增加 - 数据库 drop database 数据库名 删除 - 数据库 use 数据库名 切换 - 数据库 create table 表名 ( id int auto_increment primary key, name varchar(20) not null,) 新建 - 表 auto_increment 自动编号 primary key 主键 唯一标识 drop table 表名 删除 - 表 增 增 INSERT INTO users (uname, upwd, uqq) values(‘zs’,’123’, ‘12345’) 普通增加 INSERT INTO users values(2,’zs’,’123’, ‘12345’) 可省略字段名 删 删除 DELETE FROM users WHERE uid = 1 条件删除 DELETE FROM users 清空数据 改 改 UPDATE users SET uname=’zsxxx’, uqq=’111’ WHERE uid=1 查 查 SELECT * FROM users 普通查询 SELECT * FROM users WHERE uname like ‘%s%’ 模糊查询 SELECT * FROM users WHERE uname in (‘zs’,’ls’) in 查询 SELECT * FROM users ORDER BY 字段 DESC order by 排序 asc 默认是升序 desc 降序 SELECT * FROM users LIMIT 3 LIMIT 限制查询数量 SELECT * FROM users ORDER BY id DESC LIMIT 3 降序后取3条数据 SELECT * FROM users ORDER BY id DESC LIMIT 3,2 跳过3条，取2条 SELECT COUNT(*) FROM users 获取总条数 SELECT count(*) as sum FROM users //as 用于起别名 SELECT column_name(s) FROM table_name1 INNER JOIN table_name2 ON table_name1.column_name=table_name2.column_name where 条件 多表查询 其他 其他 = 等于 BETWEEN…AND 在某个范围内 &lt;&gt; 不等于 LIKE 搜索某种模式 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于","categories":[{"name":"sql","slug":"sql","permalink":"/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"/tags/sql/"}]},{"title":"正则表达式- 基础","slug":"3.正则","date":"2019-05-09T04:55:00.701Z","updated":"2019-05-09T04:54:53.282Z","comments":true,"path":"2019/05/09/3.正则/","link":"","permalink":"/2019/05/09/3.正则/","excerpt":"","text":"Regular Expression元字符 元字符 元字符 说明 \\d 匹配数字 \\D 匹配非数字 \\w 匹配字母或数字或下划线_ \\W 匹配非字母、数字、下划线_ \\s 匹配空白符（空格） \\S 匹配非空白符 . 匹配任意除了换行符之外的单个字符 限定符 限定符 限定符 说明 n* 匹配任何包含零个或多个 n 的字符串。n{0,} n+ 匹配任何包含至少一个 n 的字符串。{1,} n? 匹配任何包含零个或一个 n 的字符串。{0,1} n{x} 匹配包含 x 个 n 的序列的字符串 n{x,} 匹配包含至少 x 个 n 的序列的字符串。 n{x,y} 匹配包含 至少x个 至多 y 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 ^正则表达式$ 使用时，会对字符串整体校验，完全符合才能够匹配。否则，不匹配 修饰符 修饰符 → g g，全称global，有 全局 的意思，表示全局匹配。 如： var reg = /hello/g; → i i，全称ignore，有 忽视、忽略 的意思，表示匹配字母时，可以忽略字母的大小写。 如： var reg = /hello/i; → gi gi，全局匹配和忽略大小写一起使用。 如： var reg = /hello/gi; 中括号 中括号 中括号 说明 [abc] 查找一个方括号之间的任何字符。 [^abc] 查找一个任何不在方括号之间的字符。^在中括号中有取反的意思 [0-9] 查找一个任何从 0 至 9 的数字。 [a-z] 查找一个任何从小写 a 到小写 z 的字符。 [A-Z] 查找一个任何从大写 A 到大写 Z 的字符。 [A-z] 查找一个字母（包含大小写和下划线） [\\u4e00-\\u9fa5] 查找一个汉字 或模式 或模式 特殊符号：正则1\\ 正则2, 或者。 符合或两边其中一个就可以匹配。 如：google，baidu，bing; // 匹配三种其中一种字符串 正则：google\\ baidu\\ bing 分组模式 分组模式 特殊符号：(正则); 组指的是一个小集体，分组就是将一个大集体可以分成几个小集体。 如：控制你的名字连续出现的次数，最少1次，最多3次 正则：^(bruce){1,3}$ 正则转义符 正则转义符 在正则中表示特殊符号。去除.的特殊意义，需要转义： . var 变量 = new RegExp(“规则”,”修饰符”) var 变量 = /正则表达式/; var reg = /\\d/g; 正则对象.test(字符串) 用于检测字符串是否匹配。返回true和false 字符串.match(正则对象); 获取匹配正则的子字符串，返回一个伪数组。 字符串.replace(正则对象,替换内容); 替换所匹配正则的子字符串。返回替换后的字符串。","categories":[{"name":"正则","slug":"正则","permalink":"/categories/正则/"}],"tags":[{"name":"正则","slug":"正则","permalink":"/tags/正则/"}]},{"title":"ajax + jsonp","slug":"ajax + jsonp","date":"2019-05-09T03:33:47.197Z","updated":"2019-05-09T03:33:43.747Z","comments":true,"path":"2019/05/09/ajax + jsonp/","link":"","permalink":"/2019/05/09/ajax + jsonp/","excerpt":"","text":"AJAX概述背景“JavaScript 对我们而已能力有限”，我们目前所了解到的 Web 所提供的 API 都只停留在“单机游戏”的阶段。 在此之前，我们可以通过以下几种方式让浏览器发出对服务端的请求，获得服务端的数据： 地址栏输入地址，回车，刷新 特定元素的 href 或 src 属性 表单提交 这些方案都是我们无法通过或者很难通过代码的方式进行编程（对服务端发出请求并且接受服务端返回的响应），如果我们可以通过 JavaScript 直接发送网络请求，那么 Web 的可能就会更多，随之能够实现的功能也会更多，至少不再是只能开发“单机游戏”。 对 XXX 进行编程指的就是用代码的方式操作它。 Google SuggestAJAX（Asynchronous JavaScript and XML），最早出现在 2005 年的 Google Suggest，是在浏览器端进行网络编程（发送请求、接收响应）的技术方案，它使我们可以通过 JavaScript 直接获取服务端最新的内容而不必重新加载页面。让 Web 更能接近桌面应用的用户体验。 AJAX (Asynchronous Javascript And XML)说白了，AJAX 就是浏览器提供的一套 API，可以通过 JavaScript 调用，从而实现通过代码控制请求与响应。实现通过 JavaScript 进行网络编程。 至于 XML：最早在客户端与服务端之间传递数据时所采用的数据格式就是 XML。 能力不够 API 凑。 应用场景总结对于每一个未知的技术，我们在了解了过后第一反应就是在什么情况下用？ 按需获取数据 对用户数据校验 自动更新页面内容 提升用户体验，无刷新的体验 快速上手AJAX API 中核心提供的是一个 XMLHttpRequest 类型，所有的 AJAX 操作都需要使用到这个类型。 使用 AJAX 的过程可以类比平常我们访问网页过程 1234567891011121314// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器var xhr = new XMLHttpRequest()// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址xhr.open('GET', '/time')// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求xhr.send(null)// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作xhr.onreadystatechange = function () &#123; // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成 if (this.readyState === 4) &#123; // 通过 xhr 的 responseText 获取到响应的响应体 console.log(this.responseText) &#125;&#125; 注意：涉及到 AJAX 操作的页面不能使用文件协议访问（文件的方式访问） readyState由于 readystatechange 事件是在 xhr 对象状态变化时触发（不单是在得到响应时），也就意味着这个事件会被触发多次，所以我们有必要了解每一个状态值代表的含义： readyState 状态描述 说明 0 UNSENT 代理（XHR）被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用，建立了连接。 2 HEADERS_RECEIVED send() 方法已经被调用，并且已经可以获取状态行和响应头。 3 LOADING 响应体下载中， responseText 属性可能已经包含部分数据。 4 DONE 响应体下载完成，可以直接使用 responseText。 时间轴1234567s=&gt;start: UNSENTo1=&gt;operation: OPENEDo2=&gt;operation: HEADERS_RECEIVEDo3=&gt;operation: LOADINGe=&gt;end: DONEs(right)-&gt;o1(right)-&gt;o2(right)-&gt;o3(right)-&gt;e 1234567s=&gt;start: 初始化o1=&gt;operation: 建立连接o2=&gt;operation: 接收到响应头o3=&gt;operation: 响应体加载中e=&gt;end: 加载完成s(right)-&gt;o1(right)-&gt;o2(right)-&gt;o3(right)-&gt;e 123456789101112131415161718192021222324252627282930313233343536373839404142var xhr = new XMLHttpRequest()console.log(xhr.readyState)// =&gt; 0// 初始化 请求代理对象xhr.open('GET', '/time')console.log(xhr.readyState)// =&gt; 1// open 方法已经调用，建立一个与服务端特定端口的连接xhr.send()xhr.addEventListener('readystatechange', function () &#123; switch (this.readyState) &#123; case 2: // =&gt; 2 // 已经接受到了响应报文的响应头 // 可以拿到头 // console.log(this.getAllResponseHeaders()) console.log(this.getResponseHeader('server')) // 但是还没有拿到体 console.log(this.responseText) break case 3: // =&gt; 3 // 正在下载响应报文的响应体，有可能响应体为空，也有可能不完整 // 在这里处理响应体不保险（不可靠） console.log(this.responseText) break case 4: // =&gt; 4 // 一切 OK （整个响应报文已经完整下载下来了） // 这里处理响应体 console.log(this.responseText) break &#125;&#125;) 通过理解每一个状态值的含义得出一个结论：一般我们都是在 readyState 值为 4 时，执行响应的后续逻辑。 12345xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; // 后续逻辑...... &#125;&#125; 遵循 HTTP本质上 XMLHttpRequest 就是 JavaScript 在 Web 平台中发送 HTTP 请求的手段，所以我们发送出去的请求任然是 HTTP 请求，同样符合 HTTP 约定的格式： 123456789101112131415161718192021// 设置请求报文的请求行xhr.open('GET', '/time')// 设置请求头xhr.setRequestHeader('Accept', 'text/plain')// 设置请求体xhr.send(null)xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; // 获取响应状态码 console.log(this.status) // 获取响应状态描述 console.log(this.statusText) // 获取响应头信息 console.log(this.getResponseHeader('Content-Type')) // 指定响应头 console.log(this.getAllResponseHeaders()) // 全部响应头 // 获取响应体 console.log(this.responseText) // 文本形式 console.log(this.responseXML) // XML 形式，了解即可不用了 &#125;&#125; 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest 具体用法GET 请求 通常在一次 GET 请求过程中，参数传递都是通过 URL 地址中的 ? 参数传递。 12345678910111213var xhr = new XMLHttpRequest()// GET 请求传递参数通常使用的是问号传参// 这里可以在请求地址后面加上参数，从而传递数据到服务端xhr.open('GET', '/delete?id=1')// 一般在 GET 请求时无需设置响应体，可以传 null 或者干脆不传xhr.send(null)xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText) &#125;&#125;// 一般情况下 URL 传递的都是参数性质的数据，而 POST 一般都是业务数据 POST 请求 POST 请求过程中，都是采用请求体承载需要提交的数据。 1234567891011121314var xhr = new XMLHttpRequest()// open 方法的第一个参数的作用就是设置请求的 methodxhr.open('POST', '/add')// 设置请求头中的 Content-Type 为 application/x-www-form-urlencoded// 标识此次请求的请求体格式为 urlencoded 以便于服务端接收数据xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')// 需要提交到服务端的数据可以通过 send 方法的参数传递// 格式：name=zhangsan&amp;age=18xhr.send('name=zhangsan&amp;age=18')xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText) &#125;&#125; 同步与异步关于同步与异步的概念在生活中有很多常见的场景，举例说明。 同步：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作（不需要看管）不去做别的事，只是等待 异步：在执行一些耗时的操作（不需要看管）去做别的事，而不是等待 xhr.open() 方法第三个参数要求传入的是一个 bool 值，其作用就是设置此次请求是否采用异步方式执行，默认为 true，如果需要同步执行可以通过传递 false 实现： 123456789101112console.log('before ajax')var xhr = new XMLHttpRequest()// 默认第三个参数为 true 意味着采用异步方式执行xhr.open('GET', '/time', true)xhr.send(null)xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; // 这里的代码最后执行 console.log('request done') &#125;&#125;console.log('after ajax') 如果采用同步方式执行，则代码会卡死在 xhr.send() 这一步： 123456789101112131415console.log('before ajax')var xhr = new XMLHttpRequest()// 同步方式xhr.open('GET', '/time', false)// // 同步方式 执行需要 先注册事件再调用 send，否则 readystatechange 无法触发// xhr.onreadystatechange = function () &#123;// if (this.readyState === 4) &#123;// // 这里的代码最后执行// console.log('request done')// &#125;// &#125;xhr.send(null)// 因为 send 方法执行完成 响应已经下载完成console.log(xhr.responseText)console.log('after ajax') 演示同步异步差异。 所以一定在发送请求 send() 之前注册 readystatechange（不管同步或者异步） 为了让这个事件可以更加可靠（一定触发），一定是先注册 了解同步模式即可，切记不要使用同步模式。 至此，我们已经大致了解了 AJAX 所的提供的基本 API 。 XMLHttpRequest API 总结属性 readyState status responseText responseXML onreadystatechange 方法 open(method, url, async) send(requsetBody) setRequestHeader(key, value) getResponseHeader(key) 响应数据格式 提问：如果希望服务端返回一个复杂数据，该如何处理？ 关心的问题就是服务端发出何种格式的数据，这种格式如何在客户端用 JavaScript 解析。 XML一种数据描述手段 老掉牙的东西，简单演示一下，不在这里浪费时间，基本现在的项目不用了。 淘汰的原因：数据冗余太多 JSON也是一种数据描述手段，类似于 JavaScript 字面量方式 服务端采用 JSON 格式返回数据，客户端按照 JSON 格式解析数据。 注意： 不管是 JSON 也好，还是 XML，只是在 AJAX 请求过程中用到，并不代表它们与 AJAX 之间有必然的联系，它们只是数据协议罢了。 不管服务端是采用 XML 还是采用 JSON 本质上都是将数据返回给客户端。 服务端应该根据响应内容的格式设置一个合理的 Content-Type。 留言板案例 页面结构 数据接口 AJAX 实现 处理响应数据渲染客户端中拿到请求的数据过后最常见的就是把这些数据呈现到界面上。 如果数据结构简单，可以直接通过字符串操作（拼接）的方式处理，但是如果数据过于复杂，字符串拼接维护成本太大，就不推荐了。 模板引擎： artTemplate：https://aui.github.io/art-template/ 模板引擎实际上就是一个 API，模板引擎有很多种，使用方式大同小异，目的为了可以更容易的将数据渲染到HTML字符串中。 缓存问题缓存问题指的是：多次 AJAX GET 请求同一个 URL 得到的结果是相同的，目前绝大多数浏览器已经没有这个问题了，只有早期的 IE 浏览器（&lt;= IE 9）任然存在这个问题 12345678var xhr = new XMLHttpRequest()xhr.open('GET', '/time')xhr.send(null)xhr.onreadystatechange = function () &#123; if (this.readyState !== 4) return console.log(this.responseText) // =&gt; 每次得到的结果都是相同的&#125; 解决方案URL 加戳这个办法的核心就是让浏览器认为每次请求的地址都是不同的。 不同的 querystring 会被浏览器认为是不同的地址，浏览器会忽略客户端缓存。 12345678var xhr = new XMLHttpRequest()xhr.open('GET', '/time?t=' + Date.now())xhr.send(null)xhr.onreadystatechange = function () &#123; if (this.readyState !== 4) return console.log(this.responseText) // =&gt;&#125; *服务端设置响应头由服务端通过 HTTP 响应报文中的响应头告知客户端浏览器不要缓存当前地址。 123456app.get('/time', (req, res) =&gt; &#123; res.set('Cache-Control', 'no-cache') res.set('Pragma', 'no-cache') res.set('Expires', '-1') res.send(Date.now().toString())&#125;) 了解即可，更多的情况下前端开发中还是通过加戳的方式解决此问题，因为在前端可控范围之内。 兼容方案XMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题，可以通过另外一种方式代替。 12var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP')// xhr 的成员相同 封装AJAX 请求封装 函数就可以理解为一个想要做的事情，函数体中约定了这件事情做的过程，直到调用时才开始工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 发送一个 AJAX 请求 * @param &#123;String&#125; url 请求地址 * @param &#123;String&#125; method 请求方法 * @param &#123;Object&#125; params 请求参数 * @param &#123;Function&#125; done 请求完成过后需要做的事情（委托/回调） */function ajax (url, method, params, done) &#123; // 统一转换为大写便于后续判断 method = method.toUpperCase() // 对象形式的参数转换为 urlencoded 格式 var pairs = [] for (var key in params) &#123; pairs.push(key + '=' + params[key]) &#125; var querystring = pairs.join('&amp;') var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP') xhr.addEventListener('readystatechange', function () &#123; if (this.readyState !== 4) return // 尝试通过 JSON 格式解析响应体 try &#123; done(JSON.parse(this.responseText)) &#125; catch (e) &#123; done(this.responseText) &#125; &#125;) // 如果是 GET 请求就设置 URL 地址 问号参数 if (method === 'GET') &#123; url += '?' + querystring &#125; xhr.open(method, url) // 如果是 POST 请求就设置请求体 var data = null if (method === 'POST') &#123; xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') data = querystring &#125; xhr.send(data)&#125;ajax('get', '/getsomthing', &#123; id: 123 &#125;, function (data) &#123; console.log(data)&#125;)ajax('post', '/addsomthing', &#123; foo: 'posted data' &#125;, function (data) &#123; console.log(data)&#125;) 委托：将函数作为参数传递就像是将一个事情交给别人，这就是委托的概念 jQuery 中的 AJAXjQuery 中有一套专门针对 AJAX 的封装，功能十分完善，经常使用，需要着重注意。 一个你会用我会用他会用到的点，就一定有一个已经封装好的 参考： http://www.jquery123.com/category/ajax/ http://www.w3school.com.cn/jquery/jquery_ref_ajax.asp $.ajax123456789101112131415161718$.ajax(&#123; url: '/time', type: 'get', dataType: 'json', data: &#123; id: 1 &#125;, beforeSend: function (xhr) &#123; console.log('before send') &#125;, success: function (data) &#123; console.log(data) &#125;, error: function (xhr) &#123; console.log(xhr) &#125;, complete: function (xhr) &#123; console.log('request completed') &#125;&#125;) 常用选项参数介绍： url：请求地址 type：请求方法，默认为 get dataType：服务端响应数据类型 contentType：请求体内容类型，默认 application/x-www-form-urlencoded data：需要传递到服务端的数据，如果 GET 则通过 URL 传递，如果 POST 则通过请求体传递 timeout：请求超时时间 beforeSend：请求发起之前触发 success：请求成功之后触发（响应状态码 200） error：请求失败触发 complete：请求完成触发（不管成功与否） $.getGET 请求快捷方法 $.get(url, data, callback) $.postPOST 请求快捷方法 $.post(url, data, callback) 全局事件处理 http://www.jquery123.com/category/ajax/global-ajax-event-handlers/ 1234567891011121314151617.ajaxComplete()//当Ajax请求完成后注册一个回调函数。这是一个 AjaxEvent。Ajax &gt; 全局 Ajax 事件处理器.ajaxError()//Ajax请求出错时注册一个回调处理函数，这是一个 Ajax Event。Ajax &gt; 全局 Ajax 事件处理器.ajaxSend()//在Ajax请求发送之前绑定一个要执行的函数，这是一个 Ajax Event.Ajax &gt; 全局 Ajax 事件处理器.ajaxStart()//在AJAX 请求刚开始时执行一个处理函数。 这是一个 Ajax Event.Ajax &gt; 全局 Ajax 事件处理器.ajaxStop()//在AJAX 请求完成时执行一个处理函数。 这是一个 Ajax Event。Ajax &gt; 全局 Ajax 事件处理器.ajaxSuccess()//绑定一个函数当 Ajax 请求成功完成时执行。 这是一个Ajax Event. AxiosAxios 是目前应用最为广泛的 AJAX 封装库，相对于 jQuery 的优势在于功能能强劲，职责更单一，后期专门有介绍。 1234567axios.get('/time') .then(function (res) &#123; console.log(res.data) &#125;) .catch(function (err) &#123; console.error(err) &#125;) *扩展：https://github.com/axios/axios 跨域相关概念同源策略是浏览器的一种安全策略，所谓同源是指域名，协议，端口完全相同，只有同源的地址才可以相互通过 AJAX 的方式请求。 同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为跨域请求 什么是同源？例如：http://www.example.com/detail.html 与一下地址对比 对比地址 是否同源 原因 http://api.example.com/detail.html 不同源 域名不同 https://www.example.com/detail.html 不同源 协议不同 http://www.example.com:8080/detail.html 不同源 端口不同 http://api.example.com:8080/detail.html 不同源 域名、端口不同 https://api.example.com/detail.html 不同源 协议、域名不同 https://www.example.com:8080/detail.html 不同源 端口、协议不同 http://www.example.com/other.html 同源 只是目录不同 解决方案现代化的 Web 应用中肯定会有不同源的现象，所以必然要解决这个问题，从而实现跨域请求。 参考：http://rickgray.me/solutions-to-cross-domain-in-browser JSONPJSON with Padding，是一种借助于 script 标签发送跨域请求的技巧。 其原理就是在客户端借助 script 标签请求服务端的一个地址，服务端的这个地址返回一段带有调用某个全局函数调用的 JavaScript 脚本（而非一段 HTML），将原本需要返回给客户端的数据通过参数传递给这个函数，函数中就可以得到原本服务端想要返回的数据。 以后绝大多数情况都是采用 JSONP 的手段完成不同源地址之间的跨域请求 客户端 http://www.zce.me/users-list.html 1&lt;script src=\"http://api.zce.me/users?callback=foo\"&gt;&lt;/script&gt; 服务端 http://api.zce.me/users?callback=foo 返回的结果 1foo(['我', '是', '你', '原', '本', '需', '要', '直', '接', '返', '回', '的', '数', '据']) 总结一下：由于 XMLHttpRequest 无法发送不同源地址之间的跨域请求，所以我们必须要另寻他法，script 这种方案就是我们最终选择的方式，我们把这种方式称之为 JSONP，如果你不了解原理，先记住怎么用，多用一段时间再来看原理。 问题： JSONP 需要服务端配合，服务端按照客户端的要求返回一段 JavaScript 调用客户端的函数 只能发送 GET 请求 注意：JSONP 用的是 script 标签，更 AJAX 提供的 XMLHttpRequest 没有任何关系！！！ jQuery 中对 JSONP 的支持jQuery 中使用 JSONP 就是将 dataType 设置为 jsonp 123456789101112131415161718$.ajax(&#123; url: 'https://douban.uieee.com/v2/comming_soon', type: 'get', dataType: 'json', data: &#123; id: 1 &#125;, beforeSend: function (xhr) &#123; console.log('before send') &#125;, success: function (data) &#123; console.log(data) &#125;, error: function (xhr) &#123; console.log(xhr) &#125;, complete: function (xhr) &#123; console.log('request completed') &#125;&#125;) Axios 由于设计原因不支持 JSONP CORSCross Origin Resource Share，跨域资源共享 1234567app.get('/time', (req, res) =&gt; &#123; // // 允许任意源访问，不安全 // res.set('Access-Control-Allow-Origin', '*') // 允许指定源访问 res.set('Access-Control-Allow-Origin', 'http://zce.me') res.send(Date.now().toString())&#125;) 这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个 Access-Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS XMLHttpRequest 2.0 暂作了解，无需着重看待 HTML5 中对 XMLHttpRequest 类型全面升级，更易用，更强大 response 属性onload / onprogress12345678910111213var xhr = new XMLHttpRequest()xhr.open('GET', '/time')xhr.onload = function () &#123; // onload readyState =&gt; 4 // 只在请求完成时触发 console.log(this.readyState)&#125;xhr.onprogress = function () &#123; // onprogress readyState =&gt; 3 // 只在请求进行中触发 console.log(this.readyState)&#125;xhr.send(null) FormData以前 AJAX 操作只能提交字符串，现在可以提交 二进制 的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script&gt;$(function () &#123; // 当用户在文件域中选择了一个文件过后 $('#input_avatar').on('change', function () &#123; // this.files[0] =&gt; 拿到选中的文件对象 var file = this.files[0] // 希望展示这个文件有两种方式： // 1. FileReader // 2. URL.createObjectURL() // 给用户选择的文件对象创建一个临时 URL，用这个 URL 呈现图片 var url = URL.createObjectURL(file) $('#avatar_preview').attr('src', url).hide().fadeIn() &#125;) // 1. 文件域有个 change 事件，在用户选择完文件后触发 // 2. 文件域有个 accept 属性，用于设置文件域的文件类型限制 // 3. 文件域可以同 multiple 设置多选 // 4. JS 中可以通过 input dom 的 files 属性访问到选中的文件，数组 $('#btn_save').on('click', function () &#123; var file = $('#input_avatar')[0].files[0] if (!file) &#123; alert('必须选择文件') return false &#125; // HTML5 中提供了一个 专门用于提交复杂数据 AJAX 情况的类型 FormData var data = new FormData() data.append('name', $('#input_name').val()) data.append('bio', $('#input_bio').val()) data.append('avatar', file) var xhr = new XMLHttpRequest() xhr.open('POST', '/api/member-add') // send 除了可以接受 string 类型的参数 也可接受 FormData 类型 xhr.responseType = 'json' xhr.send(data) xhr.addEventListener('load', function () &#123; console.log(this.response) window.location.href = '/index.html' &#125;) return false &#125;)&#125;)&lt;/script&gt; responseType1234567891011//一般情况下 服务端都是会以 JSON 字符串的格式返回响应内容// response 会有几种情况，默认请情况下 response === responseText// 如果想要拿到对象结果，可以通过 responseType 设置 var xhr = new XMLHttpRequest() xhr.open('GET', '/page') xhr.responseType = 'document' xhr.send() xhr.addEventListener('load', function () &#123; console.log(this.response.querySelector('h1')) &#125;) 案例异步上传文件 参考链接 http://www.w3school.com.cn/ajax/index.asp https://aui.github.io/art-template/zh-cn","categories":[{"name":"ajax、jsonp","slug":"ajax、jsonp","permalink":"/categories/ajax、jsonp/"}],"tags":[{"name":"ajax、jsonp","slug":"ajax、jsonp","permalink":"/tags/ajax、jsonp/"}]},{"title":"Git - 基础","slug":"Git - 基础","date":"2019-05-09T03:31:16.682Z","updated":"2019-05-09T03:31:09.793Z","comments":true,"path":"2019/05/09/Git - 基础/","link":"","permalink":"/2019/05/09/Git - 基础/","excerpt":"","text":"Git是什么Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去。 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 文件名 用户 说明 日期 1 service.doc 张三 删除了软件服务条款5 7/12 10:38 2 service.doc 张三 增加了License人数限制 7/12 18:09 3 service.doc 李四 财务部门调整了合同金额 7/13 9:51 4 service.doc 张三 延长了免费升级周期 7/14 15:17 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 Git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 集中式vs分布式Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 安装在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建版本库选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的（不要手动修改） 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 将文件上传到Git 一定要放到learngit目录下（子目录也行） 第一步，用命令git add告诉Git，把文件添加到仓库： 1$ git add 文件名（+后缀） 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容 git commit命令执行成功后会告诉你： ​ 1 file changed：1个文件被改动 ​ 2 insertions：插入了两行内容（readme.txt有两行内容）。 常用命令整理.gitignore → 该文件内容中制定的文件/文件夹不会被git push 初始化 设置用户名 git config –global user.name ‘我的名字’ 设置用户邮箱 git config –global user.email ‘我的邮箱’ 仓库相关 拉取(本地有仓库) git pull 仓库地址 分知名 git pull 仓库地址 master 克隆(本地无仓库) git clone 仓库地址 *项目名 提交 git push 仓库地址 分支名 git push 仓库地址 master 远程仓库别名 git remote add 别名 仓库地址 初始化仓库 git init –bare 本地仓库需要初始化 注：提交前，先拉取 克隆前init、克隆后 git add + git commit 本地相关 初始化仓库 git init 提交暂存区 git add * // git add 文件路径 本地回滚 git checkout 文件路径 从暂存区恢复文件 提交仓库 git commit -m’备注’ 本地回滚 git reset –hard 版本号 从仓库中恢复文件 查询文件状态 git status 查看当前+之前版本 git log 查看版本操作记录 git reflog 分支 查看分支 git branch 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 创建+切换分支 git checkout -b * 删除分支 git branch -d 分支名称 合并分支 git merge 分支名称 当前分支合并所选分支(注 同文件冲突) 创建SSH公钥 ssh-keygen -t rsa 一路回车 公钥：C:\\Users\\nova.ssh/id_rsa.pub 将公钥添加到github中","categories":[{"name":"Git","slug":"Git","permalink":"/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"}]},{"title":"JS高级笔记","slug":"JS高级笔记","date":"2019-05-09T03:30:19.347Z","updated":"2019-05-09T03:30:16.613Z","comments":true,"path":"2019/05/09/JS高级笔记/","link":"","permalink":"/2019/05/09/JS高级笔记/","excerpt":"","text":"JS高级笔记一、前面知识点复习 创建相同结构对象是，为避免代码重复，可以使用函数对代码进行优化，也就是创建构造函数 什么是构造函数 当一个函数通过new的方式调用，我们就将这个函数称为构造函数构 造函数的作用：创建对象 使用规范 首字母大写(建议) 调用前加new this的使用 this在方法内使用才有意义，指向函数调用者 特殊场景，当使用new调用函数时，函数内的this指向实例对象​ new帮我们做了什么？​ 使用构造函数时需要注意的点 （如果给构造函数设置返回值 返回值为基本数据类型：会被忽略 如果返回值为复杂数据类型，这个值会替换掉原有的对象 思考：属性通常都是不同的，但是由于方法表示功能，功能通常是相同的，所以方法保存为多个相同的函数是没有意义的，并且浪费空间，如何将多个实例的方法值保存为一个共有的函数 二、关于原型对象相关概念 每个函数都有一个(自带)属性：prototype 原型a. 这个属性是一个对象，作用就是用于进行共有属性的保存使用的b. prototype属性称为原型属性，也称为原型对象c. 直接给这个对象设置方法即可，设置后所有的实例对象均可使用这个方法​ 此时已经可以回答上面问题——可以把公用的属性或者方法放到原型对象里，通过这样原型链查找规则可以共享，节约内容，提高性能​ 为什么这个方法没有设置给实例对象本身，但是实例对象也可以使用呢？ 通过观察我们发现，每个实例对象都具有一个自带的属性 __proto__ ，这个属性中具有设置给 构造函数.prototype的方法 通过测试构造函数.prototype === 实例对象.__proto__结果为true可得出结论—— 两个属性指针指向的是同一个对象 基本访问规则：当我们使用一个对象的属性时，如果自身有，就使用，如果没有，则查找 __proto__ 中，如果有，就使用。​ 什么是原型链: 对象属性的查找方式：对象自身存在实力属性时，使用，否则，查找__proto__属性，这种查找方式称为原型链。原型链是用来描述实例对象与原型对象之间关系的一种方式。 其他小知识点 如何检测数据类型typeof，但是只能检测基本数据类型，实际上typeof在检测数据类型时，如果数据为一个指针，会认为是object 其他常用的类型检测方式： Array.isArray() —— 检测数据类型是否为数组，ie9以下不支持 instanceof 需要前后两个操作数，前操作数为实例对象，后操作数为构造函数，如果实例对象是通过构造函数创建的，返回true，否则返回false 123console.log([1,2,3] instanceof Array); //trueconsole.log(200 instanceof Array); //false Object.prototype.toString.call() 返回的结果为数据类型名:(固定用法，记住即可) 123console.log(Object.prototype.toString.call(null));//&quot;[object Null]&quot;console.log(Object.prototype.toString.call([1,2,3]));//&quot;[object Array]&quot; 总结：以后需要检测实例对象和构造函数之间关系的时候，就使用 instanceof 就好了。 三、关于继承 继承的作用：为了更好的数据共享 继承含义：多个构造函数之间的关系 实现方式： 借用构造函数继承 设置需要被继承的构造函数Animal 1234567function Animal(name,age)&#123; this.name = name; this.age = age;&#125;Animal.prototype.eat = function()&#123; console.log(\"吃各种吃的\");&#125;; 再设置一个猫咪构造函数已经存在的构造函数Animal中具有了一些属性和方法，这些属性与方法是Cat构造函数需要的没有必要再书写一遍了，可以使用继承的方式获取 1234567function Cat(name,age)&#123; //函数可以通过函数名()的方式调用，也可以通过函数的call方法调用 //通过call的方式，修改Animal中的this指向为当前Cat的this，并设置参数 //call方法的参数1表示函数内的this指向 //call方法的后面的其他参数表示真正的实参 Animal.call(this,name,age);&#125; 上面这种继承方法称为借用构造函数 效果：可以继承实例属性，但是原型中的方法无法继承 ​ 原型继承 12345678910111213141516171819202122232425262728function Animal(name,age)&#123; this.name = name; this.age = age;&#125;Animal.prototype.eat = function()&#123; console.log(\"吃各种吃的\");&#125;;function Cat(color)&#123; this.color = color;&#125;//继承的核心代码：Cat.prototype = new Animal(\"jack\",18);//设置被覆盖的constructor属性Cat.prototype.constructor = Cat;Cat.prototype.shangShu = function()&#123; console.log(\"猫咪可以爬树\");&#125;;var c1 = new Cat(\"red\");console.log(c1);console.log(c1.name);console.log(c1.age);console.log(c1.color);c1.shangShu();c1.eat(); 使用原型继承的方式： 好处：可以继承原型中的方法 缺点：实例属性虽然有，但是无法传参（跟没有一样）​ 组合继承 ​ 使用前面两种继承方式是发现各有优缺点，所以将两种方式集合使用 ​ 这种结合使用的方式，称为组合继承，组合继承是最常用的一种继承方式 12345678910111213141516171819202122232425262728293031function Animal(name,age)&#123; this.name = name; this.age = age;&#125;Animal.prototype.eat = function()&#123; console.log(\"吃各种吃的\");&#125;;function Cat(name,age,color)&#123; //使用借用构造函数的方式继承： Animal.call(this,name,age); this.color = color; &#125; //原型继承的核心代码： //使用组合继承方式后，在构造函数体中就设置了实例属性，此处不需要传参 Cat.prototype = new Animal(); //设置被覆盖的constructor属性 Cat.prototype.constructor = Cat; Cat.prototype.shangShu = function()&#123; console.log(\"猫咪可以爬树\"); &#125;; var c1 = new Cat(\"rose\",20,\"red\"); console.log(c1); console.log(c1.name); console.log(c1.age); console.log(c1.color); c1.shangShu(); c1.eat(); console.log(c1.constructor); ​ 对象之间的继承 对象的拷贝（需要掌握） 123456789101112131415161718192021var obj = &#123; name:\"jack\", age:18, gender:\"男\", children:&#123; daughter:\"lili\", son:&#123; name:\"tom\", age:12 &#125; &#125;, sayHi:function()&#123; console.log(\"呵呵，我是人\"); &#125;&#125;;var obj2 = &#123;&#125;;for(var k in obj)&#123; obj2[k] = obj[k];&#125;console.log(obj); 思考：由于obj中的某个属性也是对象形式，进行拷贝操作时使用赋值运行导致两者相同，如何完全拷贝对象内的所有属性(包括属性的属性，达到完全无关的目的) 1234567891011121314151617181920//currentObj表示哪个元素要被拷贝//targetObj表示要拷贝到哪个对象中function deepCopy(currentObj,targetObj)&#123; for(var k in currentObj)&#123; if(typeof currentObj[k] != \"object\" || currentObj[k] === null)&#123; //基本拷贝方式只适用于基本数据类型 targetObj[k] = currentObj[k]; &#125;else&#123; //如果进入else，说明currentObj[k]属性值为复杂数据类型, //想要复制复杂数据类型需要使用deepCopy函数 //要求:两个参数都必须为对象形式，由于targetObj[k]为undefined，需要先赋值为对象再使用 //完善功能：复杂数据类型值有可能是对象，也有可能是数组，需要进行判断后再设置 targetObj[k] = currentObj[k] instanceof Array ? [] : &#123;&#125;; deepCopy(currentObj[k],targetObj[k]); &#125; &#125;&#125;var obj2 = &#123;&#125;;deepCopy(obj,obj2); 四、函数进阶函数的概念：函数是由事件驱动的或在调用时执行的可重复使用的代码块。 1、arguments 对象 arguments是伪数组(类数组)对象：没有数组方法 使用方式：只能再函数内使用，表示当前函数的实参列表 作用：由于形参的设置时固定的，如果用户传入的实参更多时，只能使用arguments访问 思考：伪数组如何使用数组方法 ​ 因为不是通过Array创建的，所以无法访问Array.prototype如何使用： 1234567891011121314151617var fun = function(a,b)&#123; console.log(arguments); //下面两个函数是同一个函数 //[1,2,3].__proto__.push; //Array.prototype.push; //通过call借用数组push方法 Array.prototype.push.call(arguments,200); //下面这个代码跟上面的代码功能相同，但是多创建了一个实例 //[].push.call(arguments,200); //console.log(arguments);&#125;;fun(1,2); 2、函数的方法call和apply2.1. call() 方法调用 12345var fun = function(num,str)&#123; console.log(\"我是fun\",num,str,this);&#125;;fun.call(&#123;name:\"jack\"&#125;,200,\"call调用\"); 2.2. apply() 方法调用 12//参数1 用于设置函数的this指向 参数2 需要传入的实参值，需要为数组形式(就一个);fun.apply(&#123;name:\"rose\"&#125;,[300,\"apply调用\"]); call与apply的区别：call传入实参时需要单个传入，apply传入实参时需要为数组结构 函数代码的执行方式有几种？ 普通调用 call() apply() 事件驱动​ 3、函数的方法 bind 方法 使用 基本使用：设置this指向后，返回当前函数的副本 12var resultFun = fun.bind(&#123;name:\"jack\"&#125;);//不会执行函数，this指向修改了resultFun(); 与上一组 的区别：call和apply 调用后，函数会立刻执行，bind调用后，函数不会立刻执行，而是返回副本123456783. 实参传递方式 ```javascript //如果使用bind方法时设置了实参值，则返回的函数副本对应实参位置永远是这个值了 var resultFun = fun.bind(&#123;name:&quot;jack&quot;&#125;,100); resultFun(); resultFun(); 对函数副本进行调用时传入的实参会向后顺延 例如：例如：resultFun这个函数在设置时num被设置为100，则本次传入的实参值对应的是形参str 1resultFun(\"我是bind返回的函数\"); 注意点： bind方法在ie9以下不支持，感兴趣可以自己查mdn 找解决方法 ​ 五、关于闭包5.1 作用域 开始学习闭包前，先简单回顾一下作用域 作用域，可分为局部作用域和全局作用域。 作用域内变量查找规则：会先从本作用域中去找，若没找到则向上级作用域中去找，以此类推就构成了作用域链儿。​ 5.2 关于闭包 关于闭包定义，这里引用 阮一峰 博客中的一段话作为解释 1234567891011121314151617181920212223242526//各种专业文献上的\"闭包\"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。//由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。//定义在一个函数内部并引用父级作用域变量的函数//所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。// 闭包，延展变量的作用范围function fn() &#123; var num = 10; return &#123; getNum: function () &#123; return num; &#125;, setNum: function (n) &#123; num = n; &#125; &#125;&#125;var obj = fn();// 在全局作用域中，操作了fn作用域中的变量numobj.setNum(50);console.log(obj.getNum()); 闭包用途 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中(延展变量的使用范围)​ 使用闭包的优缺点 （优点不理解可以将上面闭包用途当做优点来回答） 优点： 逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。 方便调用上下文的局部变量。 （什么事上下文：上下文总是关键字 this 的值，是调用当前可执行代码的对象的引用） 加强封装性，是第2点的延伸，可以达到对变量的保护作用。 缺点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。​ 如何解决闭包内存泄漏问题 手动释放内存： 源码： 12345678910111213function Cars()&#123; this.name = \"Benz\"; this.color = [\"white\",\"black\"]; &#125; Cars.prototype.sayColor = function()&#123; var outer = this; return function()&#123; return outer.color &#125;; &#125;; var instance = new Cars(); console.log(instance.sayColor()()) 优化后： 1234567891011121314function Cars()&#123; this.name = \"Benz\"; this.color = [\"white\",\"black\"]; &#125; Cars.prototype.sayColor = function()&#123; var outerColor = this.color; //保存一个副本到变量中 return function()&#123; return outerColor; //应用这个副本 &#125;; outColor = null; //释放内存 &#125;; var instance = new Cars(); console.log(instance.sayColor()()) 闭包的使用场景 采用函数引用方式的setTimeout调用。 原生的setTimeout有一个缺陷，你传递的第一个函数不能带参数。即 1setTimeout(func(parma),1000); 这样的语句是不生效的（不过在不同浏览器中有不同的错误，总之都无法达到预期效果） 这时，我们就可以用闭包来实现这个效果了。 1234567function func(param) &#123; return function() &#123; alert(param); &#125;&#125;var f = func(1)setTimeout(f, 1000); 使用闭包可以在JavaScript中模拟块级作用域 ECMAScript6标准之前的JavaScript本身没有块级作用域的概念; 12345678function outputNumbers(count)&#123; (function()&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //导致一个错误！&#125; 闭包可以用于在对象中创建私有变量 12345678910111213//闭包可以用于在对象中创建私有变量function MyObject()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 特权方法,调用私有方法、函数 this.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;&#125; 将函数关联到对象的实例方法 封装相关的功能集​ 最后两个可以[参考http://www.jb51.net/article/110706.htm","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}]},{"title":"node + 插件 + 包 + 模块","slug":"node + 插件 + 包 + 模块","date":"2019-05-09T03:28:32.690Z","updated":"2019-05-09T03:28:29.068Z","comments":true,"path":"2019/05/09/node + 插件 + 包 + 模块/","link":"","permalink":"/2019/05/09/node + 插件 + 包 + 模块/","excerpt":"","text":"Node.js JavaScript运行环境 除了node安装以外，其余插件安装均在cmd中进行 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 特点：事件驱动、非阻塞 IO（异步） 模型、单线程、跨平台 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 安装 1234567安装node环境 执行*.exe安装文件 检测是否安装成功 node -v安装cnpm(包管理工具) (需要完善) npm install -g cnpm --registry=https://registry.npm.taobao.org 检测是否安装成功 cnpm - v 升级 12345678910# 全局安装n$ npm install -g n# 升级到最新稳定版$ n stable # 升级到最新版$ n latest# 升级到定制版$ n v7.10.0# 切换使用版本$ n 7.10.0 (ENTER) npm(包) npm全称Node Package Manager`(node 包管理器)，它的诞生是为了解决 Node 中第三方包共享的问题。 npm 不需要单独安装。在安装Node的时候，会连带一起安装npm。 本地安装：安装到当前项目中 全局安装：安装到电脑系统中，各个项目都可以调用 常用命令: 查看 npm 版本 12npm --versionnpm -v 升级 npm 12npm install npm --globalnpm install npm -g 初始化 package.json 1npm init -y 安装第三方包 123456npm install 包名npm install 包名 包名npm install 包名@版本号npm install --production // 只下载dependencies依赖包npm install // devDependencies和 dependencies依赖包 都下载 从缓存目录安装包 12345# 查看缓存目录npm config get cache# 从缓存目录下载包# --cache-min 后面跟的是时间，单位是分钟，超过这个时间才去服务器下载npm install --cache-min 9999999 &lt;package-name&gt; package.json 12345678910111213141516main：制订入口文件dependencies：依赖 //~1.2.2 代表安装1.2.x 以上的版本 //^1.2.2 代表安装1.x.x 以上的版本 script：命令行 \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"node app.js\", \"t\": \"dir c:\\\\\" &#125; npm run t npm run start # 只有 start 可以简化调用 npm start —配置生产、开发环境变量 12345678 \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"cross-env NODE_ENV=development nodemon app.js\", \"start\": \"cross-env NODE_ENV=production nodemon app.js\" &#125;,//设置环境变量后 可以通过nodemon 环境变量名(dev) 运行//注意看“cross-env”插件 node.js 第三方模块使用教程 (开发项目中的安装模块方法) 在使用第三方模块之前，需要在当前项目中建立一个 package.json 文件(不能包含中文) 方法：cmd中 输入npm init -y 模块的加载机制 123456789Node.js 中的模块化遵守 CommonJS 规范，CommonJS 是模块化的一种规范，Node.js 中实现了这种规范。- 如果不是文件模块，也不是核心模块- node 会去 node_modules 目录中找（找跟你引用的名称一样的目录），例如这里 require(&apos;moment&apos;)- 如果在 node_modules 目录中找到 moment 目录，则找该目录下的 package.json 文件- 如果找到 package.json 文件，则找该文件中的 main 属性，拿到 main 指定的入口模块- 如果过程都找不到，node 则取上一级目录下找 node_modules 目录，规则同上- 如果一直找到代码文件的根路径还找不到，则报错 一般工具Gulp 压制代码、部署浏览器同步测试工具 安装 123cnpm install gulp -g检测是否安装成功: gulp - v 本地环境搭建 123456789101112初始化 在对应的工作目录下 按下 shift 选中在命令窗口中打开 安装插件 # 当前项目中安装gulp cnpm install gulp --save-dev # 压缩html的插件 cnpm install gulp-htmlmin --save-dev # 压缩css的插件 cnpm install gulp-cssmin --save-dev # 自动打开浏览器，并实时刷新插件(浏览器同步测试工具) cnpm install browser-sync --save-dev 配置文件 1234567将gulpjs文件复制到项目根目录下自动化压缩和复制文件到发布目录dist gulp build 开启测试用的服务器 gulp dev LESS CSS 预处理语言，增加了诸如变量、混合（mixin）、函数等功能 安装 12345678运行cmd命令输入: npm install less -g验证less是否安装成功 lessc -v 安装成功后新建一个less文件即可 *.less 将Less文件编译为CSS文件 1234运行cmd命令输入: 注意: 首先要通过cmd命令进入到当前less文件所在的文件夹目录中 编译less文件cmd命令: lessc 要被编译的less文件 要编译为自定义CSS文件 例如: lessc index.less index.css 开发工具配置 123456789webstorm自带less编译功能,实时编译webStorm: 配置快捷键方式进行编译 ◆ 文件 - &gt; 设置 - &gt; 工具 -&gt; file watchers -&gt; 选择less文件点击编辑 -&gt; 取消实时编译选项 ◆ 文件 - &gt; 设置 -&gt; 快捷键 - &gt; 插件 - &gt; File watchers -&gt; 点击右键添加键盘快捷键 Sublime安装插件: LESS2CSS 安装编译插件: ctral+shift+P ---&gt; 在搜索栏中输入 LESS2CSS VSCode需要安装插件: Easy Less 安装成功后 Ctrl+s保存即可 babel ECMAScript 6 降级处理 官网 步骤概述 12345降级处理 babel 的使用步骤 1. 安装Node.js 2. 命令行中安装 babel 3. 配置文件 .babelrc 4. 运行 安装 1npm install @babel/core @babel/cli @babel/preset-env 使用 12345678910配置文件 .babelrc &#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;] &#125;在命令行中，运行 # 把转换的结果输出到指定的文件 babel index.js -o test.js # 把转换的结果输出到指定的目录 babel src -d lib browser-sync 简单服务器（文件更新后不需要刷新网页） 官网 安装 1npm install -g browser-sync forever node服务器，关闭cdm后 服务器依然会运行 官网 安装 1npm i forever -g 使用 1forever start (node服务器入口文件 例 app.js) nodemon 自动重启项目工程 官网 安装 1npm install -g nodemon 使用 12345cmd中用nodemon替换node 运行服务器程序： nodemon *例如： node app.js → nodemon app.js 其他类似模块 forever，nodemon，node-dev mime 根据后缀名生成 Content-Type值 官网 安装 1npm install mime 使用 12const Mime = require(&apos;mime/Mime&apos;);Mime.getType(&apos;abc&apos;); glob 文件路径获取工具 官网 安装 123npm i glob//or 下载js文件 语法 123456789var glob = require(\"glob\")glob(\"**/*.js\", options, function (er, files) &#123;&#125;)//orvar mg = new Glob(pattern, options, cb) moment 日期处理类库,用于解析、检验、操作、显示日期 官网 安装 1npm install moment 使用 123moment().format(&apos;dddd&apos;); // 星期一moment().format(&quot;MMM Do YY&quot;); // 12月 10日 18moment().format(&apos;YYYY [escaped] YYYY&apos;); // 2018 escaped 2018 MySQL 使用框架连接my sql数据库 官网 安装 1npm install mysql 使用 1234567891011121314151617181920var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', port : 3306 user : 'me', password : 'secret', database : 'my_db'&#125;);connection.connect();connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; // error: 是否有错误 // results: 查询的结果，数组。重要 // fields: 字段信息 if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;);connection.end(); 连接池 1234567891011121314151617181920//引入第三方mysql模块const mysql = require('mysql')//使用连接池的方式 建立连接const pool = mysql.createPool(&#123; host: '127.0.0.1', user: 'root', password: 'root', database: 'alishow', connectionLimit: 10&#125;)//抛出一个执行sql语句的方法module.exports.query = (sql, params, callback) =&gt; &#123; pool.getConnection((err, connection) =&gt; &#123; connection.query(sql, params, (err, results, feilds) =&gt; &#123; callback(err, results, feilds) &#125;) &#125;)&#125; youch node中的错误页面 官网 安装 1npm i youch 使用 12345//设置中间件 处理错误页面app.use((err, req, res, next) =&gt; &#123; const youch = new Youch(err, req) youch.toHTML().then(html =&gt; res.end(html))&#125;) morgan 打印、生成请求日志 官网 安装 1npm i morgan 使用 12345app.use(log('combined'))//orapp.use(log('dev')) cross-env 解决mac、windows环境变量的兼容 官网 安装 1npm install cross-env -g 运行 12根据环境变量 运行对应的node app.jsnpm run 环境变量名 npm run dev 模板引擎art-template 用于循环数据，动态生成网站 官网 安装 1npm install -g browser-sync 基本语法 1234567891011121314151617181920212223242526272829303132333435//导入 art-template const template = require('art-template');//语法： let html = template(绝对路径, 数据对象); let html = template(path.join(__dirname, 'views/xx.html'), &#123; title: '这是数据' &#125;); //输出数据：(在html中 插入占位符) &#123;&#123; title &#125;&#125; //条件输出： &#123;&#123;if value&#125;&#125; &lt;p&gt;&#123;&#123; value &#125;&#125;&lt;/p&gt; &#123;&#123;/if&#125;&#125;//循环输出： &#123;&#123;each items&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125; &#123;&#123;/each&#125;&#125; //数据别名(防止名称冲突)&#123;&#123;each category data i&#125;&#125; //在html页面中使用template(url(可以是*.html), &#123;key,value&#125;)&lt;% for(var i=1 ; i&lt;=10 ; i++)&#123; %&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&#123;&#123;i&#125;&#125;&lt;/a&gt;&lt;/li&gt;&lt;% &#125; %&gt; //html字符串 转义符：# or @ 模板继承1234567891011//其他页面引入模板 &#123;&#123; extend './_layout/layout.html' &#125;&#125; //模板页面中挖坑： &#123;&#123; block 'content' &#125;&#125;&#123;&#123; /block &#125;&#125; //其他页面填充父模板的坑: &#123;&#123; block 'content' &#125;&#125; //.....填充的内容 &#123;&#123; /block &#125;&#125; 在模板页中引用子模板1&#123;&#123;include '../includes/navbar.html'&#125;&#125; 过滤器12345const template = require('art-template');// 给 art-template 设置过滤器template.defaults.imports.dateFormat = function(date, format)&#123; return moment(date).format(format); //利用moment处理日期数据 并返回&#125;; html页面使用1234567891011121314151617//在页面中 引入模板引擎 .js文件后 写入&lt;script&gt; &lt;script type=\"text/html\" id=\"javaaa\"&gt; &#123;&#123; each msg&#125;&#125; &lt;li&gt; &lt;img src=\"&#123;&#123; $value.img &#125;&#125;\" alt=\"\"&gt; &lt;span class=\"name\"&gt;&#123;&#123; $value.uName &#125;&#125; 说：&lt;/span&gt; &lt;span&gt;&#123;&#123; $value.content &#125;&#125;&lt;/span&gt; &lt;/li&gt; &#123;&#123; /each &#125;&#125; &lt;/script&gt; //获取服务器返回的json数据、解析后给模板引擎赋值、然后生成页面解构 var aaa = JSON.parse(this.responseText) let a = template('javaaa', &#123;msg: aaa&#125;) $('ul').html(a) 修改语法界定符 若与服务器的模板引擎发送冲突，则需要进行配置 1234567&lt;script&gt;template.defaults.rules[1].test = /&#123;-([@#]?)[ \\t]*(\\/?)([\\w\\W]*?)[ \\t]*-&#125;/;&lt;/script&gt;// 原始语法的界定符规则template.defaults.rules[0].test = /&lt;!(#?)((?:==|=#|[=-])?)[ \\t]*([\\w\\W]*?)[ \\t]*(-?)!&gt;/; 传递变量12345//变量声明template.defaults.imports.log = console.log;//导入变量&lt;%= $imports.log('hello world') %&gt; 其他模板引擎 12- jade- ejs express-art-template 与Express框架配合使用（基于art-template，其作用为 简化代码） 官网 安装 1npm install art-template express-art-template 配置 123456// 默认模板都放在views文件夹中// 设置html文件为模板app.set('view engine', 'html');// 设置模板交给谁去处理app.engine('html', require('express-art-template')); 使用示例 12345678app.get('/', function (req, res) &#123; // render 方法默认会去项目的 views 目录中查找 index.html 文件 // render 方法的本质就是将读取文件和模板引擎渲染这件事儿给封装起来了 // 默认模板都是html文件，这里的.html可以省略 res.render('index.html', &#123; title: 'hello world' &#125;)&#125;) 如果希望修改默认的 views 视图渲染存储目录，可以： 123// 第一个参数 views 是一个特定标识，不能乱写// 第二个参数给定一个目录路径作为默认的视图查找目录app.set('views', 目录路径) #### web开发框架Express 可以设置中间件来响应 HTTP 请求。定义了路由表用于执行不同的 HTTP 请求动作。可以通过向模板传递参数来动态渲染 HTML页面 官网、中文官网、Github 安装 1npm install express 使用 123456789101112const express = require('express')// 调用 express() 得到一个 app 类似于 http.createServer()const app = express()// 设置请求对应的处理函数 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get('/', (req, res) =&gt; &#123; res.send('hello world')&#125;)// 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log('app listening on port 3000!')) 路由 参考文档 路由（Routing）是由一个 URL（或者叫路径标识）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何处理响应客户端请求。 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行。 路由的定义的结构如下： 12345app.METHOD(PATH, HANDLER)//前缀可选app.use('前缀','路由') 其中： app 是 express 实例 METHOD 是一个 HTTP 请求方法 PATH 是服务端路径（定位标识） HANDLER 是当路由匹配到时需要执行的处理函数 下面是一些基本示例。 处理 get 请求 1234// 当你以 GET 方法请求 / 的时候，执行对应的处理函数app.get('/', function (req, res) &#123; res.send('Hello World!')&#125;) 处理 post 请求 1234// 当你以 POST 方法请求 / 的时候，指定对应的处理函数app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125;) 路由的参考文档 routing guide. 设置路由 123456789//在路由配置上面设置const router = module.exports = express.Router();//等同于以下方法const router = express.Router()//路由内容 例处理get、post请求module.exports = router 多路由文件处理 下载、使用glob模块 12345678const glob = require('glob')glob('./routers/**/*.js', function (er, files) &#123; files.forEach((item, index) =&gt; &#123; let routers = path.join(__dirname, item) app.use(require(routers)) &#125;)&#125;) 处理静态资源参考文档 12345//普通处理方式app.use(express.static('public'))//带前缀的静态资源app.use('/public', express.static(path.join(__dirname, './public'))) 注：css/images等文件夹不能直接被处理，需要同意放在一个公共的文件夹中(例 public) 解析 post 请求体 express 已经内置 body-parser express 通过 express.urlencoded 方法包装了 body-parser 新版的Express 已经内置了！！ 配置+使用 123456789101112//配置app.use(express.urlencoded())//orapp.use(express.json())app.use(express.urlencoded(&#123;extended: false&#125;))//使用*.body //例 req.body body-parser - 独立模块 参考文档： GitHub - body-parser 在 Express 中没有内置获取表单 POST 请求体的 API 这里我们需要使用一个第三方包：body-parser 安装： 1npm install body-parser 配置： 123456789var bodyParser = require('body-parser')// 配置 body-parser// 只要加入这个配置，则在 req 请求对象上会多出来一个属性：body// 也就是说你就可以直接通过 req.body 来获取表单 POST 请求体数据了// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()); 使用： 1234// 可以通过 req.body 来获取表单 POST 请求体数据app.post('/publish', (req, res) =&gt; &#123; res.send(req.body);&#125;); 302跳转 123// express中新增了一个redirect ，设置状态码 302 ，并设置响应头 locationres.redirect('/admin'); 中间件 中间件是 Express 的最大特色，也是最重要的一个设计 一个 Express 应用，就是由许许多多的中间件来完成的 中间件函数是能够访问请求对象、响应对象，以及应用程序的请求/响应循环中的下一个中间件函数 中间件函数可以执行以下任何任务 执行任何代码 修改 request 或者 response 响应对象 结束请求响应周期 调用下一个中间件 return next 后 程序会去找挂在路由的js文件 去执行写了4个形参的函数，并去执行 12345678910111213141516171819202122232425262728//利用中间件 处理404 500页面app.use((err, req, res, next) =&gt; &#123; res.status(404) res.send('404 页面')&#125;)app.use((err, req, res, next)=&gt;&#123; res.status(500) res.send('500 页面')&#125;)// 四个参数，缺一不可// 这里配置好以后，接下来你就可以在其他的路由处理函数中，遇到错误的使用，调用 next(传入错误对象)// 那么，这个带有四个参数的中间件就会被调用// 该中间件的第一个参数就是你 next(错误对象) 调用所传递的那个错误对象app.use((err, req, res, next) =&gt; &#123; // 简单一点，在网站系统中增加一个异常管理功能 // 数据表，异常表 // 报错时间，报错文件，具体的报错信息，哪个路由，哪个方法.... // 发送邮件或短信给开发人员，给管理员 res.status(500).send(&#123; statusCode: 500, message: 'Internal Server Error', error: err.message &#125;)&#125;) cookie处理 配置cookie的key、value 需要安装cookie-parser 官网 安装 1npm install cookie-parser 使用 12345678910111213141516171819202122232425var express = require('express')var cookieParser = require('cookie-parser')var app = express()app.use(cookieParser())//--------------------------------var express = require('express')var cookieParser = require('cookie-parser')var app = express()app.use(cookieParser())app.get('/', function (req, res) &#123; // Cookies that have not been signed console.log('Cookies: ', req.cookies) // Cookies that have been signed console.log('Signed Cookies: ', req.signedCookies)&#125;)app.listen(8080) 存cookie数据 1234567891011//取cookie数据//cookies是对象let cookie = req.cookies[key]//存储cookiereq.cookie(key,value) //value 是json字符串req.cookie(&#123;key,value&#125;，&#123;过期时间,v&#125;,&#123;???&#125;) //value 是json字符串res.cookie(config.cookie.key, JSON.stringify(cookieJson),&#123;expires&#125;) //删除cookiereq.clearCookie(key) 其他参数 1expires:过期时间 JS下的cookie操作 1document.cookie = session处理 需要安装第三方框架：express-session 官网 安装 1npm i express-session 配置 12345678const session = require('express-session');app.use(session(&#123; secret: 'keyboard cat', cookie: &#123; maxAge: 60*1000 &#125;, //cookie过期时间 resave: false, saveUninitialized: true, //!!配合express-mysql-session 使用&#125;)); name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。 secret: 这个 string 对 sessionID 对应的cookie进行签名，并放在 cookie 中。 cookie: 设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: ‘/’, httpOnly: true, maxAge: null }) resave: 强制session保存到session store中。即使在请求中这个session没有被修改。 saveUninitialized: 强制没有“初始化”的session保存到storage中，没有初始化的session指的是：刚被创建没有被修改（第一次请求是否生成 sessionid） 简单使用 1234567891011121314// req.session 是一个对象// 当配置好 session 之后，可以使用 session 保持登录的状态req.session.isLogin = user;// 在其他\"路由\"，可以判断登录的状态if (!req.session.isLogin) &#123; // 如果状态不存在则没有登录，跳转到首页 return res.redirect('/')&#125;// 退出的时候要，销毁sessionreq.session.destroy() 中间件方式 123456789101112131415161718192021//在程序入口（app.js）中设置一个中间件，用于判断用户是否已经登陆//用户若访问/admin下的页面，则会经过这个中间件 需要在路由之前注册中间件app.use('/admin', (req, res, next) =&gt; &#123; //获取当前访问的url ( req.originalUrl ) const url = req.originalUrl if (url === '/admin/login') &#123; // 调用 next 会往后找与当前请求匹配的路由处理函数 return next() &#125; // 校验登录状态 session const sessionUser = req.session.isLogin // 若没有登录，则让用户跳转到登录页 if (!sessionUser) &#123; return res.redirect('/admin/login') &#125; next()&#125;) express-mysql-session 用于session永久化，该模块会在数据库中创建一个session表 官网 安装 1npm install express-mysql-session 使用 123456789101112131415161718192021222324var express = require('express');var app = module.exports = express();//----------------------------------------var session = require('express-session');var MySQLStore = require('express-mysql-session')(session);var options = &#123; host: '127.0.0.1', port: 3306, user: 'root', password: 'root', database: 'session_test'&#125;;app.use(session(&#123; key: 'session_cookie_name', //cookie key名称 secret: 'session_cookie_secret', //算法私钥，可以理解为 随便设置 store: sessionStore, //告诉 express-session，要用sessionStore持久化session resave: false, //重新保存 session有效期 saveUninitialized: false //什么时候初始化 用session的时候 才初始化&#125;)); 注意 若使用session永久化，需要在配置express-session之前进行配置 multer 处理用户上传文件 官网 若用户上传文件，则req.body，需要使用新的模块 下载 1npm install multer 使用 12345678910111213141516171819202122232425262728293031//用于处理用户上传文件的中间件const path = require('path')const multer = require('multer')//配置multerlet storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, 'public/uploads/') &#125;, filename: function (req, file, cb) &#123; let ext = path.extname(file.originalname) cb(null, file.fieldname + '-' + Date.now() + ext) &#125;&#125;)let upload = multer(&#123; storage: storage&#125;)module.exports = upload//------------------------------------------------------------------//这里的upload.single('article_file') 必须与提交的name字段名一致router.post('/api/posts/add', upload.single('article_file'), (req, res, next) =&gt; &#123; //通过解构的方式获得input内容 + 上传文件 let &#123;body , file&#125; = req //file存储的图片相关信息&#125;)//以上是一个路由，用来处理用户上传文件 (upload.single('article_file')) html页面里的ajax请求 12345678910111213141516171819202122232425&lt;script&gt; //文章上传功能 $('#save').on('click', function () &#123; // var body = $('#add_form').serialize() var from = $('#add_form') var data = new FormData(from.get(0)) $.ajax(&#123; url: \"/api/posts/add\", type: \"POST\", data: data, processData: false, // 不处理数据 contentType: false, // 不设置内容类型 error: function (err) &#123; console.log(err) &#125;, success: function (results) &#123; console.log(results) &#125; &#125;); return false &#125;)&lt;/script&gt; http-errors 为express，处理http 404、500等错误 官网 安装 1npm install http-errors 使用 1234567891011121314var createError = require('http-errors')var express = require('express')var app = express()app.use(function (req, res, next) &#123; if (!req.user) return next(createError(401, 'Please login to view this page.'))&#125;)//orapp.use((req,res,next)=&gt;&#123; return next(createError(404, 'Not Found'))&#125;) svg-captcha 验证码 官网 安装 1npm install svg-captcha 使用 12345var svgCaptcha = require('svg-captcha'); var captcha = svgCaptcha.create();console.log(captcha);// &#123;data: '&lt;svg.../svg&gt;', text: 'abcd'&#125; 其他常用12345678910111213141516171819//url重定向(跳转页面)res.redirect（[status，] path）res.redirect('http://example.com');//获取用户访问的url GET 'http://www.example.com/admin/new'console.log(req.originalUrl); // '/admin/new'console.log(req.baseUrl); // '/admin'console.log(req.path); // '/new'//locals对象 设置后可以模板中使用该变量app.locals.abc = 123123 //全局中的变量 放内存中 //模板引擎中 → &#123;&#123; abc &#125;&#125; res.locals.category //响应体中的变量req.app.locals.category //请求体中的变量 //express app 中存变量，通常用于缓存res.locals.statusCode = err.status == 404 ? 404 : 500 //将错误状态吗存入全局对象中//在art-template的.html中使用 &#123;&#123;statusCode&#125;&#125;res.status(err.status || 500) //返回404或者500状态码 md5加密 使用node内置crypto模块进行数据加密 12345678910//引入crypto模块const crypto = require('crypto');//将加密方法 导出，外部require引用时 需要传入加密字符串module.exports.crypto_hash = (str) =&gt; &#123; const hash = crypto.createHash('md5') hash.update(str) return hash.digest('hex')&#125; 配合vue 路由模式？123app.get('*', function (request, response)&#123; response.sendFile(path.resolve(__dirname, 'build', 'index.html'))&#125;) HTTP协议 HTTP 协议是无状态的，服务端不能跟踪客户端的状态，也就无法记录客户端登录的状态。 Cookie什么是 Cookie Cookie - 小甜点，属于 HTTP 协议的一部分 是服务器发送到用户浏览器并保存在本地的一小块数据 在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上 它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态 Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能 Cookie 存储的数据量有限，由浏览器决定，一般在4KB左右 Cookie 的使用场景 Cookie 主要用来分辨两个请求是否来自同一个浏览器，以及用来保存一些状态信息。它的常用场合有以下一些。 对话（session）管理：保存登录、购物车等需要记录的信息。 个性化：保存用户的偏好，比如网页的字体大小、背景色等等。 追踪：记录和分析用户行为。 Cookie 的属性 Cookie 的访问被限制，只能在当前域名下可以访问。(不能跨域访问)。 Path Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。 HttpOnly 设置该属性的话，不允许客户端操作 Cookie Expires 设置过期时间，具体的时间点 Max-Age 设置过期时间，时间段，隔多长时间过期，单位是秒 (例如：60*60 1小时) 如果同时设置 Max-Age 和 Expires，Max-Age优先 如果没有设置 Expires 和 Max-Age，浏览器关闭 Cookie 就消失 (只存储在内存中) 123456res.cookie('name', 'zs', &#123; httpOnly: true, path: '/', // 此处的单位是 毫秒 maxAge: 60 * 60 * 24 * 1000&#125;); Cookie 与 HTTP 协议 Cookie 由 HTTP 协议生成，也主要是供 HTTP 协议使用。 HTTP 响应：Cookie 的生成 服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。 1Set-Cookie:foo=bar 上面代码会在浏览器保存一个名为foo的 Cookie，它的值为bar。 HTTP 回应可以包含多个Set-Cookie字段，即在浏览器生成多个 Cookie。下面是一个例子。 1234HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=choco; HttpOnlySet-Cookie: tasty_cookie=strawberry; HttpOnly 下面是一个例子。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly HTTP 请求：Cookie 的发送 浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。也就是说，把服务器早前保存在浏览器的这段信息，再发回服务器。这时要使用 HTTP 头信息的Cookie字段。 1Cookie: foo=bar 上面代码会向服务器发送名为foo的 Cookie，值为bar。 Cookie字段可以包含多个 Cookie，使用分号（;）分隔。 1Cookie: name=value; name2=value2; name3=value3 下面是一个例子。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry 在浏览器中操作 Cookie document.cookie document.cookie属性用于读写当前网页的 Cookie。 读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有HTTPOnly属性。 1document.cookie // &quot;foo=bar;baz=bar&quot; document.cookie属性是可写的，可以通过它为当前网站添加 Cookie。 1document.cookie = &apos;fontSize=14&apos;; 注意：document.cookie一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。 s-cookie https://github.com/js-cookie/js-cookie Session会话保持的机制，session 是记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 session 保存在服务器上。 session 的使用 第三方模块 express-session 配置 12345678const session = require('express-session');app.use(session(&#123; secret: 'keyboard cat', cookie: &#123; maxAge: 60*60*24*1000 &#125;, resave: false, saveUninitialized: true,&#125;)); name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。 secret: 这个 string 对 sessionID 对应的cookie进行签名，并放在 cookie 中。 cookie: 设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: ‘/’, httpOnly: true, maxAge: null }) resave: 强制session保存到session store中。即使在请求中这个session没有被修改。 saveUninitialized: 强制没有“初始化”的session保存到storage中，没有初始化的session指的是：刚被创建没有被修改（第一次请求是否生成 sessionid） 使用 1234567891011// req.session 是一个对象// 当配置好 session 之后，可以使用 session 保持登录的状态req.session.user = user;// 在其他路由，可以判断登录的状态if (!req.session.user) &#123; // 如果状态不存在则没有登录&#125;// 退出的时候要，销毁sessionreq.session.destroy() session的原理 浏览器向服务器发送登录请求(post)，携带账号和密码 服务器返回的响应头中携带 服务器生成的 sessionid(cookie中)，身份标示 浏览器再次访问服务器的时候会通过cookie携带sessionid 服务器获取浏览器发送的sessionid后，在服务器查找sessionid，如果找不到，未登录 如果找到 sessionid，根据 sessionid 查找对应的对象，如果不存在，未登录 Cookie 和 Session 的区别 cookie 数据存放在客户端，session 数据放在服务器端。 cookie 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用session。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 cookie 。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 将登陆信息等重要信息存放为 session、其他信息如果需要保留，可以放在cookie中 参考资料 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies","categories":[{"name":"Node.js","slug":"Node-js","permalink":"/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"}]},{"title":"React - 基础","slug":"React - 基础","date":"2019-05-09T03:26:31.116Z","updated":"2019-05-09T03:15:01.230Z","comments":true,"path":"2019/05/09/React - 基础/","link":"","permalink":"/2019/05/09/React - 基础/","excerpt":"","text":"React框架个人感觉 违背W3C等规范，将JS、HTML等语言混在一起使用 在JS的基础上进行扩展，又不符合常规语法，容易混淆，难以理解 一次编写 到处运行是个亮点，内部算法也许比Vue强 特性 声明式视图 对于声明式组件，当数据变更的时候，React低层负责高效更新。这种方式代码更加可预见并且更容易调试。 组件化 封装管理数据的组件，通过组合的方式实现复杂的UI，组件的逻辑采用js实现而不是模板，这样可以保持数据在DOM之外。 一次学习，随处编写 React可以进行服务端渲染，也可以用于移动APP开发（React Native） 中文官网 英文官网 前端3大框架： 框架 时间 作者 概述 Vue 2012 尤雨溪 只关注视图层的开发 React 2010 facebook 一切都是javascript、包括html、css angular 2009 google TypeScript、被边缘化 Vue与React的区别 MVC、MVVM MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分： Model：（数据层）主要负责 数据库的操作； View：（视图层）所有前端页面，统称为 View 层 Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点） MVVM是前端页面的分层开发思想，主要关注于 视图层 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View, ViewModel Model 是 页面中，需要用到的数据 View 是页面中的HTML结构； ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念； 其他框架 Ember Knockout Polymer Riot 基本用法注：代码中含有为基础用法 后续会采用npm的方式安装React，并在js里写组件 12345678910111213141516171819&lt;body&gt; &lt;script src=\"./js/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/babel.min.js\"&gt;&lt;/script&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root') ); &lt;/script&gt;&lt;/body&gt;//ornpm 下载 JSX(js扩展语法) 本质：普通对象 JSX中嵌入表达式（JSX本身也是表达式） JSX可以赋值给变量 作为函数的参数 作为函数的返回值 常规用法123456789101112131415161718const info = &lt;div&gt;Hello World!&lt;/div&gt;;//可以html标签嵌套，但是需要包含一个根标签！！const element = (&lt;div&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/div&gt;);//()可以不加~ 建议加上。。//作为函数的返回值function foo() &#123; return ( &lt;div tabIndex=\"0\" className='active'&gt;Tom&lt;/div&gt; );&#125;//作为函数的参数function foo(info) &#123; return info;&#125;let ret = foo(&lt;div&gt;hi&lt;/div&gt;); 原理 1234567891011121314151617181920212223// 函数原型React.createElement(element, [props], [...children])// ------------------------------------------------const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// 上述JSX本质上可以表示为如下形式：const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!');// let info = &lt;div&gt;你好&lt;/div&gt;;// let info = React.createElement('h1', &#123;className: 'active'&#125;, 'Nihao');let c1 = React.createElement('h1', &#123;className: 'active1'&#125;, 'Nihao');let c2 = React.createElement('h2', &#123;className: 'active2'&#125;, 'Hello');let info = React.createElement('div', &#123;className: 'active'&#125;, [c1, c2]);ReactDOM.render(info, document.getElementById('root')); props属性操作 可使用es6等语法，通过多种方式传递数据/属性 扩展运算符：传递多个数据 12345678910111213141516171819//使用 ... 完成数据 解构？ 传递数据&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.name&#125; | &#123;this.props.age&#125; | &#123;this.props.sex&#125; &lt;/div&gt; ) &#125; &#125; let obj = &#123;name:'zs',age:18,sex:'男'&#125; let App = ( &lt;div&gt;&lt;Com &#123;...obj&#125; /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 解构：传递指定数据 1234567891011121314151617181920// 使用 ... 将name值“拆出来”，这时传递到组件中 就只有age、sex 了&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.name&#125; | &#123;this.props.age&#125; | &#123;this.props.sex&#125; &lt;/div&gt; ) &#125; &#125; let obj = &#123;name:'zs',age:18,sex:'男'&#125; let &#123;name,...other&#125; = obj let App = ( &lt;div&gt;&lt;Com &#123;...other&#125; /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; props值类型 组件传递数据时，可传递表达式、函数、对象等类型。并可以在组件中调用、更改值 但是开发环境中不建议修改props中的值 1234567891011121314151617&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.num&#125; | &#123;this.props.obj.name&#125; | &#123;this.props.fn()&#125; &lt;/div&gt; ) &#125; &#125; let myObj = &#123;name:1&#125; let App = ( &lt;div&gt;&lt;Com num=&#123;1+2+3&#125; obj=&#123;myObj&#125; fn=&#123;()=&gt;&#123;console.log(123)&#125;&#125; /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; children 原理类似Vue中的 slot（插槽） 在React中，可通过 this.props.children 获取组件标签中的内容/html结构 1234567891011121314&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com&gt;hello world&lt;/Com&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 点标记组件 可通过对象的方式 包装 多个子组件，通常代表子组件功能相互关联 12345678910111213141516&lt;script type=\"text/babel\"&gt; let abc = &#123; a:class extends React.Component&#123; render()&#123; return (&lt;div&gt;&lt;h1&gt;A&lt;/h1&gt;&lt;/div&gt;) &#125; &#125;, b:class extends React.Component&#123; render()&#123; return (&lt;div&gt;&lt;h1&gt;B&lt;/h1&gt;&lt;/div&gt;) &#125; &#125; &#125; let App = ( &lt;div&gt;&lt;abc.a /&gt;&lt;abc.b /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 高阶组件笔记未总结 组件化 重复利用的单元，形式与vue类似，实现原理不同 高内聚,低耦合 React的组件推荐写在js中，这里先写在html里，方便学习 定义组件的方式（2种） 12345678910111213//函数组件function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;//类组件class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;//定义class并继承React.component，并return组件结构 类组件的传参 - 固定写法，包括 “props” 12345678910111213141516171819202122&lt;script type=\"text/babel\"&gt; class Con extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;h1&gt;你好&#123;this.props.info&#125;&lt;/h1&gt;; &#125; &#125; let app = &lt;Con info=\"World\"&gt;a&lt;/Con&gt;; ReactDOM.render(app, document.getElementById(\"root\"));&lt;/script&gt;// ----------说明----------// class Con 继承(extends) React.Component// 采用constructor 接收参数(props) （固定写法） //这个+内部的super可以省略不写! // 使用super(props) super代表调用父类构造函数（这里指React） 在这里接收了参数props// Con中 写了一个render()方法 并将html结构return// 外部可以使用&lt;Con&gt;&lt;/Con&gt;// Con中的this指向 与 普通构造函数的指向（示例）一致// Con通过原型链 可以找到父类中的props 数据 组件状态-state（单向数据流） 组件可通过this.state={} 设置内部数据 ！class组件存在state，函数组件不存在 数据特性为单向：父组件数据传递给子组件 123456789101112131415161718&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class Com1 extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; msg:'hello world' &#125; &#125; render()&#123; return( &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; ) &#125; &#125; let App = (&lt;Com1&gt;&lt;/Com1&gt;) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; state中数据修改 123456// 若要设置state的值，则需要使用：this.setState(&#123;&#125;)// 若不使用该方法，React则无法监测到数据变化 而改变DOMthis.setState(&#123; msg:new Date().toString()&#125;) setState的数据修改异步问题 12345678910111213141516//setState是异步执行，所以这里console打印出的是旧数据clk=()=&gt;&#123; this.setState(&#123; num:this.state.num + 1 &#125;) console.log(this.state.num);&#125;//setState有一个回调函数，这里打印出的是数据更新后的值clk=()=&gt;&#123; this.setState(&#123; num:this.state.num + 1 &#125;,()=&gt;&#123; console.log(this.state.num); &#125;)&#125; 组件间数据传值父 → 子 父组件向子组件传值(props) 子组件 通过”标签属性”向父组件传值 父组件class中的props中就会包含子组件传输的数据（格式：子组件属性:数据） 在父组件中可通过 this.props.属性获取子组件传送的数据 1234567891011121314151617181920212223242526272829303132333435363738&lt;script type=\"text/babel\"&gt; class Father extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; msg:'Father组件data' &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;father&lt;/h1&gt; &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &lt;Son msg=&#123;this.state.msg&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ) &#125; &#125; class Son extends React.Component &#123; constructor(props) &#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;son&lt;/h1&gt; &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt; &lt;Father msg='根组件data'&gt;&lt;/Father&gt; &lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 子 → 父 子组件向父组件传值(传递函数) 在父组件class中 render子组件 通过子组件标签属性传递一个函数sum 在子组件class中解构、运行该函数 sonnum() // 示例代码是通过事件触发解构、运行、传值 总结：通过父组件向子组件传递“函数” 并在子组件解构 + 运行 + 传递参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script type=\"text/babel\"&gt; class Son extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; num: 0 &#125; &#125; clk=()=&gt;&#123; let &#123;sonnum&#125; = this.props sonnum(1) this.setState(&#123; num:this.state.num + 1 &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.clk&#125;&gt;点击&lt;/button&gt; &lt;span&gt;&#123;this.state.num&#125;&lt;/span&gt; &lt;/div&gt; ) &#125; &#125; class Father extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; total:0 &#125; &#125; sum=(n)=&gt;&#123; this.setState(&#123; total:this.state.total + n &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.total&#125;&lt;/h1&gt; &lt;Son sonnum=&#123;this.sum&#125;&gt;&lt;/Son&gt; &lt;Son sonnum=&#123;this.sum&#125;&gt;&lt;/Son&gt; &lt;Son sonnum=&#123;this.sum&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt; &lt;Father&gt;&lt;/Father&gt; &lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 兄弟 → 兄弟 非父子组件之间传值(redux) 生命周期 组件从产生 → 销毁的过程 （重要的加粗） （即将移除）componentWillMount：唯一在render()之前调用的钩子 componentDidMount： DOM树渲染完成后调用，通常用于加载后台数据 （即将移除）componentWillReceiveProps：组件接收到新的props，该方法会首先被调用 （新增）static getDerivedStateFromProps(props, state)：state、props改变后，都会执行钩子 componentWillUnmount：组件被销毁之前一般用于清理工作（定时器timer、网络请求、订阅事件） 其他生命周期钩子参考 使用示例： componentDidMount(){} 123456789101112render()&#123; return( &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; )&#125;componentDidMount()&#123; setInterval(() =&gt; &#123; this.setState(&#123; msg:new Date().toString() &#125;) &#125;, 1000);&#125; 事件相关事件绑定 通过button标签中的 onClick={this.clk} 绑定点击事件clk 123456789101112131415161718192021222324252627&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; num:0 &#125; &#125; clk=()=&gt;&#123; this.setState(&#123; num:this.state.num + 1 &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.state.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.clk&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;Com&gt;&lt;/Com&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 事件传参 若需要传递参数则需要在onClick中传递一个 “参数” 函数！！ —–错误写法：onClick={ this.clk(2) } 等同于函数调用，会返回字符串。而这里需要一个函数 可以通过 onClick={ (e)=&gt;{this.clk(e,2)} } //第一个参数为 事件对象 可以通过 onClick={ this.clk.bind( this,2 ) } //采用bind的特性（返回一个函数） —–改变this只是原生js语法规定的，这里没有什么用 （不太确定） 12345678910111213141516171819202122232425262728&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; num:0 &#125; &#125; clk=(e,n)=&gt;&#123; console.log(e); this.setState(&#123; num:this.state.num + n &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.state.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.clk(e,2)&#125;&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;Com&gt;&lt;/Com&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 阻止默认行为123456789clk=(e,n)=&gt;&#123; e.stopPropagation() // 阻止冒泡 e.preventDefault() // 阻止默认行为 return false // 不好使 this.setState(&#123; num:this.state.num + n &#125;)&#125; 补充 1234//clk方法写成了箭头函数，其原因为this指向问题//另一种解决方法是： (改变this指向)this.clk = this.clk.bind(this); 条件渲染 通过判断语句，甄别渲染组件/标签/内容 if else 在render函数中 通过if判断 要reruen什么html结构 123456789101112131415161718&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; show:false &#125; &#125; render()&#123; if(this.state.show)&#123; return( &lt;h1&gt;hello&lt;/h1&gt; ) &#125; else&#123; return (&lt;h1&gt;world&lt;/h1&gt;) &#125; &#125; &#125; let App = ( &lt;div&gt;&lt;Com&gt;&lt;/Com&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 三元表达式 return时 可通过三元表达式来判断是否要渲染 123456789101112131415161718192021&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; show:false &#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.state.show ? &lt;h1&gt;hello&lt;/h1&gt; : &lt;h1&gt;world&lt;/h1&gt; &#125; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt;&lt;Com&gt;&lt;/Com&gt;&lt;/div&gt;)ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 阻止渲染 1// 在function中return null / 在class render中 return null 遍历渲染 通过原生数组map()方法循环遍历 生成html结构，然后使用{html}渲染 遍历出的html必须包含唯一的key，便于React监控DOM树 1234567891011121314151617181920&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; ary:[1,2,3,4,5] &#125; &#125; render()&#123; let lis = this.state.ary.map((item,index)=&gt;&#123;return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;) return ( &lt;div&gt; &lt;ul&gt;&#123;lis&#125;&lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 表单处理 受控组件：表单域的基本使用；通过标签中的value绑定数据 + onChange “实时”监控表单状态双向数据绑定 非受控组件：直接通过DOM获取value 也可绑定state中数据 区别： 需要设置原始值，或实时监控组件内容时 使用受控组件，反之非受控组件 表单中 若存在“value”，则通常为受控组件 受控组件 通过html表单域中的value 绑定state的值 通过给表单绑定onChange方法 更新state中的值 —-在onChange(e){}方法中，第一个参数为事件对象，通过e.target.vale可获取值 1234567891011121314151617181920212223242526&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; uname:'' &#125; &#125; inputChange=(e)=&gt;&#123; let val = e.target.value this.setState(&#123; uname:val &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.uname&#125; onChange=&#123;this.inputChange&#125;/&gt; &lt;p&gt;state的值：&#123;this.state.uname&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 非受控组件 通过html标签中的ref值 与class组件声明的ref 的进行绑定 通过 this.ref.current.value 获取对应html表单的值 1234567891011121314151617181920212223242526272829&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; uname:'' &#125; this.uNameRef = React.createRef() &#125; inputPush=()=&gt;&#123; let val = this.uNameRef.current.value this.setState(&#123; uname:val &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;input的值不会实时绑定到state中&lt;/p&gt; &lt;input type=\"text\" ref=&#123;this.uNameRef&#125; /&gt; &lt;button onClick=&#123;this.inputPush&#125;&gt;提交&lt;/button&gt; &lt;p&gt;提交后state：&#123;this.state.uname&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 常规表单处理radio：通过受控组件 监控 选中情况，并根据绑定的value值 来决定checked 1234567891011121314151617181920212223242526&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; sex:'man' &#125; &#125; iChange=(e)=&gt;&#123; this.setState(&#123; sex:e.target.value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"radio\" name=\"sex\" value=\"man\" checked=&#123;this.state.sex=='man'&#125; onChange=&#123;this.iChange&#125; /&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"women\" checked=&#123;this.state.sex=='women'&#125; onChange=&#123;this.iChange&#125; /&gt;女 &lt;p&gt;radio数据：&#123;this.state.sex&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; checkbox：通过onChange事件监控点击事件，使用临时array、遍历的方法判断点击次数，判断是否“选中” 123456789101112131415161718192021222324252627282930313233&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; checkboxDate:[] &#125; &#125; isChecked=(e)=&gt;&#123; let val = e.target.value let ary = this.state.checkboxDate.slice() //截取(0)生成新数组，避免相同引用地址 let index = ary.findIndex(item=&gt;item==val) //循环遍历出索引index if(index == -1) &#123; ary.push(val) &#125; //判断数组中是否存在 else &#123; ary.splice(index,1) &#125; this.setState(&#123; checkboxDate:ary &#125;,()=&gt;&#123;console.log(this.state.checkboxDate);&#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"checkbox\" name=\"like\" value=\"read\" onChange=&#123;this.isChecked&#125; /&gt;看书 &lt;input type=\"checkbox\" name=\"like\" value=\"game\" onChange=&#123;this.isChecked&#125; /&gt;游戏 &lt;input type=\"checkbox\" name=\"like\" value=\"music\" onChange=&#123;this.isChecked&#125; /&gt;音乐 &lt;p&gt;checkbox绑定的值：&#123;this.state.checkboxDate&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; select + option：通过受控组件 监控 选中情况，并更新state中的值 1234567891011121314151617181920212223242526272829&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; val:1 &#125; &#125; iChange=(e)=&gt;&#123; this.setState(&#123; val:e.target.value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;select value=&#123;this.state.val&#125; onChange=&#123;this.iChange&#125;&gt; &lt;option value='1'&gt;工作&lt;/option&gt; &lt;option value='2'&gt;学习&lt;/option&gt; &lt;option value='3'&gt;看书&lt;/option&gt; &lt;/select&gt; &lt;p&gt;option绑定的value值：&#123;this.state.val&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; file：通过非受控组件 ，当点击按钮后 读取 文件上传情况，并更新state中的值 1234567891011121314151617181920212223242526272829303132&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; name:'', size:'', type:'' &#125; this.fileRef = React.createRef() &#125; filePush=()=&gt;&#123; console.log(); this.setState(&#123; name:this.fileRef.current.files[0].name, size:this.fileRef.current.files[0].size, type:this.fileRef.current.files[0].type &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"file\" ref=&#123;this.fileRef&#125; /&gt; &lt;button onClick=&#123;this.filePush&#125;&gt;提交&lt;/button&gt; &lt;p&gt;file绑定的值：&#123;this.state.name&#125;----&#123;this.state.size&#125;----&#123;this.state.type&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; textarea：通过受控组件 监控 输入内容，并更新state中的值 12345678910111213141516171819202122232425&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; val:'' &#125; &#125; iChange=(e)=&gt;&#123; this.setState(&#123; val:e.target.value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;textarea value=&#123;this.state.val&#125; onChange=&#123;this.iChange&#125;&gt;&lt;/textarea&gt; &lt;p&gt;textarea绑定的value值：&#123;this.state.val&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; CSS样式处理className 1234567891011121314151617181920212223242526// React中class是关键词，所以使用className// 可通过常规写法进行绑定样式，也可通过绑定 state 中数据来控制// 在className中 也可以使用表达式&lt;style&gt;.box&#123;color: red;&#125;.box2&#123;color: blue&#125;.fs&#123;font-size: 16px;&#125;&lt;/style&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; abc:true &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;div&gt;&lt;h1 className='box fs'&gt;hello&lt;/h1&gt;&lt;/div&gt; &lt;div&gt;&lt;h1 className=&#123;this.state.abc?'box2 fs':'box fs'&#125;&gt;world&lt;/h1&gt;&lt;/div&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; style 1234567891011121314151617181920212223// 通过html标签绑定 state 中的对象来控制行内样式// 或者 在html标签中采用 &#123;&#123;key:value,key:value&#125;&#125; 控制样式（不推荐）&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; abc:&#123;'fontSize':'36px',color:'blue'&#125; &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h1 style=&#123;&#123;color:'red','fontSize':'16px'&#125;&#125;&gt;hello&lt;/h1&gt; &lt;h1 style=&#123;this.state.abc&#125;&gt;world&lt;/h1&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; yarn(类似npm) 类似npm的包管理网站 官网 安装 12//在官网中找到对应的安装文件，安装//在cmd中输入 yarn --version 查看是否安装成功 基础命令 1234567891011121314151617181920212223242526//与npm对比// 初始化新项目npm inityarn init// 默认安装npm installyarn install// 安装某个依赖，并且默认保存到package.npm install express —saveyarn add express// 移除某个依赖项目npm uninstall express —saveyarn remove express// 安装某个开发时依赖项目npm install express —save-dev yarn add express —dev// 更新某个依赖项目npm update express —save yarn upgrade express// 安装某个全局依赖项目npm install webpack -gyarn global add webpack// 运行某个命令npm run 命令名称yarn run 命令名称 create-react-app (脚手架) 官方脚手架工具，类似Vue-cli 脚手架工具，用来初始化项目 其他关键词：前端工程化、前后端分离 基于yarn，包装了webpack等工具包 官网 基础使用安装 需要先安装npx（npm引入的新命令） 1npm install -g npx 123456npx create-react-app 项目名称// ornpm install -g create-react-app //全局安装create-react-app 项目名称 运行说明 12345678//package.json\"scripts\": &#123; \"start\": \"react-scripts start\", //运行项目 \"build\": \"react-scripts build\", //打包、编译 \"test\": \"react-scripts test\", //运行测试项目 \"eject\": \"react-scripts eject\" //解锁webpack等包，解锁后不能还原&#125;, 路由 根据hash实现，url中的#不会解析。通过js获取对应hash 并显示不同的组件 react-router doc ####配置 安装 1yarn add react-router-dom 声明式路由 import { BrowserRouter as Router, Route, Link } from “react-router-dom”; 标签包裹 内容 使用首页 //相当于 使用 // url为”/“时，加入 exact 中若没有path，则会匹配其他url，然后重定向？到component组件中 可以不写component： 可使用render={()=&gt;{111111}} 处理简单内容，触发条件为 path匹配 可使用children={()=&gt;{111111}} 与render类似，但触发条件为 路径触发则调用 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";import Home from './components/Home'import Game from './components/Game'class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Redirect to=\"/\"/&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; html容器： 模糊路由 import { BrowserRouter as Router, Route, Link, Switch} from “react-router-dom”; 不写明path，需要导入Switch，并用包裹 ：在路径相同的情况下，只匹配第一个，可以避免重复匹配路由 12345678910111213141516171819202122232425import &#123; BrowserRouter as Router, Route, Link, Switch&#125; from \"react-router-dom\";class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music\"&gt;音乐&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/:abc\"&gt;其他&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Route path='/music' component=&#123;Music&#125;&gt;&lt;/Route&gt; &lt;Route component=&#123;Other&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; 路由嵌套 子组件不需要用标签包裹 内容，且子组件可包含或 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link, Switch&#125; from \"react-router-dom\";// import './App.css';import Home from './components/Home'import Game from './components/Game'import Other from './components/Other'function music1()&#123;return &lt;p&gt;华语&lt;/p&gt;&#125;function music2()&#123;return &lt;p&gt;英语&lt;/p&gt;&#125;function Music ()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/music/1\"&gt;华语&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music/2\"&gt;英语&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/music/1\" component=&#123;music1&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/music/2\" component=&#123;music2&#125;&gt;&lt;/Route&gt; &lt;/div&gt; )&#125;class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music\"&gt;音乐&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/:abc\"&gt;其他&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Route path='/music' component=&#123;Music&#125;&gt;&lt;/Route&gt; &lt;Route component=&#123;Other&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 参数传递 通过 中的path设置传参 例如path=’/game/:id’ 在标签to中传递参数 在对应组件的 this.props.match 获取参数(class组件) 12345678910111213141516&lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game/123\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music\"&gt;音乐&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/:abc\"&gt;其他&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game/:id' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Route path='/music' component=&#123;Music&#125;&gt;&lt;/Route&gt; &lt;Route component=&#123;Other&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; 123456789//若是函数组件，则通过match获取参数&lt;Route path=\"/:id\" component=&#123;Child&#125; /&gt;function Child(&#123; match &#125;) &#123; return ( &lt;div&gt; &lt;h3&gt;ID: &#123;match.params.id&#125;&lt;/h3&gt; &lt;/div&gt; );&#125; 路由重定向 import { BrowserRouter as Router, Route, Link, Switch, Redirect} from “react-router-dom”; 123456// 函数组件，判断条件是否成立 //如果页面中存在&lt;Redirect&gt;标签，则会直接跳转function music2()&#123; let isok = false let info = isok ? \"\" : &lt;Redirect to='/'&gt;&lt;/Redirect&gt; return info&#125; 编程式导航 通过js的方式 实现组件跳转 //注意根url 的有没有exact 导入withRouter import { withRouter } from “react-router-dom”; 导出组件时需要使用withRouter包裹 export default withRouter(Game) 给事件源（按钮）注册方法，触发事件 通过结构获取props中的history let {history} = this.props 通过 history.push(‘/‘) 跳转页面 12345678910111213141516171819202122232425262728import React,&#123;Component&#125; from 'react'import &#123; withRouter &#125; from \"react-router-dom\";class Game extends Component &#123; constructor(props)&#123; super(props) &#125; fn=()=&gt;&#123; let &#123;history&#125; = this.props console.dir(history); history.push('/') // history.push('/',&#123;key:val&#125;) 传参 &#125; render()&#123; let id = this.props console.log(id); return ( &lt;div&gt; &lt;h1&gt;游戏&lt;/h1&gt; &lt;button onClick=&#123;this.fn&#125;&gt;编程式导航&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default withRouter(Game)// 传参跳转时，外部获取参数 props.location.state 自定义路由链接(样式) 路由发生变化时 改变对应标签的样式/结构重构 利用的children属性 获取当前点击事件源，并赋予指定样式 1234567891011121314151617181920212223242526272829303132333435363738394041import React from 'react'import &#123; Route, Link &#125; from 'react-router-dom'class Com extends React.Component&#123; render()&#123; // 通过props解构传入的参数 let &#123;to,name&#125; = this.props return ( // children传入函数，通过解构match判断当前事件源 &lt;Route path=&#123;to&#125; children=&#123;( &#123;match&#125; )=&gt;&#123; return ( &lt;div className=&#123;match?'active':''&#125;&gt; &lt;Link to=&#123;to&#125;&gt;&#123;name&#125;&lt;/Link&gt; &lt;/div&gt; ) &#125;&#125; /&gt; ) &#125;&#125;// 临时的组件function Temp1()&#123;return (&lt;div&gt;hello&lt;/div&gt;)&#125;function Temp2()&#123;return (&lt;div&gt;world&lt;/div&gt;)&#125;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;/* 内容容器 （这里组件写死了，以后可以动态传入组件） */&#125; &lt;Route path='/main/message/url-1' component=&#123;Temp1&#125;&gt;&lt;/Route&gt; &lt;Route path='/main/message/url-2' component=&#123;Temp2&#125;&gt;&lt;/Route&gt; &#123;/* 引入组件，传入参数 */&#125; &lt;Com to='/main/message/url-1' name='111' /&gt; &lt;Com to='/main/message/url-2' name='222' /&gt; &lt;/div&gt; ) &#125;&#125;export default Message // 参考项目代码：myapp-基础项目搭建.zip （看Menu.js、Main.js） redux 状态（数据）管理，类似vuex 看另一个笔记。。 其他内容短路运算符: &amp;&amp;1234567891011121314151617181920212223//通过短路运算符 判断标签是否需要渲染到页面中&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; show:true &#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.state.show &amp;&amp; &lt;h1&gt;hello&lt;/h1&gt; &#125; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt;&lt;Com&gt;&lt;/Com&gt;&lt;/div&gt;)ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 虚拟DOM（Virtual DOM） 映射真实DOM树的JS对象 数据发生改变时，先对虚拟DOM进行操作（diff） diff的结果就是变更的节点（这里的节点指的是虚拟节点-本质上就是普通对象） 而后对虚拟DOM、真实DOM进行比较 根据比较结构，对真实DOM进行操作，完成页面更新 案例1 - tab栏切换本质： 利用点击按钮时传递循环产生的 i，与state中的index配对 通过按钮点击事件 改变state中的值，保证这对数据 一致性 通过判断 i 和state中的index，判断 div 是否显示 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt;&lt;style&gt; #box div&#123;height: 200px;width: 300px;background: #ccc;display: none&#125; #box div.active&#123;display: block&#125; #box button.active&#123;background: orange&#125;&lt;/style&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; tabData:[&#123;title:'导航1',cont:'内容1'&#125;,&#123;title:'导航2',cont:'内容2'&#125;,&#123;title:'导航3',cont:'内容3'&#125;], eleIndex:0 &#125; &#125; handleTag=(e,i)=&gt;&#123; this.setState(&#123; eleIndex:i &#125;) &#125; render()&#123; let index = this.state.eleIndex let tempTitle = [] let tempCont = [] this.state.tabData.forEach((item,i) =&gt; &#123; tempTitle.push(&lt;button className=&#123;index==i?'active':''&#125; key=&#123;i&#125; onClick=&#123;(e)=&gt;&#123;this.handleTag(e,i)&#125;&#125;&gt;&#123;item.title&#125;&lt;/button&gt;) tempCont.push(&lt;div className=&#123;index==i?'active':''&#125; key=&#123;i&#125;&gt;&#123;item.cont&#125;&lt;/div&gt;) &#125;) return ( &lt;div id=\"box\"&gt; &#123;tempTitle&#125; &#123;tempCont&#125; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"React","slug":"React","permalink":"/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"/tags/React/"}]},{"title":"Vue - element-ui","slug":"Vue - element-ui","date":"2019-05-09T03:26:17.015Z","updated":"2019-05-09T03:26:14.031Z","comments":true,"path":"2019/05/09/Vue - element-ui/","link":"","permalink":"/2019/05/09/Vue - element-ui/","excerpt":"","text":"element-ui本身是一个Vue组件库，由饿了么团队进行包装。 桌面组件库（PC） 官网 其他常用组件库 连接 Vuetify Vue Material Keen UI Buefy Bootstrap-Vue AT-UI Fish-UI Quasar Muse UI Vux ###hello world 安装 1npm i element-ui -S 解决字体文件解析 1234//用到了**格式的字体文件，需要额外配置loader//该loader为：url-loader&#123;test:/\\.(eot|svg|ttf|woff|woff2)$/, use:'url-loader'&#125;, 基础使用 完整引入 1234567891011import Vue from 'vue';import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App.vue';Vue.use(ElementUI);new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); 基础使用 按需引入 参考 使用页面中的标签照抄代码就行，懒得写了","categories":[{"name":"Vue","slug":"Vue","permalink":"/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"手机rem、x倍图适配","slug":"手机rem、x倍图适配","date":"2019-05-09T03:11:41.902Z","updated":"2019-05-09T03:10:08.363Z","comments":true,"path":"2019/05/09/手机rem、x倍图适配/","link":"","permalink":"/2019/05/09/手机rem、x倍图适配/","excerpt":"","text":"rem计算参考 vm+rem：参考 123456789101112131415161718192021222324252627282930// .scss预编译// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vm_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vm_design: 750;html &#123; font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body增加宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125;// 使用示例div &#123; height: rem(300); width: rem(300); background: red;&#125; 标准rem方案： 动态获取屏幕宽度 并赋予font-size 应对于各视口+横竖屏 123456789&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; //获取手机屏幕宽度var deviceWidth = document.documentElement.clientWidth;//动态设置html的font-sizedocument.documentElement.style.fontSize = deviceWidth / 6.4 + 'px';//设计稿基准640px则：640/100=6.4//页面元素rem = 设计稿尺寸 / 100 rem 其他rem：背景：在 1080px 的视觉稿中，左上角有个logo，宽度是 180px 1234567&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; //最低设置 //获取手机屏幕宽度var deviceWidth = document.documentElement.clientWidth;//动态设置html的font-sizedocument.documentElement.style.fontSize = deviceWidth + 'px'; sass 12345678//定义方法：calc@function calc($val)&#123; @return $val / 1080;&#125;.logo&#123; width : calc(180rem);&#125; 倍图适配方法普通图片：js+img异步加载图片12//html&lt;img id=\"img\" data-src1x=\"xxx@1x.jpg\" data-src2x=\"xxx@2x.jpg\" data-src3x=\"xxx@3x.jpg\"/&gt; 123456789101112//jsvar dpr = window.devicePixelRatio;if(dpr &gt; 3)&#123; dpr = 3;&#125;;var imgSrc = $('#img').data('src'+dpr+'x');var img = new Image();img.src = imgSrc;img.onload = function(imgObj)&#123; $('#img').remove().prepend(imgObj);//替换img对象&#125;; srcset 标签 基于WebKit特性srcset 1&lt;img src=\"1.jpg\" srcset=\"2.jpg 2x, 3.jpg 3x\"&gt; 参考 背景图片：media query123456789101112131415161718/* 普通显示屏(设备像素比例小于等于1)使用1倍的图 */.css&#123; background-image: url(img_1x.png);&#125;/* 高清显示屏(设备像素比例大于等于2)使用2倍图 */@media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .css&#123; background-image: url(img_2x.png); &#125;&#125;/* 高清显示屏(设备像素比例大于等于3)使用3倍图 */@media only screen and (-webkit-min-device-pixel-ratio:3)&#123; .css&#123; background-image: url(img_3x.png); &#125;&#125; 横、竖屏： 需要针对横、竖屏编写不同的css 动态设置字体尺寸（不推荐） 12345678910var deviceWidth = document.documentElement.clientWidth, deviceHeight = document.documentElement.clientHeight//横屏状态if (window.orientation === 90 || window.orientation === -90) &#123; deviceWidth = deviceHeight;&#125;;//设置根字体大小document.documentElement.style.fontSize = deviceWidth + 'px'; JS检测横竖屏js获取屏幕旋转方向：window.orientation 0 - 正常方向 -90 - 屏幕顺时钟旋转90度 90 - 屏幕逆时针旋转90度 180 - 屏幕旋转180度 123window.addEventListener(\"orientationchange\", function () &#123; window.orientation === 0 ? alert('竖屏') : alert('横屏')&#125;, false) 12345678window.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", function() &#123; if (window.orientation === 180 || window.orientation === 0) &#123; console.log('竖屏状态！'); &#125;; if (window.orientation === 90 || window.orientation === -90 )&#123; console.log('横屏状态！'); &#125; &#125;, false); CSS判断横竖屏方式一： 12345&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"&gt;&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"landscape.css\"&gt; 方式二：写在同一个CSS中： 123456@media screen and (orientation: portrait) &#123; /*竖屏 css*/&#125; @media screen and (orientation: landscape) &#123; /*横屏 css*/&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"webpack - 基础","slug":"webpack - 基础","date":"2019-05-09T03:11:41.887Z","updated":"2019-05-09T03:15:16.392Z","comments":true,"path":"2019/05/09/webpack - 基础/","link":"","permalink":"/2019/05/09/webpack - 基础/","excerpt":"","text":"Webpack描述主要用于对项目文件进行打包，减少用户浏览时的请求数量，并对es6、es7降级，解决css兼容性等问题 npm 官网 适用于： 123456789101. 样式表 .css .less .scss2. JS文件 .js .ts (typescript)3. 图片 .jpg/.jpeg .png .gif .bmp 4. 字体文件 .ttf .eot .woff .woff2 .svg5. 模板文件 .vue .jsx(react) 不适用： 12341. 合并多个js文件为一个2. 模块化开发3. 把less、scss、es6/es7等高级语言编译为低级的，使得浏览器可以识别4. 编译图片为base64格式，减少网络请求次数 其他打包工具： Grunt Gulp 基本使用 基于node环境，需要配置基本的入口文件。输入/输出文件夹 默认只对.js文件打包，若需要处理额外的格式，需要安装对应的包 安装12345678910111213(以下为默认情况下的配置，部分内容可通过配置文件调整)1.初始化 初始化环境：npm init -y 在项目文件夹中创建\"src\"文件夹，用于默认的入口 创建入口文件:index.js、index.html2.安装 安装webpack和其依赖webpack-cli：npm i webpack webpack-cli -D （-d 等于将依赖安装到‘devDependencies’模块，该模块用于开发环境）3.配置运行指令 在package.json文件的scripts节点中，新增一个dev节点（自定义名称） \"pack\": \"webpack\" 打包时，运行命令：npm run pack，即可打包 自定义配置1234567891011121314151.在项目根目录下，创建一个 webpack.config.js 文件自定义配置：（具体参考官网）const path = require('path')module.exports = &#123; // production:生产，产生优化压缩的打包文件 // development:开发，产生有注释、空白、回车 可读性好的打包文件 mode: 'development', entry: path.join(__dirname, './src/index.js'), // 修改入口文件 output: &#123; path: path.join(__dirname, './dist'), // 输出目录 filename: 'main.js' // 输出打包文件名字设置 &#125;&#125;; HTML页面处理 插件：html-webpack-plugin 参考 安装 1npm install --save-dev html-webpack-plugin 配置 123456789101112//在 webpack.config.js 文件中添加：const HtmlWebpackPlugin = require('html-webpack-plugin');plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', //被打包的html模板文件名称 //filename: 'index.html' //生成打包文件名称， 默认是index.html &#125;)] 使用 1常规打包即可 loader参考 loader : javascript函数，以模块形式存在，webpack打包过程中，遇到不能处理的内容就会寻找对应的loader处理 处理不同内容的loader： css内容： style-loader 和 css-loader less内容： less-loader 和 less(less-loader的依赖) 图片内容： url-loader 和 file-loader ES6/ES7内容： babel-loader 配置参考 12345678910111213141516没有参数的 1个或多个 加载器配置&#123; test: /\\.格式$/, use: 加载器 &#125;, //1个&#123; test: /\\.格式$/, use: [加载器,加载器] &#125;, //多个 数组元素 &#123; test: /\\.格式$/, loader: 加载器&#125;, //1个&#123; test: /\\.格式$/, loader: 加载器!加载器&#125;, //多个 !叹号分隔有options参数的 1个或多个 加载器配置&#123; test: /\\.格式$/, loader: 加载器, options:对象参数&#125;, //1个&#123; test: /\\.格式$/, use:[&#123;loader: 加载器, options:对象参数&#125;,&#123;loader: 加载器, options:对象参数&#125;,...]&#125;, //多个 css文件处理安装 1npm install style-loader css-loader --save-dev 配置 12345678910111213141516171819202122232425//在 webpack.config.js 里添加：module: &#123; rules: [&#123; test: /\\.css$/, // css名字结尾文件 处理loader设定 use: [ // 以下两个loader有顺序要求，css-loader在后，style-loader在前 // 它们在执行的时候是先执行css-loader在执行style-loader &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125; ] &#125;, ]&#125;//精简写法module: &#123; rules: [&#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125;, ]&#125; less处理 最好先安装css-loader、style-loader 安装 1npm install --save-dev less-loader less 配置 123456789101112//在 webpack.config.js 文件中添加：module: &#123; rules: [&#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125;, &#123; test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"] &#125; ]&#125; url处理(+img) url-loader 该loader会将url引用的img图片转换成base64格式（可设置阈值） 超过阈值的内容会交给 file-loader处理 安装 1npm install --save-dev file-loader url-loader 配置 1234567891011121314151617181920//在 webpack.config.js 文件中添加：module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ] &#125; ] &#125;&#125;//limit 代表 阈值尺寸 JS降级 babel-loader 官网 webpack 安装 12345//不同版本的安装：npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpacknpm install babel-loader babel-core babel-preset-env webpacknpm install --save-dev babel-loader @babel/core @babel/preset-env 配置 v1 123456789101112131415//在 webpack.config.js 文件中添加：module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ]&#125; 推荐配置 12345678910111213//在 webpack.config.js 文件中添加：module: &#123; rules: [ &#123; // 设置babel-loader，使得js中es6等高级语法可以降级为es5标准，兼容各个浏览器 test: /\\.js$/, exclude: /node_modules/, // node_modules目录的js文件不要给处理 use: 'babel-loader', // 调用具体loader // 具体preset在其他位置配置，给\"根目录\"制作.babelrc文件并做配置即可 &#125; ]&#125; 123456//同级目录创建“.babelrc”，输入：&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-proposal-class-properties\"] //处理“静态”成员&#125; 处理“静态”成员 需要安装插件:class-properties 参考 安装 1npm install --save-dev @babel/plugin-proposal-class-properties 配置 12345678910111213//在.babelrc中配置&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-proposal-class-properties\"] //处理“静态”成员&#125;//在webpack.config.js中配置 ？？？&#123; \"plugins\": [ [\"@babel/plugin-proposal-class-properties\", &#123; \"loose\": true &#125;] ]&#125; Vue-loader 处理.vue格式的文件 官网 安装 1npm install vue-loader vue-template-compiler --save-dev 配置 12345678910111213141516171819//webpack.config.js//1const VueLoaderPlugin = require('vue-loader/lib/plugin')//2module: &#123; rules: [ &#123; test: /\\.vue$/, use: 'vue-loader' &#125;, ]&#125;, //3 plugins: [ new VueLoaderPlugin()], 其他简单服务器（实时预览） 一个简单的 web 服务器，并且能够实时重新加载(live reloading)。 只会在内存中运行，不会生成对应的实体文件 插件：webpack-dev-sever 参考 安装 1npm install --save-dev webpack-dev-server 配置 1 12345678910111213//在 webpack.config.js 中添加devServer: &#123; contentBase: './dist'&#125;//或 详细配置devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, //是否压缩 host: \"127.0.0.1\", // 服务主机ip地址 port: 9000, //端口号 open: true // 自动打开浏览器访问效果&#125; 配置 2 12345//在 package.json 里添加一个启动方式\"scripts\": &#123; \"line\": \"webpack-dev-server --open\"&#125;, 启动 1npm run line","categories":[{"name":"webpack","slug":"webpack","permalink":"/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"雅虎前端优化35条规则","slug":"雅虎前端优化35条规则","date":"2019-05-09T03:03:30.349Z","updated":"2019-05-09T03:08:48.155Z","comments":true,"path":"2019/05/09/雅虎前端优化35条规则/","link":"","permalink":"/2019/05/09/雅虎前端优化35条规则/","excerpt":"","text":"本文是大名鼎鼎的雅虎前端优化规则（Yslow）的翻译。翻译并不逐字逐句，部分难以逐字翻译的被意译了，另外一些不重要的举例等也被精简。 原文： Best Practices for Speeding Up Your Web Site。 如何让web页面更快，雅虎团队实践总结了7类35条规则，下面一一列出。 1. Content1.1 Make Fewer HTTP RequestsMinimize HTTP Requests减少/最小化 http 请求数。 到终端用户的响应时间80%花在前端：大部分用于下载组件（js/css/image/flash等等）。减少组件数就是减少渲染页面所需的http请求数。这是更快页面的关键。 减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少http请求，有以下几个技术： Combined files。合并文件，如合并js，合并css都能减少请求数。如果页面间脚本和样式差异很大，合并会更具挑战性。 CSS Sprites。雪碧图可以合并多个背景图片，通过background-image 和 background-position 来显示不同部分。 Image maps。合并多个图片到一个图片，一般用于如导航条。由于定义坐标的枯燥和易错，一般不推荐。 Inline images。使用data:url scheme来內连图片。 减少请求数是为第一次访问页面的用户提高性能的最重要的指导。 1.2 Reduce DNS Lookups减少DNS查询。 就像电话簿，你在浏览器地址栏输入网址，通过DNS查询得到网站真实IP。 DNS查询被缓存来提高性能。这种缓存可能发生在特定的缓存服务器（ISP/local area network维护），或者用户的计算机。DNS信息留存在操作系统DNS缓存中（在windows中就是 DNS Client Serve ）。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS记录，它就不会向操作系统发DNS解析请求。 IE默认缓存DNS记录30分钟，FireFox默认缓存1分钟。 当客户端的DNS缓存是空的，DNS查找次数等于页面中的唯一域名数。 减少DNS请求数可能会减少并行下载数。避免DNS查找减少响应时间，但减少并行下载数可能会增加响应时间。指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是两者的妥协。 1.3 Avoid Redirects避免跳转。 跳转用301或302状态码来达成。一个301响应http头的例子： 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 浏览器自动跳转到Location指定的路径。跳转所需的所有信息都在http头，所以http主体一般是空的。301`302响应一般不会被缓存，除非有额外的头部信息，比如Expires或Cache-Control指定要缓存。meta刷新标签或 JavaScript 也可以跳转，但如果真要跳转，3xx`跳转更好，主要是保证返回键可用。 跳转显然拖慢响应速度。在跳转的页面被获取前浏览器没什么能渲染，没什么组件能下载。 最浪费的跳转之一发生在url尾部slash（/）缺失。比如http://astrology.yahoo.com/astrology会301跳转到http://astrology.yahoo.com/astrology/。这可以被Apache等服务器修复，用Alias，mod_rewrite等等。 1.4 Make Ajax Cacheable让Ajax可缓存。 使用ajax的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。 提高ajax性能的最重要的方法是让响应被缓存，即在Add an Expires or a Cache-Control Header中讨论的 Expires 。其它方法是： gzip组件 减少DNS查找 压缩JS 避免跳转 设置ETags 1.5 Post-load Components延迟加载组件。 再看看你的页面然后问问自己，“什么是页面初始化必须的？”。剩下的内容和组件可以延迟。 JavaScript是理想的（延迟）候选者，可以切分到onload事件之前和之后。比如拖放的js库可以延迟，因为拖动必须在页面初始化之后。其它可延迟的包括隐藏的内容，折叠起来的图片等等。 1.6 Preload Components预加载组件。 预加载看起来与延迟加载相反，但它的确有个不同的目标。通过预加载你可以利用浏览器的空闲时间来请求你将来会用到的组件。这样当用户访问下一个页面时，你会有更多的组件已经在缓存中，这样会极大加快页面加载。 有几种预加载类型： 无条件预加载：一旦onload触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。 有条件预加载：基于用户动作，你推测用户下一步会去哪里并加载相应组件。 预期的预加载：在发布重新设计（的网站）前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。 1.7 Reduce the Number of DOM Elements减少dom数。 一个复杂的页面意味着更多的内容要下载，以及更慢的dom访问。比如在有500dom数量的页面添加事件处理就和有5000dom数量的不同。 如果你的页面dom元素很多，那么意味着你可能需要删除无用的内容和标签来优化。 1.8 Split Components Across Domains把组件分散到不同的域名。 把组件分散到不同的域名允许你最大化并行下载数。由于DNS查询的副作用，最佳的不同域名数是2-4。 1.9 Minimize the Number of iframes最小化iframe的数量。 iframe允许html文档被插入到父文档。 优点： 帮助解决缓慢的第三方内容的加载，如广告和徽章 安全沙盒 并行下载脚本 缺点： 即使空的也消耗（资源和时间） 阻塞了页面的onload 非语义化（标签） 1.10 No 404s不要404。 http请求是昂贵的，所以发出http请求但获得没用的响应（如404）是完全不必要的，并且会降低用户体验。 一些网站会有特别的404页面提高用户体验，但这仍然会浪费服务器资源。特别坏的是当链接指向外部js但却得到404结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把404响应体当作js来解析，试图从里面找出可用的东西。 2. Server2.1 Use a Content Delivery Network使用CDN。 用户接近你的服务器会减少响应时间。把你的内容发布到多个，地理上分散的服务器可以让页面加载更快。但怎么开始？ 首先不要试图把你的架构重新设计成分布式架构。因为可能引进更多复杂性和不可控。 记住80-90%的终端用户响应时间花费在下载页面中的所有组件：图片、样式、脚本、falsh等等。这是Performance Golden Rule。不要从困难的重新设计后台架构开始，最好首先分发你的静态内容。这不仅可以减少响应时间，用CDN还很容易来做。 CDN是一群不同地点的服务器，可以更高效地分发内容到用户。一些大公司有自己的CDN。 2.2 Add an Expires or a Cache-Control Header加Expires或者Cache-Control头部。 这条规则有两个方面： 对静态组件：通过设置Expires头部来实现“永不过期”策略。 对动态组件：用合适的Cache-Control头部来帮助浏览器进行有条件请求。 页面越来越丰富，意味着更多脚本，样式，图片等等。第一次访问的用户可能需要发出多个请求，但使用Expires可以让这些组件被缓存。这避免了访问子页面时没必要的http请求。Expires一般用在图片上，但应该用在所有的组件上。 浏览器（以及代理）使用缓存来减少http请求数，加快页面加载。服务器使用http响应的Expires头部来告诉客户端一个组件可以缓存多久。比如下面： 1Expires: Thu, 15 Apr 2010 20:00:00 GMT //2010-04-15之前都是稳定的 注意，如果你设置了Expires头部，当组件更新后，你必须更改文件名。 2.3 Gzip Components传输时用gzip等压缩组件。 http请求或响应的传输时间可以被前端工程师显著减少。终端用户的带宽，ISP，接近对等交换点等等没法被开发团队控制，但是，压缩可以通过减少http响应的大小减少响应时间。 从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩： 1Accept-Encoding: gzip, deflate 如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端： 1Content-Encoding: gzip gzip一般可减小响应的70%。尽可能去gzip更多（文本）类型的文件。html，脚本，样式，xml和json等等都应该被gzip，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过，gzip它们只是浪费cpu，甚至增加文件大小。 2.4 Configure ETags实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个组件是否匹配服务器端原组件的一种机制。实体就是组件：图片，脚本，样式等等。ETag被当作验证实体的比最后更改（last-modified）日期更高效的机制。服务器这样设置组件的ETag： 1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195 之后，如果浏览器要验证组件，它用If-None-Match头部来传ETag给服务器。如果ETag匹配，服务器返回304： 12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified ETag的问题是它们被构造来使它们对特定的运行这个网站的服务器唯一。浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag将不匹配。然而服务器集群是处理请求的通用解决方案。 如果不能解决多服务器间的ETag匹配问题，那么删除ETag可能更好。 2.5 Flush the Buffer Early早一点刷新buffer（尽早给浏览器数据）。 当用户请求一个页面，服务器一般要花200-500ms来拼凑整个页面。这段时间，浏览器是空闲的（等数据返回）。在php，有个方法flush()允许你传输部分准备好的html响应给浏览器。这样的话浏览器就可以开始下载组件，而同时后台可以继续生成页面剩下的部分。这种好处更多是在忙碌的后台或轻前端网站可以看到。 一个比较好的flush的位置是在head之后，因为浏览器可以加载其中的样式和脚本文件，而后台继续生成页面剩余部分。 12345&lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt;&lt;!-- content --&gt; 2.6 Use GET for AJAX Requestsajax请求用get。 Yahoo! Mail团队发现当使用XMLHttpRequest，POST 被浏览器实现为两步：首先发送头部，然后发送数据。所以使用GET最好，仅用一个TCP包发送（除非cookie太多）。IE的url长度限制是2K。 POST但不提交任何数据根GET行为类似，但从语义上讲，获取数据应该用GET，提交数据到服务器用POST。 2.7 Avoid Empty Image src避免空src的图片。 空src属性的图片的行为可能跟你预期的不一样。它有两种形式： html标签：&lt;img src=&quot;&quot;&gt; js：var img = new Image(); img.src = &quot;&quot;; 两种都会造成同一种后果：浏览器会向你的服务器发请求。 IE，向页面所在的目录发请求。 Safari和Chrome，请求实际的页面。 FireFox3及之前和Safari/Chrome一样，但从3.5开始修复问题，不再发请求。 Opera遇到空图片src不做任何事。 为什么这种行为很糟糕？ 由于发送大量的意料之外的流量，会削弱服务器，尤其那些每天pv上百万的页面。 浪费服务器计算周期取生成不会被浏览的页面。 可能会破坏用户数据。如果你在跟踪请求状态，通过cookie或其它，你可能会破坏数据。即使image的请求不会返回图片，但所有的头部数据都被浏览器读取了，包括cookie。即使剩下的响应体被丢弃，破坏可能已经发生。 这种行为的根源是uri解析发生在浏览器。RFC 3986 定义了这种行为，空字符串被当作相对路径，Firefox, Safari, 和 Chrome都正确解析，而IE错误。总之，浏览器解析空字符串为相对路径的行为被认为是符合预期的。 html5在4.8.2添加了对标签src属性的描述，指导浏览器不要发出额外的请求。 The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string. 幸运的是将来浏览器不会有这个问题了（在图片上）。不幸的是，&lt;script src=&quot;&quot;&gt;和&lt;link href=&quot;&quot;&gt;没有这样的规范。 3 Cookie3.1 Reduce Cookie Sizehttp cookie的使用有多种原因，比如授权和个性化。cookie的信息通过http头部在浏览器和服务器端交换。尽可能减小cookie的大小来降低响应时间。 消除不必要的cookie。 尽可能减小cookie的大小来降低响应时间。 注意设置cookie到合适的域名级别，则其它子域名不会被影响。 正确设置Expires日期。早一点的Expires日期或者没有会尽早删除cookie，优化响应时间。 3.2 Use Cookie-free Domains for Components用没有cookie的域名提供组件。 当浏览器请求静态图片并把cookie一起发送到服务器时，cookie此时对服务器没什么用处。所以这些cookie只是增加了网络流量。所以你应该保证静态组件的请求是没有cookie的。可以创建一个子域名来托管所有静态组件。 比如，你域名是www.example.org，可以把静态组件托管在static.example.org。不过，你如果把cookie设置在顶级域名example.org下，这些cookie仍然会被传给static.example.org。这种情况下，启用一个全新的域名来托管静态组件。 另外一个用没有cookie的域名提供组件的好处是，某些代理可能会阻止缓存待cookie的静态组件请求。 4. CSS4.1 Put Stylesheets at the Top把样式放在顶部。 研究雅虎网页性能时发现把样式表移到&lt;head&gt;里会让页面更快。这是因为把样式表移到&lt;head&gt;里允许页面逐步渲染。 关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML页面就是进度条。当浏览器逐步加载页面头部，导航条，logo等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。 把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。 HTML规范清楚表明样式应该在&lt;head&gt;里。 4.2 Avoid CSS Expressions避免CSS表达式。 CSS表达式是强大的（可能也是危险的）设置动态CSS属性的方法。IE5开始支持，IE8开始不赞成使用。例如，背景颜色可以设置成每小时轮换： 1background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); CSS表达式的问题是它们可能比大多数人预期的计算的更频繁。它们不仅在页面载入和调整大小时重新计算，也在滚动页面甚至是用户在页面上移动鼠标时计算。比如在页面上移动鼠标可能轻易计算超过10000次。 要避免CSS表达式计算太多次，可以在它第一次计算后替换成确切值，或者用事件处理函数而不是CSS表达式。 4.3 Choose &lt;link&gt; over @import选择&lt;link&gt;而不是@import。 之前的一个最佳原则是说CSS应该在顶部来允许逐步渲染。 在IE用@import和把CSS放到页面底部行为一致，所以最好别用。 4.4 Avoid Filters避免使用（IE）过滤器。 IE专有的AlphaImageLoader过滤器用于修复IE7以下版本的半透明真彩色PNG的问题。这个过滤器的问题是它阻止了渲染，并在图片下载时冻结了浏览器。另外它还引起内存消耗，并且它被应用到每个元素而不是每个图片，所以问题（的严重性）翻倍了。 最佳做法是放弃AlphaImageLoader，改用PNG8来优雅降级。 5. JavaScript5.1 Put Scripts at the Bottom把脚本放到底部。 脚本引起的问题是它们阻塞了并行下载。HTTP1.1规范建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下。 有些情况下把脚本移动到底部并不简单。比如，脚本中用了document.write来插入内容，它就不能被移动到底部。另外有可能有作用域问题。但大多数情况，有方法可以解决这些问题。 一个替代建议是使用异步脚本。defer属性表明脚本不包含document.write，是提示浏览器继续渲染的线索。不幸的是，Firefox不支持。如果脚本能异步，那么也就可以移动到底部。 5.2 Make JavaScript and CSS External使用外部JS和CSS。 这里的很多性能规则涉及外部组件怎么管理。但你首先要明白一个基本问题：JS和CSS是应该包含在外部文件还是內连在页面本身？ 真实世界中使用外部文件一般会加快页面，因为JS和CSS文件被浏览器缓存了。內连的JS和CSS怎在每次HTML文档下载时都被下载。內连减少了http请求，但增加了HTML文档大小。另一方面，如果JS和CSS被缓存了，那么HTML文档可以减小大小而不增加HTTP请求。 核心因素，就是JS和CSS被缓存相对于HTML文档被请求的频率。尽管这个因素很难被量化，但可以用不同的指标来计算。如果网站用户每个session有多个pv，许多页面重用相同的JS和CSS，那么有很大可能用外部JS和CSS更好。 许多网站用这些指标计算后在中间位置。对这些网站来说，最佳方案还是用外部JS和CSS文件。唯一例外是內连更被主页偏爱，如http://www.yahoo.com/。主页每个session可能只有少量的甚至一个pv，这时候內连可能更快。 对多个页面的首页来说，可以通过技术减少（其它页面的）http请求。在首页用內连，初始化后动态加载外部文件，接下来的页面如果用到这些文件，就可以使用缓存了。 5.3 Minify JavaScript and CSS压缩JS和CSS。 压缩就是删除代码中不必要的字符来减小文件大小，从而提高加载速度。当代码压缩时，注释删除，不需要的空格（空白，换行，tab）也被删除。 混淆是对代码可选的优化。它比压缩更复杂，并且可能产生bug。在对美国top10网站的调查，压缩可减小21%，而混淆可减小25%。 除了外部脚本和样式，內连的脚本和样式同样应该被压缩。 5.4 Remove Duplicate Scripts删除重复的脚本。 在页面中引入相同的脚本两次会伤害性能。可能超出你的预料，美国top10网站的2家有重复脚本引入。两个主要因素造成同一页面引入相同脚本：团队大小和脚本数量。当确实引入重复脚本，会发出不必要的http请求和浪费js执行时间。 发出不必要的http请求发生在IE而不是Firefox。在IE，如果外部脚本引入两次且没有缓存，它会发出2个请求。即使脚本被缓存，刷新时也会发出额外请求。 除了增加http请求，时间被浪费在执行脚本多次上。不管IE还是Firefox都会执行多次。 一种避免多次引入脚本的方法是在模板系统实现一个脚本管理模块。 5.5 Minimize DOM Access最小化DOM访问。 用JS访问DOM元素是缓慢的，所以为了响应更好的页面，你应该： 缓存访问过的元素的引用 在DOM树外更新节点，然后添加到DOM树 避免用JS实现固定布局 5.6 Develop Smart Event Handlers开发聪明的事件处理 有时候页面看起来不那么响应（响应速度慢），是因为绑定到不同元素的大量事件处理函数执行太多次。这是为什么使用事件委托是一种好方法。 另外，你不必等到onload事件来开始处理DOM树，DOMContentLoaded更快。大多时候你需要的只是想访问的元素已在DOM树中，所以你不必等到所有图片被下载。 6 Images6.1 Optimize Images优化图片 在设计师建好图片后，在上传图片到服务器前你仍可以做些事： 检查gif图片的调色板大小是否匹配图片颜色数。 可以把gif转成png看看有没有变小。除了动画，gif一般可以转成png8。 运行pngcrush或其它工具压缩png。 运行jpegtran或其它工具压缩jpeg。 6.2 Optimize CSS Sprites优化CSS雪碧图 把图片横向合并而不是纵向，横向更小。 把颜色近似的图片合并到一张雪碧图，这样可以让颜色数更少，如果低于256就可以用png8. “Be mobile-friendly”并且合并时图片间的间距不要太大。这对图片大小影响不是太大，但客户端解压时需要的内存更少。100×100是10000个像素，1000×1000是1000000个像素。 6.3 Don’t Scale Images in HTML不要在html中缩放图片 不要因为你可以设置图片的宽高就去用比你需要的大得多的图片。如果你需要 1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么，就用100x100px的图片，而不是500x500px的。 6.4 Make favicon.ico Small and Cacheablefavicon.ico小且缓存 favicon.ico是在你服务器根路径的图片。邪恶的是即使你不关心它，浏览器仍然会请求它。所以最好不要响应404。另外由于在同一服务器，每次请求favicon.ico时也会带上cookie。这个图片还会影响下载顺序，比如在IE，如果你在onload时下载额外的组件，fcvicon会在这些组件之前被下载。 怎么减轻favicon.ico的缺点？ 小，最好1K以下 设置Expires头部。也许可以安全地设置为几个月。 7 Mobile7.1 Keep Components under 25K保持组件小于25K 这个限制与iPhone不缓存大于25K的组件相关。注意，这是非压缩（uncompressed）的文件大小。在这里minification（压缩，不要与compress混淆）很重要，因为gzip无法满足（iPhone）。 7.2 Pack Components into a Multipart Document打包组件到一个多部父文档 打包组件到一个多部父文档类似于带附件的邮件。它帮助你在一个http请求中获取多个组件，但注意，iPhone不支持。","categories":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/categories/扩展阅读/"}],"tags":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/tags/扩展阅读/"}]},{"title":"Hello World","slug":"0.hello-world","date":"2019-05-07T10:06:43.794Z","updated":"2019-05-09T07:11:09.349Z","comments":true,"path":"2019/05/07/0.hello-world/","link":"","permalink":"/2019/05/07/0.hello-world/","excerpt":"","text":"前言 入了前端坑了以后，才越发发现技术领域的庞大，为了巩固所学知识 与项目实战的经验 着手准备撰写博客 该博客采用Hexo框架搭建，配置在了全球最大同性交友平台（giyhub）上 搭建流程概述 安装nodejs 官网 打开cmd，安装hexo 官网 npm install hexo-cli -g 新建文件夹 在cmd中初始化hexo hexo init 安装对应主题（去github或官网查看） 配置_config.yml 使用git 初始化、上传到github上 配置（转载）https://www.jianshu.com/p/9f0e90cc32c2","categories":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/categories/扩展阅读/"}],"tags":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/tags/扩展阅读/"}]}]}