{"meta":{"title":"nova7y","subtitle":null,"description":null,"author":"nova7y","url":"","root":"/yyy/"},"pages":[{"title":"标签","date":"2019-05-09T02:30:30.208Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-09T02:30:19.811Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-05-09T02:30:00.482Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"React - 基础","slug":"React - 基础","date":"2019-05-09T03:15:24.626Z","updated":"2019-05-09T03:15:01.230Z","comments":true,"path":"2019/05/09/React - 基础/","link":"","permalink":"/2019/05/09/React - 基础/","excerpt":"","text":"React框架个人感觉 违背W3C等规范，将JS、HTML等语言混在一起使用 在JS的基础上进行扩展，又不符合常规语法，容易混淆，难以理解 一次编写 到处运行是个亮点，内部算法也许比Vue强 特性 声明式视图 对于声明式组件，当数据变更的时候，React低层负责高效更新。这种方式代码更加可预见并且更容易调试。 组件化 封装管理数据的组件，通过组合的方式实现复杂的UI，组件的逻辑采用js实现而不是模板，这样可以保持数据在DOM之外。 一次学习，随处编写 React可以进行服务端渲染，也可以用于移动APP开发（React Native） 中文官网 英文官网 前端3大框架： 框架 时间 作者 概述 Vue 2012 尤雨溪 只关注视图层的开发 React 2010 facebook 一切都是javascript、包括html、css angular 2009 google TypeScript、被边缘化 Vue与React的区别 MVC、MVVM MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分： Model：（数据层）主要负责 数据库的操作； View：（视图层）所有前端页面，统称为 View 层 Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点） MVVM是前端页面的分层开发思想，主要关注于 视图层 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View, ViewModel Model 是 页面中，需要用到的数据 View 是页面中的HTML结构； ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念； 其他框架 Ember Knockout Polymer Riot 基本用法注：代码中含有为基础用法 后续会采用npm的方式安装React，并在js里写组件 12345678910111213141516171819&lt;body&gt; &lt;script src=\"./js/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/babel.min.js\"&gt;&lt;/script&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root') ); &lt;/script&gt;&lt;/body&gt;//ornpm 下载 JSX(js扩展语法) 本质：普通对象 JSX中嵌入表达式（JSX本身也是表达式） JSX可以赋值给变量 作为函数的参数 作为函数的返回值 常规用法123456789101112131415161718const info = &lt;div&gt;Hello World!&lt;/div&gt;;//可以html标签嵌套，但是需要包含一个根标签！！const element = (&lt;div&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/div&gt;);//()可以不加~ 建议加上。。//作为函数的返回值function foo() &#123; return ( &lt;div tabIndex=\"0\" className='active'&gt;Tom&lt;/div&gt; );&#125;//作为函数的参数function foo(info) &#123; return info;&#125;let ret = foo(&lt;div&gt;hi&lt;/div&gt;); 原理 1234567891011121314151617181920212223// 函数原型React.createElement(element, [props], [...children])// ------------------------------------------------const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// 上述JSX本质上可以表示为如下形式：const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!');// let info = &lt;div&gt;你好&lt;/div&gt;;// let info = React.createElement('h1', &#123;className: 'active'&#125;, 'Nihao');let c1 = React.createElement('h1', &#123;className: 'active1'&#125;, 'Nihao');let c2 = React.createElement('h2', &#123;className: 'active2'&#125;, 'Hello');let info = React.createElement('div', &#123;className: 'active'&#125;, [c1, c2]);ReactDOM.render(info, document.getElementById('root')); props属性操作 可使用es6等语法，通过多种方式传递数据/属性 扩展运算符：传递多个数据 12345678910111213141516171819//使用 ... 完成数据 解构？ 传递数据&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.name&#125; | &#123;this.props.age&#125; | &#123;this.props.sex&#125; &lt;/div&gt; ) &#125; &#125; let obj = &#123;name:'zs',age:18,sex:'男'&#125; let App = ( &lt;div&gt;&lt;Com &#123;...obj&#125; /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 解构：传递指定数据 1234567891011121314151617181920// 使用 ... 将name值“拆出来”，这时传递到组件中 就只有age、sex 了&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.name&#125; | &#123;this.props.age&#125; | &#123;this.props.sex&#125; &lt;/div&gt; ) &#125; &#125; let obj = &#123;name:'zs',age:18,sex:'男'&#125; let &#123;name,...other&#125; = obj let App = ( &lt;div&gt;&lt;Com &#123;...other&#125; /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; props值类型 组件传递数据时，可传递表达式、函数、对象等类型。并可以在组件中调用、更改值 但是开发环境中不建议修改props中的值 1234567891011121314151617&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.num&#125; | &#123;this.props.obj.name&#125; | &#123;this.props.fn()&#125; &lt;/div&gt; ) &#125; &#125; let myObj = &#123;name:1&#125; let App = ( &lt;div&gt;&lt;Com num=&#123;1+2+3&#125; obj=&#123;myObj&#125; fn=&#123;()=&gt;&#123;console.log(123)&#125;&#125; /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; children 原理类似Vue中的 slot（插槽） 在React中，可通过 this.props.children 获取组件标签中的内容/html结构 1234567891011121314&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com&gt;hello world&lt;/Com&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 点标记组件 可通过对象的方式 包装 多个子组件，通常代表子组件功能相互关联 12345678910111213141516&lt;script type=\"text/babel\"&gt; let abc = &#123; a:class extends React.Component&#123; render()&#123; return (&lt;div&gt;&lt;h1&gt;A&lt;/h1&gt;&lt;/div&gt;) &#125; &#125;, b:class extends React.Component&#123; render()&#123; return (&lt;div&gt;&lt;h1&gt;B&lt;/h1&gt;&lt;/div&gt;) &#125; &#125; &#125; let App = ( &lt;div&gt;&lt;abc.a /&gt;&lt;abc.b /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 高阶组件笔记未总结 组件化 重复利用的单元，形式与vue类似，实现原理不同 高内聚,低耦合 React的组件推荐写在js中，这里先写在html里，方便学习 定义组件的方式（2种） 12345678910111213//函数组件function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;//类组件class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;//定义class并继承React.component，并return组件结构 类组件的传参 - 固定写法，包括 “props” 12345678910111213141516171819202122&lt;script type=\"text/babel\"&gt; class Con extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;h1&gt;你好&#123;this.props.info&#125;&lt;/h1&gt;; &#125; &#125; let app = &lt;Con info=\"World\"&gt;a&lt;/Con&gt;; ReactDOM.render(app, document.getElementById(\"root\"));&lt;/script&gt;// ----------说明----------// class Con 继承(extends) React.Component// 采用constructor 接收参数(props) （固定写法） //这个+内部的super可以省略不写! // 使用super(props) super代表调用父类构造函数（这里指React） 在这里接收了参数props// Con中 写了一个render()方法 并将html结构return// 外部可以使用&lt;Con&gt;&lt;/Con&gt;// Con中的this指向 与 普通构造函数的指向（示例）一致// Con通过原型链 可以找到父类中的props 数据 组件状态-state（单向数据流） 组件可通过this.state={} 设置内部数据 ！class组件存在state，函数组件不存在 数据特性为单向：父组件数据传递给子组件 123456789101112131415161718&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class Com1 extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; msg:'hello world' &#125; &#125; render()&#123; return( &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; ) &#125; &#125; let App = (&lt;Com1&gt;&lt;/Com1&gt;) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; state中数据修改 123456// 若要设置state的值，则需要使用：this.setState(&#123;&#125;)// 若不使用该方法，React则无法监测到数据变化 而改变DOMthis.setState(&#123; msg:new Date().toString()&#125;) setState的数据修改异步问题 12345678910111213141516//setState是异步执行，所以这里console打印出的是旧数据clk=()=&gt;&#123; this.setState(&#123; num:this.state.num + 1 &#125;) console.log(this.state.num);&#125;//setState有一个回调函数，这里打印出的是数据更新后的值clk=()=&gt;&#123; this.setState(&#123; num:this.state.num + 1 &#125;,()=&gt;&#123; console.log(this.state.num); &#125;)&#125; 组件间数据传值父 → 子 父组件向子组件传值(props) 子组件 通过”标签属性”向父组件传值 父组件class中的props中就会包含子组件传输的数据（格式：子组件属性:数据） 在父组件中可通过 this.props.属性获取子组件传送的数据 1234567891011121314151617181920212223242526272829303132333435363738&lt;script type=\"text/babel\"&gt; class Father extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; msg:'Father组件data' &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;father&lt;/h1&gt; &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &lt;Son msg=&#123;this.state.msg&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ) &#125; &#125; class Son extends React.Component &#123; constructor(props) &#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;son&lt;/h1&gt; &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt; &lt;Father msg='根组件data'&gt;&lt;/Father&gt; &lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 子 → 父 子组件向父组件传值(传递函数) 在父组件class中 render子组件 通过子组件标签属性传递一个函数sum 在子组件class中解构、运行该函数 sonnum() // 示例代码是通过事件触发解构、运行、传值 总结：通过父组件向子组件传递“函数” 并在子组件解构 + 运行 + 传递参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script type=\"text/babel\"&gt; class Son extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; num: 0 &#125; &#125; clk=()=&gt;&#123; let &#123;sonnum&#125; = this.props sonnum(1) this.setState(&#123; num:this.state.num + 1 &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.clk&#125;&gt;点击&lt;/button&gt; &lt;span&gt;&#123;this.state.num&#125;&lt;/span&gt; &lt;/div&gt; ) &#125; &#125; class Father extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; total:0 &#125; &#125; sum=(n)=&gt;&#123; this.setState(&#123; total:this.state.total + n &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.total&#125;&lt;/h1&gt; &lt;Son sonnum=&#123;this.sum&#125;&gt;&lt;/Son&gt; &lt;Son sonnum=&#123;this.sum&#125;&gt;&lt;/Son&gt; &lt;Son sonnum=&#123;this.sum&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt; &lt;Father&gt;&lt;/Father&gt; &lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 兄弟 → 兄弟 非父子组件之间传值(redux) 生命周期 组件从产生 → 销毁的过程 （重要的加粗） （即将移除）componentWillMount：唯一在render()之前调用的钩子 componentDidMount： DOM树渲染完成后调用，通常用于加载后台数据 （即将移除）componentWillReceiveProps：组件接收到新的props，该方法会首先被调用 （新增）static getDerivedStateFromProps(props, state)：state、props改变后，都会执行钩子 componentWillUnmount：组件被销毁之前一般用于清理工作（定时器timer、网络请求、订阅事件） 其他生命周期钩子参考 使用示例： componentDidMount(){} 123456789101112render()&#123; return( &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; )&#125;componentDidMount()&#123; setInterval(() =&gt; &#123; this.setState(&#123; msg:new Date().toString() &#125;) &#125;, 1000);&#125; 事件相关事件绑定 通过button标签中的 onClick={this.clk} 绑定点击事件clk 123456789101112131415161718192021222324252627&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; num:0 &#125; &#125; clk=()=&gt;&#123; this.setState(&#123; num:this.state.num + 1 &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.state.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.clk&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;Com&gt;&lt;/Com&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 事件传参 若需要传递参数则需要在onClick中传递一个 “参数” 函数！！ —–错误写法：onClick={ this.clk(2) } 等同于函数调用，会返回字符串。而这里需要一个函数 可以通过 onClick={ (e)=&gt;{this.clk(e,2)} } //第一个参数为 事件对象 可以通过 onClick={ this.clk.bind( this,2 ) } //采用bind的特性（返回一个函数） —–改变this只是原生js语法规定的，这里没有什么用 （不太确定） 12345678910111213141516171819202122232425262728&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; num:0 &#125; &#125; clk=(e,n)=&gt;&#123; console.log(e); this.setState(&#123; num:this.state.num + n &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.state.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.clk(e,2)&#125;&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;Com&gt;&lt;/Com&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 阻止默认行为123456789clk=(e,n)=&gt;&#123; e.stopPropagation() // 阻止冒泡 e.preventDefault() // 阻止默认行为 return false // 不好使 this.setState(&#123; num:this.state.num + n &#125;)&#125; 补充 1234//clk方法写成了箭头函数，其原因为this指向问题//另一种解决方法是： (改变this指向)this.clk = this.clk.bind(this); 条件渲染 通过判断语句，甄别渲染组件/标签/内容 if else 在render函数中 通过if判断 要reruen什么html结构 123456789101112131415161718&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; show:false &#125; &#125; render()&#123; if(this.state.show)&#123; return( &lt;h1&gt;hello&lt;/h1&gt; ) &#125; else&#123; return (&lt;h1&gt;world&lt;/h1&gt;) &#125; &#125; &#125; let App = ( &lt;div&gt;&lt;Com&gt;&lt;/Com&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 三元表达式 return时 可通过三元表达式来判断是否要渲染 123456789101112131415161718192021&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; show:false &#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.state.show ? &lt;h1&gt;hello&lt;/h1&gt; : &lt;h1&gt;world&lt;/h1&gt; &#125; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt;&lt;Com&gt;&lt;/Com&gt;&lt;/div&gt;)ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 阻止渲染 1// 在function中return null / 在class render中 return null 遍历渲染 通过原生数组map()方法循环遍历 生成html结构，然后使用{html}渲染 遍历出的html必须包含唯一的key，便于React监控DOM树 1234567891011121314151617181920&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; ary:[1,2,3,4,5] &#125; &#125; render()&#123; let lis = this.state.ary.map((item,index)=&gt;&#123;return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;) return ( &lt;div&gt; &lt;ul&gt;&#123;lis&#125;&lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 表单处理 受控组件：表单域的基本使用；通过标签中的value绑定数据 + onChange “实时”监控表单状态双向数据绑定 非受控组件：直接通过DOM获取value 也可绑定state中数据 区别： 需要设置原始值，或实时监控组件内容时 使用受控组件，反之非受控组件 表单中 若存在“value”，则通常为受控组件 受控组件 通过html表单域中的value 绑定state的值 通过给表单绑定onChange方法 更新state中的值 —-在onChange(e){}方法中，第一个参数为事件对象，通过e.target.vale可获取值 1234567891011121314151617181920212223242526&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; uname:'' &#125; &#125; inputChange=(e)=&gt;&#123; let val = e.target.value this.setState(&#123; uname:val &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.uname&#125; onChange=&#123;this.inputChange&#125;/&gt; &lt;p&gt;state的值：&#123;this.state.uname&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 非受控组件 通过html标签中的ref值 与class组件声明的ref 的进行绑定 通过 this.ref.current.value 获取对应html表单的值 1234567891011121314151617181920212223242526272829&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; uname:'' &#125; this.uNameRef = React.createRef() &#125; inputPush=()=&gt;&#123; let val = this.uNameRef.current.value this.setState(&#123; uname:val &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;input的值不会实时绑定到state中&lt;/p&gt; &lt;input type=\"text\" ref=&#123;this.uNameRef&#125; /&gt; &lt;button onClick=&#123;this.inputPush&#125;&gt;提交&lt;/button&gt; &lt;p&gt;提交后state：&#123;this.state.uname&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 常规表单处理radio：通过受控组件 监控 选中情况，并根据绑定的value值 来决定checked 1234567891011121314151617181920212223242526&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; sex:'man' &#125; &#125; iChange=(e)=&gt;&#123; this.setState(&#123; sex:e.target.value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"radio\" name=\"sex\" value=\"man\" checked=&#123;this.state.sex=='man'&#125; onChange=&#123;this.iChange&#125; /&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"women\" checked=&#123;this.state.sex=='women'&#125; onChange=&#123;this.iChange&#125; /&gt;女 &lt;p&gt;radio数据：&#123;this.state.sex&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; checkbox：通过onChange事件监控点击事件，使用临时array、遍历的方法判断点击次数，判断是否“选中” 123456789101112131415161718192021222324252627282930313233&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; checkboxDate:[] &#125; &#125; isChecked=(e)=&gt;&#123; let val = e.target.value let ary = this.state.checkboxDate.slice() //截取(0)生成新数组，避免相同引用地址 let index = ary.findIndex(item=&gt;item==val) //循环遍历出索引index if(index == -1) &#123; ary.push(val) &#125; //判断数组中是否存在 else &#123; ary.splice(index,1) &#125; this.setState(&#123; checkboxDate:ary &#125;,()=&gt;&#123;console.log(this.state.checkboxDate);&#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"checkbox\" name=\"like\" value=\"read\" onChange=&#123;this.isChecked&#125; /&gt;看书 &lt;input type=\"checkbox\" name=\"like\" value=\"game\" onChange=&#123;this.isChecked&#125; /&gt;游戏 &lt;input type=\"checkbox\" name=\"like\" value=\"music\" onChange=&#123;this.isChecked&#125; /&gt;音乐 &lt;p&gt;checkbox绑定的值：&#123;this.state.checkboxDate&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; select + option：通过受控组件 监控 选中情况，并更新state中的值 1234567891011121314151617181920212223242526272829&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; val:1 &#125; &#125; iChange=(e)=&gt;&#123; this.setState(&#123; val:e.target.value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;select value=&#123;this.state.val&#125; onChange=&#123;this.iChange&#125;&gt; &lt;option value='1'&gt;工作&lt;/option&gt; &lt;option value='2'&gt;学习&lt;/option&gt; &lt;option value='3'&gt;看书&lt;/option&gt; &lt;/select&gt; &lt;p&gt;option绑定的value值：&#123;this.state.val&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; file：通过非受控组件 ，当点击按钮后 读取 文件上传情况，并更新state中的值 1234567891011121314151617181920212223242526272829303132&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; name:'', size:'', type:'' &#125; this.fileRef = React.createRef() &#125; filePush=()=&gt;&#123; console.log(); this.setState(&#123; name:this.fileRef.current.files[0].name, size:this.fileRef.current.files[0].size, type:this.fileRef.current.files[0].type &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"file\" ref=&#123;this.fileRef&#125; /&gt; &lt;button onClick=&#123;this.filePush&#125;&gt;提交&lt;/button&gt; &lt;p&gt;file绑定的值：&#123;this.state.name&#125;----&#123;this.state.size&#125;----&#123;this.state.type&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; textarea：通过受控组件 监控 输入内容，并更新state中的值 12345678910111213141516171819202122232425&lt;script type=\"text/babel\"&gt;class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; val:'' &#125; &#125; iChange=(e)=&gt;&#123; this.setState(&#123; val:e.target.value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;textarea value=&#123;this.state.val&#125; onChange=&#123;this.iChange&#125;&gt;&lt;/textarea&gt; &lt;p&gt;textarea绑定的value值：&#123;this.state.val&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt; &lt;Com&gt;&lt;/Com&gt; &lt;/div&gt; )ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; CSS样式处理className 1234567891011121314151617181920212223242526// React中class是关键词，所以使用className// 可通过常规写法进行绑定样式，也可通过绑定 state 中数据来控制// 在className中 也可以使用表达式&lt;style&gt;.box&#123;color: red;&#125;.box2&#123;color: blue&#125;.fs&#123;font-size: 16px;&#125;&lt;/style&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; abc:true &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;div&gt;&lt;h1 className='box fs'&gt;hello&lt;/h1&gt;&lt;/div&gt; &lt;div&gt;&lt;h1 className=&#123;this.state.abc?'box2 fs':'box fs'&#125;&gt;world&lt;/h1&gt;&lt;/div&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; style 1234567891011121314151617181920212223// 通过html标签绑定 state 中的对象来控制行内样式// 或者 在html标签中采用 &#123;&#123;key:value,key:value&#125;&#125; 控制样式（不推荐）&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; abc:&#123;'fontSize':'36px',color:'blue'&#125; &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h1 style=&#123;&#123;color:'red','fontSize':'16px'&#125;&#125;&gt;hello&lt;/h1&gt; &lt;h1 style=&#123;this.state.abc&#125;&gt;world&lt;/h1&gt; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; yarn(类似npm) 类似npm的包管理网站 官网 安装 12//在官网中找到对应的安装文件，安装//在cmd中输入 yarn --version 查看是否安装成功 基础命令 1234567891011121314151617181920212223242526//与npm对比// 初始化新项目npm inityarn init// 默认安装npm installyarn install// 安装某个依赖，并且默认保存到package.npm install express —saveyarn add express// 移除某个依赖项目npm uninstall express —saveyarn remove express// 安装某个开发时依赖项目npm install express —save-dev yarn add express —dev// 更新某个依赖项目npm update express —save yarn upgrade express// 安装某个全局依赖项目npm install webpack -gyarn global add webpack// 运行某个命令npm run 命令名称yarn run 命令名称 create-react-app (脚手架) 官方脚手架工具，类似Vue-cli 脚手架工具，用来初始化项目 其他关键词：前端工程化、前后端分离 基于yarn，包装了webpack等工具包 官网 基础使用安装 需要先安装npx（npm引入的新命令） 1npm install -g npx 123456npx create-react-app 项目名称// ornpm install -g create-react-app //全局安装create-react-app 项目名称 运行说明 12345678//package.json\"scripts\": &#123; \"start\": \"react-scripts start\", //运行项目 \"build\": \"react-scripts build\", //打包、编译 \"test\": \"react-scripts test\", //运行测试项目 \"eject\": \"react-scripts eject\" //解锁webpack等包，解锁后不能还原&#125;, 路由 根据hash实现，url中的#不会解析。通过js获取对应hash 并显示不同的组件 react-router doc ####配置 安装 1yarn add react-router-dom 声明式路由 import { BrowserRouter as Router, Route, Link } from “react-router-dom”; 标签包裹 内容 使用首页 //相当于 使用 // url为”/“时，加入 exact 中若没有path，则会匹配其他url，然后重定向？到component组件中 可以不写component： 可使用render={()=&gt;{111111}} 处理简单内容，触发条件为 path匹配 可使用children={()=&gt;{111111}} 与render类似，但触发条件为 路径触发则调用 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";import Home from './components/Home'import Game from './components/Game'class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Redirect to=\"/\"/&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; html容器： 模糊路由 import { BrowserRouter as Router, Route, Link, Switch} from “react-router-dom”; 不写明path，需要导入Switch，并用包裹 ：在路径相同的情况下，只匹配第一个，可以避免重复匹配路由 12345678910111213141516171819202122232425import &#123; BrowserRouter as Router, Route, Link, Switch&#125; from \"react-router-dom\";class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music\"&gt;音乐&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/:abc\"&gt;其他&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Route path='/music' component=&#123;Music&#125;&gt;&lt;/Route&gt; &lt;Route component=&#123;Other&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; 路由嵌套 子组件不需要用标签包裹 内容，且子组件可包含或 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link, Switch&#125; from \"react-router-dom\";// import './App.css';import Home from './components/Home'import Game from './components/Game'import Other from './components/Other'function music1()&#123;return &lt;p&gt;华语&lt;/p&gt;&#125;function music2()&#123;return &lt;p&gt;英语&lt;/p&gt;&#125;function Music ()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/music/1\"&gt;华语&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music/2\"&gt;英语&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/music/1\" component=&#123;music1&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/music/2\" component=&#123;music2&#125;&gt;&lt;/Route&gt; &lt;/div&gt; )&#125;class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music\"&gt;音乐&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/:abc\"&gt;其他&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Route path='/music' component=&#123;Music&#125;&gt;&lt;/Route&gt; &lt;Route component=&#123;Other&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 参数传递 通过 中的path设置传参 例如path=’/game/:id’ 在标签to中传递参数 在对应组件的 this.props.match 获取参数(class组件) 12345678910111213141516&lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/game/123\"&gt;游戏&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/music\"&gt;音乐&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/:abc\"&gt;其他&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/game/:id' component=&#123;Game&#125;&gt;&lt;/Route&gt; &lt;Route path='/music' component=&#123;Music&#125;&gt;&lt;/Route&gt; &lt;Route component=&#123;Other&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; 123456789//若是函数组件，则通过match获取参数&lt;Route path=\"/:id\" component=&#123;Child&#125; /&gt;function Child(&#123; match &#125;) &#123; return ( &lt;div&gt; &lt;h3&gt;ID: &#123;match.params.id&#125;&lt;/h3&gt; &lt;/div&gt; );&#125; 路由重定向 import { BrowserRouter as Router, Route, Link, Switch, Redirect} from “react-router-dom”; 123456// 函数组件，判断条件是否成立 //如果页面中存在&lt;Redirect&gt;标签，则会直接跳转function music2()&#123; let isok = false let info = isok ? \"\" : &lt;Redirect to='/'&gt;&lt;/Redirect&gt; return info&#125; 编程式导航 通过js的方式 实现组件跳转 //注意根url 的有没有exact 导入withRouter import { withRouter } from “react-router-dom”; 导出组件时需要使用withRouter包裹 export default withRouter(Game) 给事件源（按钮）注册方法，触发事件 通过结构获取props中的history let {history} = this.props 通过 history.push(‘/‘) 跳转页面 12345678910111213141516171819202122232425262728import React,&#123;Component&#125; from 'react'import &#123; withRouter &#125; from \"react-router-dom\";class Game extends Component &#123; constructor(props)&#123; super(props) &#125; fn=()=&gt;&#123; let &#123;history&#125; = this.props console.dir(history); history.push('/') // history.push('/',&#123;key:val&#125;) 传参 &#125; render()&#123; let id = this.props console.log(id); return ( &lt;div&gt; &lt;h1&gt;游戏&lt;/h1&gt; &lt;button onClick=&#123;this.fn&#125;&gt;编程式导航&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default withRouter(Game)// 传参跳转时，外部获取参数 props.location.state 自定义路由链接(样式) 路由发生变化时 改变对应标签的样式/结构重构 利用的children属性 获取当前点击事件源，并赋予指定样式 1234567891011121314151617181920212223242526272829303132333435363738394041import React from 'react'import &#123; Route, Link &#125; from 'react-router-dom'class Com extends React.Component&#123; render()&#123; // 通过props解构传入的参数 let &#123;to,name&#125; = this.props return ( // children传入函数，通过解构match判断当前事件源 &lt;Route path=&#123;to&#125; children=&#123;( &#123;match&#125; )=&gt;&#123; return ( &lt;div className=&#123;match?'active':''&#125;&gt; &lt;Link to=&#123;to&#125;&gt;&#123;name&#125;&lt;/Link&gt; &lt;/div&gt; ) &#125;&#125; /&gt; ) &#125;&#125;// 临时的组件function Temp1()&#123;return (&lt;div&gt;hello&lt;/div&gt;)&#125;function Temp2()&#123;return (&lt;div&gt;world&lt;/div&gt;)&#125;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;/* 内容容器 （这里组件写死了，以后可以动态传入组件） */&#125; &lt;Route path='/main/message/url-1' component=&#123;Temp1&#125;&gt;&lt;/Route&gt; &lt;Route path='/main/message/url-2' component=&#123;Temp2&#125;&gt;&lt;/Route&gt; &#123;/* 引入组件，传入参数 */&#125; &lt;Com to='/main/message/url-1' name='111' /&gt; &lt;Com to='/main/message/url-2' name='222' /&gt; &lt;/div&gt; ) &#125;&#125;export default Message // 参考项目代码：myapp-基础项目搭建.zip （看Menu.js、Main.js） redux 状态（数据）管理，类似vuex 看另一个笔记。。 其他内容短路运算符: &amp;&amp;1234567891011121314151617181920212223//通过短路运算符 判断标签是否需要渲染到页面中&lt;script type=\"text/babel\"&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state=&#123; show:true &#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.state.show &amp;&amp; &lt;h1&gt;hello&lt;/h1&gt; &#125; &lt;/div&gt; ) &#125;&#125;let App = ( &lt;div&gt;&lt;Com&gt;&lt;/Com&gt;&lt;/div&gt;)ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt; 虚拟DOM（Virtual DOM） 映射真实DOM树的JS对象 数据发生改变时，先对虚拟DOM进行操作（diff） diff的结果就是变更的节点（这里的节点指的是虚拟节点-本质上就是普通对象） 而后对虚拟DOM、真实DOM进行比较 根据比较结构，对真实DOM进行操作，完成页面更新 案例1 - tab栏切换本质： 利用点击按钮时传递循环产生的 i，与state中的index配对 通过按钮点击事件 改变state中的值，保证这对数据 一致性 通过判断 i 和state中的index，判断 div 是否显示 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt;&lt;style&gt; #box div&#123;height: 200px;width: 300px;background: #ccc;display: none&#125; #box div.active&#123;display: block&#125; #box button.active&#123;background: orange&#125;&lt;/style&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class Com extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123; tabData:[&#123;title:'导航1',cont:'内容1'&#125;,&#123;title:'导航2',cont:'内容2'&#125;,&#123;title:'导航3',cont:'内容3'&#125;], eleIndex:0 &#125; &#125; handleTag=(e,i)=&gt;&#123; this.setState(&#123; eleIndex:i &#125;) &#125; render()&#123; let index = this.state.eleIndex let tempTitle = [] let tempCont = [] this.state.tabData.forEach((item,i) =&gt; &#123; tempTitle.push(&lt;button className=&#123;index==i?'active':''&#125; key=&#123;i&#125; onClick=&#123;(e)=&gt;&#123;this.handleTag(e,i)&#125;&#125;&gt;&#123;item.title&#125;&lt;/button&gt;) tempCont.push(&lt;div className=&#123;index==i?'active':''&#125; key=&#123;i&#125;&gt;&#123;item.cont&#125;&lt;/div&gt;) &#125;) return ( &lt;div id=\"box\"&gt; &#123;tempTitle&#125; &#123;tempCont&#125; &lt;/div&gt; ) &#125; &#125; let App = ( &lt;div&gt;&lt;Com /&gt;&lt;/div&gt; ) ReactDOM.render(App,document.getElementById('root'))&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"React","slug":"React","permalink":"/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"/tags/React/"}]},{"title":"手机rem、x倍图适配","slug":"手机rem、x倍图适配","date":"2019-05-09T03:11:41.902Z","updated":"2019-05-09T03:10:08.363Z","comments":true,"path":"2019/05/09/手机rem、x倍图适配/","link":"","permalink":"/2019/05/09/手机rem、x倍图适配/","excerpt":"","text":"rem计算参考 vm+rem：参考 123456789101112131415161718192021222324252627282930// .scss预编译// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vm_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vm_design: 750;html &#123; font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body增加宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125;// 使用示例div &#123; height: rem(300); width: rem(300); background: red;&#125; 标准rem方案： 动态获取屏幕宽度 并赋予font-size 应对于各视口+横竖屏 123456789&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; //获取手机屏幕宽度var deviceWidth = document.documentElement.clientWidth;//动态设置html的font-sizedocument.documentElement.style.fontSize = deviceWidth / 6.4 + 'px';//设计稿基准640px则：640/100=6.4//页面元素rem = 设计稿尺寸 / 100 rem 其他rem：背景：在 1080px 的视觉稿中，左上角有个logo，宽度是 180px 1234567&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; //最低设置 //获取手机屏幕宽度var deviceWidth = document.documentElement.clientWidth;//动态设置html的font-sizedocument.documentElement.style.fontSize = deviceWidth + 'px'; sass 12345678//定义方法：calc@function calc($val)&#123; @return $val / 1080;&#125;.logo&#123; width : calc(180rem);&#125; 倍图适配方法普通图片：js+img异步加载图片12//html&lt;img id=\"img\" data-src1x=\"xxx@1x.jpg\" data-src2x=\"xxx@2x.jpg\" data-src3x=\"xxx@3x.jpg\"/&gt; 123456789101112//jsvar dpr = window.devicePixelRatio;if(dpr &gt; 3)&#123; dpr = 3;&#125;;var imgSrc = $('#img').data('src'+dpr+'x');var img = new Image();img.src = imgSrc;img.onload = function(imgObj)&#123; $('#img').remove().prepend(imgObj);//替换img对象&#125;; srcset 标签 基于WebKit特性srcset 1&lt;img src=\"1.jpg\" srcset=\"2.jpg 2x, 3.jpg 3x\"&gt; 参考 背景图片：media query123456789101112131415161718/* 普通显示屏(设备像素比例小于等于1)使用1倍的图 */.css&#123; background-image: url(img_1x.png);&#125;/* 高清显示屏(设备像素比例大于等于2)使用2倍图 */@media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .css&#123; background-image: url(img_2x.png); &#125;&#125;/* 高清显示屏(设备像素比例大于等于3)使用3倍图 */@media only screen and (-webkit-min-device-pixel-ratio:3)&#123; .css&#123; background-image: url(img_3x.png); &#125;&#125; 横、竖屏： 需要针对横、竖屏编写不同的css 动态设置字体尺寸（不推荐） 12345678910var deviceWidth = document.documentElement.clientWidth, deviceHeight = document.documentElement.clientHeight//横屏状态if (window.orientation === 90 || window.orientation === -90) &#123; deviceWidth = deviceHeight;&#125;;//设置根字体大小document.documentElement.style.fontSize = deviceWidth + 'px'; JS检测横竖屏js获取屏幕旋转方向：window.orientation 0 - 正常方向 -90 - 屏幕顺时钟旋转90度 90 - 屏幕逆时针旋转90度 180 - 屏幕旋转180度 123window.addEventListener(\"orientationchange\", function () &#123; window.orientation === 0 ? alert('竖屏') : alert('横屏')&#125;, false) 12345678window.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", function() &#123; if (window.orientation === 180 || window.orientation === 0) &#123; console.log('竖屏状态！'); &#125;; if (window.orientation === 90 || window.orientation === -90 )&#123; console.log('横屏状态！'); &#125; &#125;, false); CSS判断横竖屏方式一： 12345&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"&gt;&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"landscape.css\"&gt; 方式二：写在同一个CSS中： 123456@media screen and (orientation: portrait) &#123; /*竖屏 css*/&#125; @media screen and (orientation: landscape) &#123; /*横屏 css*/&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"webpack - 基础","slug":"webpack - 基础","date":"2019-05-09T03:11:41.887Z","updated":"2019-05-09T03:15:16.392Z","comments":true,"path":"2019/05/09/webpack - 基础/","link":"","permalink":"/2019/05/09/webpack - 基础/","excerpt":"","text":"Webpack描述主要用于对项目文件进行打包，减少用户浏览时的请求数量，并对es6、es7降级，解决css兼容性等问题 npm 官网 适用于： 123456789101. 样式表 .css .less .scss2. JS文件 .js .ts (typescript)3. 图片 .jpg/.jpeg .png .gif .bmp 4. 字体文件 .ttf .eot .woff .woff2 .svg5. 模板文件 .vue .jsx(react) 不适用： 12341. 合并多个js文件为一个2. 模块化开发3. 把less、scss、es6/es7等高级语言编译为低级的，使得浏览器可以识别4. 编译图片为base64格式，减少网络请求次数 其他打包工具： Grunt Gulp 基本使用 基于node环境，需要配置基本的入口文件。输入/输出文件夹 默认只对.js文件打包，若需要处理额外的格式，需要安装对应的包 安装12345678910111213(以下为默认情况下的配置，部分内容可通过配置文件调整)1.初始化 初始化环境：npm init -y 在项目文件夹中创建\"src\"文件夹，用于默认的入口 创建入口文件:index.js、index.html2.安装 安装webpack和其依赖webpack-cli：npm i webpack webpack-cli -D （-d 等于将依赖安装到‘devDependencies’模块，该模块用于开发环境）3.配置运行指令 在package.json文件的scripts节点中，新增一个dev节点（自定义名称） \"pack\": \"webpack\" 打包时，运行命令：npm run pack，即可打包 自定义配置1234567891011121314151.在项目根目录下，创建一个 webpack.config.js 文件自定义配置：（具体参考官网）const path = require('path')module.exports = &#123; // production:生产，产生优化压缩的打包文件 // development:开发，产生有注释、空白、回车 可读性好的打包文件 mode: 'development', entry: path.join(__dirname, './src/index.js'), // 修改入口文件 output: &#123; path: path.join(__dirname, './dist'), // 输出目录 filename: 'main.js' // 输出打包文件名字设置 &#125;&#125;; HTML页面处理 插件：html-webpack-plugin 参考 安装 1npm install --save-dev html-webpack-plugin 配置 123456789101112//在 webpack.config.js 文件中添加：const HtmlWebpackPlugin = require('html-webpack-plugin');plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', //被打包的html模板文件名称 //filename: 'index.html' //生成打包文件名称， 默认是index.html &#125;)] 使用 1常规打包即可 loader参考 loader : javascript函数，以模块形式存在，webpack打包过程中，遇到不能处理的内容就会寻找对应的loader处理 处理不同内容的loader： css内容： style-loader 和 css-loader less内容： less-loader 和 less(less-loader的依赖) 图片内容： url-loader 和 file-loader ES6/ES7内容： babel-loader 配置参考 12345678910111213141516没有参数的 1个或多个 加载器配置&#123; test: /\\.格式$/, use: 加载器 &#125;, //1个&#123; test: /\\.格式$/, use: [加载器,加载器] &#125;, //多个 数组元素 &#123; test: /\\.格式$/, loader: 加载器&#125;, //1个&#123; test: /\\.格式$/, loader: 加载器!加载器&#125;, //多个 !叹号分隔有options参数的 1个或多个 加载器配置&#123; test: /\\.格式$/, loader: 加载器, options:对象参数&#125;, //1个&#123; test: /\\.格式$/, use:[&#123;loader: 加载器, options:对象参数&#125;,&#123;loader: 加载器, options:对象参数&#125;,...]&#125;, //多个 css文件处理安装 1npm install style-loader css-loader --save-dev 配置 12345678910111213141516171819202122232425//在 webpack.config.js 里添加：module: &#123; rules: [&#123; test: /\\.css$/, // css名字结尾文件 处理loader设定 use: [ // 以下两个loader有顺序要求，css-loader在后，style-loader在前 // 它们在执行的时候是先执行css-loader在执行style-loader &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125; ] &#125;, ]&#125;//精简写法module: &#123; rules: [&#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125;, ]&#125; less处理 最好先安装css-loader、style-loader 安装 1npm install --save-dev less-loader less 配置 123456789101112//在 webpack.config.js 文件中添加：module: &#123; rules: [&#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125;, &#123; test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"] &#125; ]&#125; url处理(+img) url-loader 该loader会将url引用的img图片转换成base64格式（可设置阈值） 超过阈值的内容会交给 file-loader处理 安装 1npm install --save-dev file-loader url-loader 配置 1234567891011121314151617181920//在 webpack.config.js 文件中添加：module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ] &#125; ] &#125;&#125;//limit 代表 阈值尺寸 JS降级 babel-loader 官网 webpack 安装 12345//不同版本的安装：npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpacknpm install babel-loader babel-core babel-preset-env webpacknpm install --save-dev babel-loader @babel/core @babel/preset-env 配置 v1 123456789101112131415//在 webpack.config.js 文件中添加：module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ]&#125; 推荐配置 12345678910111213//在 webpack.config.js 文件中添加：module: &#123; rules: [ &#123; // 设置babel-loader，使得js中es6等高级语法可以降级为es5标准，兼容各个浏览器 test: /\\.js$/, exclude: /node_modules/, // node_modules目录的js文件不要给处理 use: 'babel-loader', // 调用具体loader // 具体preset在其他位置配置，给\"根目录\"制作.babelrc文件并做配置即可 &#125; ]&#125; 123456//同级目录创建“.babelrc”，输入：&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-proposal-class-properties\"] //处理“静态”成员&#125; 处理“静态”成员 需要安装插件:class-properties 参考 安装 1npm install --save-dev @babel/plugin-proposal-class-properties 配置 12345678910111213//在.babelrc中配置&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-proposal-class-properties\"] //处理“静态”成员&#125;//在webpack.config.js中配置 ？？？&#123; \"plugins\": [ [\"@babel/plugin-proposal-class-properties\", &#123; \"loose\": true &#125;] ]&#125; Vue-loader 处理.vue格式的文件 官网 安装 1npm install vue-loader vue-template-compiler --save-dev 配置 12345678910111213141516171819//webpack.config.js//1const VueLoaderPlugin = require('vue-loader/lib/plugin')//2module: &#123; rules: [ &#123; test: /\\.vue$/, use: 'vue-loader' &#125;, ]&#125;, //3 plugins: [ new VueLoaderPlugin()], 其他简单服务器（实时预览） 一个简单的 web 服务器，并且能够实时重新加载(live reloading)。 只会在内存中运行，不会生成对应的实体文件 插件：webpack-dev-sever 参考 安装 1npm install --save-dev webpack-dev-server 配置 1 12345678910111213//在 webpack.config.js 中添加devServer: &#123; contentBase: './dist'&#125;//或 详细配置devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, //是否压缩 host: \"127.0.0.1\", // 服务主机ip地址 port: 9000, //端口号 open: true // 自动打开浏览器访问效果&#125; 配置 2 12345//在 package.json 里添加一个启动方式\"scripts\": &#123; \"line\": \"webpack-dev-server --open\"&#125;, 启动 1npm run line","categories":[{"name":"webpack","slug":"webpack","permalink":"/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"雅虎前端优化35条规则","slug":"雅虎前端优化35条规则","date":"2019-05-09T03:03:30.349Z","updated":"2019-05-09T03:08:48.155Z","comments":true,"path":"2019/05/09/雅虎前端优化35条规则/","link":"","permalink":"/2019/05/09/雅虎前端优化35条规则/","excerpt":"","text":"本文是大名鼎鼎的雅虎前端优化规则（Yslow）的翻译。翻译并不逐字逐句，部分难以逐字翻译的被意译了，另外一些不重要的举例等也被精简。 原文： Best Practices for Speeding Up Your Web Site。 如何让web页面更快，雅虎团队实践总结了7类35条规则，下面一一列出。 1. Content1.1 Make Fewer HTTP RequestsMinimize HTTP Requests减少/最小化 http 请求数。 到终端用户的响应时间80%花在前端：大部分用于下载组件（js/css/image/flash等等）。减少组件数就是减少渲染页面所需的http请求数。这是更快页面的关键。 减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少http请求，有以下几个技术： Combined files。合并文件，如合并js，合并css都能减少请求数。如果页面间脚本和样式差异很大，合并会更具挑战性。 CSS Sprites。雪碧图可以合并多个背景图片，通过background-image 和 background-position 来显示不同部分。 Image maps。合并多个图片到一个图片，一般用于如导航条。由于定义坐标的枯燥和易错，一般不推荐。 Inline images。使用data:url scheme来內连图片。 减少请求数是为第一次访问页面的用户提高性能的最重要的指导。 1.2 Reduce DNS Lookups减少DNS查询。 就像电话簿，你在浏览器地址栏输入网址，通过DNS查询得到网站真实IP。 DNS查询被缓存来提高性能。这种缓存可能发生在特定的缓存服务器（ISP/local area network维护），或者用户的计算机。DNS信息留存在操作系统DNS缓存中（在windows中就是 DNS Client Serve ）。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS记录，它就不会向操作系统发DNS解析请求。 IE默认缓存DNS记录30分钟，FireFox默认缓存1分钟。 当客户端的DNS缓存是空的，DNS查找次数等于页面中的唯一域名数。 减少DNS请求数可能会减少并行下载数。避免DNS查找减少响应时间，但减少并行下载数可能会增加响应时间。指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是两者的妥协。 1.3 Avoid Redirects避免跳转。 跳转用301或302状态码来达成。一个301响应http头的例子： 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 浏览器自动跳转到Location指定的路径。跳转所需的所有信息都在http头，所以http主体一般是空的。301`302响应一般不会被缓存，除非有额外的头部信息，比如Expires或Cache-Control指定要缓存。meta刷新标签或 JavaScript 也可以跳转，但如果真要跳转，3xx`跳转更好，主要是保证返回键可用。 跳转显然拖慢响应速度。在跳转的页面被获取前浏览器没什么能渲染，没什么组件能下载。 最浪费的跳转之一发生在url尾部slash（/）缺失。比如http://astrology.yahoo.com/astrology会301跳转到http://astrology.yahoo.com/astrology/。这可以被Apache等服务器修复，用Alias，mod_rewrite等等。 1.4 Make Ajax Cacheable让Ajax可缓存。 使用ajax的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。 提高ajax性能的最重要的方法是让响应被缓存，即在Add an Expires or a Cache-Control Header中讨论的 Expires 。其它方法是： gzip组件 减少DNS查找 压缩JS 避免跳转 设置ETags 1.5 Post-load Components延迟加载组件。 再看看你的页面然后问问自己，“什么是页面初始化必须的？”。剩下的内容和组件可以延迟。 JavaScript是理想的（延迟）候选者，可以切分到onload事件之前和之后。比如拖放的js库可以延迟，因为拖动必须在页面初始化之后。其它可延迟的包括隐藏的内容，折叠起来的图片等等。 1.6 Preload Components预加载组件。 预加载看起来与延迟加载相反，但它的确有个不同的目标。通过预加载你可以利用浏览器的空闲时间来请求你将来会用到的组件。这样当用户访问下一个页面时，你会有更多的组件已经在缓存中，这样会极大加快页面加载。 有几种预加载类型： 无条件预加载：一旦onload触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。 有条件预加载：基于用户动作，你推测用户下一步会去哪里并加载相应组件。 预期的预加载：在发布重新设计（的网站）前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。 1.7 Reduce the Number of DOM Elements减少dom数。 一个复杂的页面意味着更多的内容要下载，以及更慢的dom访问。比如在有500dom数量的页面添加事件处理就和有5000dom数量的不同。 如果你的页面dom元素很多，那么意味着你可能需要删除无用的内容和标签来优化。 1.8 Split Components Across Domains把组件分散到不同的域名。 把组件分散到不同的域名允许你最大化并行下载数。由于DNS查询的副作用，最佳的不同域名数是2-4。 1.9 Minimize the Number of iframes最小化iframe的数量。 iframe允许html文档被插入到父文档。 优点： 帮助解决缓慢的第三方内容的加载，如广告和徽章 安全沙盒 并行下载脚本 缺点： 即使空的也消耗（资源和时间） 阻塞了页面的onload 非语义化（标签） 1.10 No 404s不要404。 http请求是昂贵的，所以发出http请求但获得没用的响应（如404）是完全不必要的，并且会降低用户体验。 一些网站会有特别的404页面提高用户体验，但这仍然会浪费服务器资源。特别坏的是当链接指向外部js但却得到404结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把404响应体当作js来解析，试图从里面找出可用的东西。 2. Server2.1 Use a Content Delivery Network使用CDN。 用户接近你的服务器会减少响应时间。把你的内容发布到多个，地理上分散的服务器可以让页面加载更快。但怎么开始？ 首先不要试图把你的架构重新设计成分布式架构。因为可能引进更多复杂性和不可控。 记住80-90%的终端用户响应时间花费在下载页面中的所有组件：图片、样式、脚本、falsh等等。这是Performance Golden Rule。不要从困难的重新设计后台架构开始，最好首先分发你的静态内容。这不仅可以减少响应时间，用CDN还很容易来做。 CDN是一群不同地点的服务器，可以更高效地分发内容到用户。一些大公司有自己的CDN。 2.2 Add an Expires or a Cache-Control Header加Expires或者Cache-Control头部。 这条规则有两个方面： 对静态组件：通过设置Expires头部来实现“永不过期”策略。 对动态组件：用合适的Cache-Control头部来帮助浏览器进行有条件请求。 页面越来越丰富，意味着更多脚本，样式，图片等等。第一次访问的用户可能需要发出多个请求，但使用Expires可以让这些组件被缓存。这避免了访问子页面时没必要的http请求。Expires一般用在图片上，但应该用在所有的组件上。 浏览器（以及代理）使用缓存来减少http请求数，加快页面加载。服务器使用http响应的Expires头部来告诉客户端一个组件可以缓存多久。比如下面： 1Expires: Thu, 15 Apr 2010 20:00:00 GMT //2010-04-15之前都是稳定的 注意，如果你设置了Expires头部，当组件更新后，你必须更改文件名。 2.3 Gzip Components传输时用gzip等压缩组件。 http请求或响应的传输时间可以被前端工程师显著减少。终端用户的带宽，ISP，接近对等交换点等等没法被开发团队控制，但是，压缩可以通过减少http响应的大小减少响应时间。 从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩： 1Accept-Encoding: gzip, deflate 如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端： 1Content-Encoding: gzip gzip一般可减小响应的70%。尽可能去gzip更多（文本）类型的文件。html，脚本，样式，xml和json等等都应该被gzip，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过，gzip它们只是浪费cpu，甚至增加文件大小。 2.4 Configure ETags实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个组件是否匹配服务器端原组件的一种机制。实体就是组件：图片，脚本，样式等等。ETag被当作验证实体的比最后更改（last-modified）日期更高效的机制。服务器这样设置组件的ETag： 1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195 之后，如果浏览器要验证组件，它用If-None-Match头部来传ETag给服务器。如果ETag匹配，服务器返回304： 12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified ETag的问题是它们被构造来使它们对特定的运行这个网站的服务器唯一。浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag将不匹配。然而服务器集群是处理请求的通用解决方案。 如果不能解决多服务器间的ETag匹配问题，那么删除ETag可能更好。 2.5 Flush the Buffer Early早一点刷新buffer（尽早给浏览器数据）。 当用户请求一个页面，服务器一般要花200-500ms来拼凑整个页面。这段时间，浏览器是空闲的（等数据返回）。在php，有个方法flush()允许你传输部分准备好的html响应给浏览器。这样的话浏览器就可以开始下载组件，而同时后台可以继续生成页面剩下的部分。这种好处更多是在忙碌的后台或轻前端网站可以看到。 一个比较好的flush的位置是在head之后，因为浏览器可以加载其中的样式和脚本文件，而后台继续生成页面剩余部分。 12345&lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt;&lt;!-- content --&gt; 2.6 Use GET for AJAX Requestsajax请求用get。 Yahoo! Mail团队发现当使用XMLHttpRequest，POST 被浏览器实现为两步：首先发送头部，然后发送数据。所以使用GET最好，仅用一个TCP包发送（除非cookie太多）。IE的url长度限制是2K。 POST但不提交任何数据根GET行为类似，但从语义上讲，获取数据应该用GET，提交数据到服务器用POST。 2.7 Avoid Empty Image src避免空src的图片。 空src属性的图片的行为可能跟你预期的不一样。它有两种形式： html标签：&lt;img src=&quot;&quot;&gt; js：var img = new Image(); img.src = &quot;&quot;; 两种都会造成同一种后果：浏览器会向你的服务器发请求。 IE，向页面所在的目录发请求。 Safari和Chrome，请求实际的页面。 FireFox3及之前和Safari/Chrome一样，但从3.5开始修复问题，不再发请求。 Opera遇到空图片src不做任何事。 为什么这种行为很糟糕？ 由于发送大量的意料之外的流量，会削弱服务器，尤其那些每天pv上百万的页面。 浪费服务器计算周期取生成不会被浏览的页面。 可能会破坏用户数据。如果你在跟踪请求状态，通过cookie或其它，你可能会破坏数据。即使image的请求不会返回图片，但所有的头部数据都被浏览器读取了，包括cookie。即使剩下的响应体被丢弃，破坏可能已经发生。 这种行为的根源是uri解析发生在浏览器。RFC 3986 定义了这种行为，空字符串被当作相对路径，Firefox, Safari, 和 Chrome都正确解析，而IE错误。总之，浏览器解析空字符串为相对路径的行为被认为是符合预期的。 html5在4.8.2添加了对标签src属性的描述，指导浏览器不要发出额外的请求。 The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string. 幸运的是将来浏览器不会有这个问题了（在图片上）。不幸的是，&lt;script src=&quot;&quot;&gt;和&lt;link href=&quot;&quot;&gt;没有这样的规范。 3 Cookie3.1 Reduce Cookie Sizehttp cookie的使用有多种原因，比如授权和个性化。cookie的信息通过http头部在浏览器和服务器端交换。尽可能减小cookie的大小来降低响应时间。 消除不必要的cookie。 尽可能减小cookie的大小来降低响应时间。 注意设置cookie到合适的域名级别，则其它子域名不会被影响。 正确设置Expires日期。早一点的Expires日期或者没有会尽早删除cookie，优化响应时间。 3.2 Use Cookie-free Domains for Components用没有cookie的域名提供组件。 当浏览器请求静态图片并把cookie一起发送到服务器时，cookie此时对服务器没什么用处。所以这些cookie只是增加了网络流量。所以你应该保证静态组件的请求是没有cookie的。可以创建一个子域名来托管所有静态组件。 比如，你域名是www.example.org，可以把静态组件托管在static.example.org。不过，你如果把cookie设置在顶级域名example.org下，这些cookie仍然会被传给static.example.org。这种情况下，启用一个全新的域名来托管静态组件。 另外一个用没有cookie的域名提供组件的好处是，某些代理可能会阻止缓存待cookie的静态组件请求。 4. CSS4.1 Put Stylesheets at the Top把样式放在顶部。 研究雅虎网页性能时发现把样式表移到&lt;head&gt;里会让页面更快。这是因为把样式表移到&lt;head&gt;里允许页面逐步渲染。 关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML页面就是进度条。当浏览器逐步加载页面头部，导航条，logo等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。 把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。 HTML规范清楚表明样式应该在&lt;head&gt;里。 4.2 Avoid CSS Expressions避免CSS表达式。 CSS表达式是强大的（可能也是危险的）设置动态CSS属性的方法。IE5开始支持，IE8开始不赞成使用。例如，背景颜色可以设置成每小时轮换： 1background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); CSS表达式的问题是它们可能比大多数人预期的计算的更频繁。它们不仅在页面载入和调整大小时重新计算，也在滚动页面甚至是用户在页面上移动鼠标时计算。比如在页面上移动鼠标可能轻易计算超过10000次。 要避免CSS表达式计算太多次，可以在它第一次计算后替换成确切值，或者用事件处理函数而不是CSS表达式。 4.3 Choose &lt;link&gt; over @import选择&lt;link&gt;而不是@import。 之前的一个最佳原则是说CSS应该在顶部来允许逐步渲染。 在IE用@import和把CSS放到页面底部行为一致，所以最好别用。 4.4 Avoid Filters避免使用（IE）过滤器。 IE专有的AlphaImageLoader过滤器用于修复IE7以下版本的半透明真彩色PNG的问题。这个过滤器的问题是它阻止了渲染，并在图片下载时冻结了浏览器。另外它还引起内存消耗，并且它被应用到每个元素而不是每个图片，所以问题（的严重性）翻倍了。 最佳做法是放弃AlphaImageLoader，改用PNG8来优雅降级。 5. JavaScript5.1 Put Scripts at the Bottom把脚本放到底部。 脚本引起的问题是它们阻塞了并行下载。HTTP1.1规范建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下。 有些情况下把脚本移动到底部并不简单。比如，脚本中用了document.write来插入内容，它就不能被移动到底部。另外有可能有作用域问题。但大多数情况，有方法可以解决这些问题。 一个替代建议是使用异步脚本。defer属性表明脚本不包含document.write，是提示浏览器继续渲染的线索。不幸的是，Firefox不支持。如果脚本能异步，那么也就可以移动到底部。 5.2 Make JavaScript and CSS External使用外部JS和CSS。 这里的很多性能规则涉及外部组件怎么管理。但你首先要明白一个基本问题：JS和CSS是应该包含在外部文件还是內连在页面本身？ 真实世界中使用外部文件一般会加快页面，因为JS和CSS文件被浏览器缓存了。內连的JS和CSS怎在每次HTML文档下载时都被下载。內连减少了http请求，但增加了HTML文档大小。另一方面，如果JS和CSS被缓存了，那么HTML文档可以减小大小而不增加HTTP请求。 核心因素，就是JS和CSS被缓存相对于HTML文档被请求的频率。尽管这个因素很难被量化，但可以用不同的指标来计算。如果网站用户每个session有多个pv，许多页面重用相同的JS和CSS，那么有很大可能用外部JS和CSS更好。 许多网站用这些指标计算后在中间位置。对这些网站来说，最佳方案还是用外部JS和CSS文件。唯一例外是內连更被主页偏爱，如http://www.yahoo.com/。主页每个session可能只有少量的甚至一个pv，这时候內连可能更快。 对多个页面的首页来说，可以通过技术减少（其它页面的）http请求。在首页用內连，初始化后动态加载外部文件，接下来的页面如果用到这些文件，就可以使用缓存了。 5.3 Minify JavaScript and CSS压缩JS和CSS。 压缩就是删除代码中不必要的字符来减小文件大小，从而提高加载速度。当代码压缩时，注释删除，不需要的空格（空白，换行，tab）也被删除。 混淆是对代码可选的优化。它比压缩更复杂，并且可能产生bug。在对美国top10网站的调查，压缩可减小21%，而混淆可减小25%。 除了外部脚本和样式，內连的脚本和样式同样应该被压缩。 5.4 Remove Duplicate Scripts删除重复的脚本。 在页面中引入相同的脚本两次会伤害性能。可能超出你的预料，美国top10网站的2家有重复脚本引入。两个主要因素造成同一页面引入相同脚本：团队大小和脚本数量。当确实引入重复脚本，会发出不必要的http请求和浪费js执行时间。 发出不必要的http请求发生在IE而不是Firefox。在IE，如果外部脚本引入两次且没有缓存，它会发出2个请求。即使脚本被缓存，刷新时也会发出额外请求。 除了增加http请求，时间被浪费在执行脚本多次上。不管IE还是Firefox都会执行多次。 一种避免多次引入脚本的方法是在模板系统实现一个脚本管理模块。 5.5 Minimize DOM Access最小化DOM访问。 用JS访问DOM元素是缓慢的，所以为了响应更好的页面，你应该： 缓存访问过的元素的引用 在DOM树外更新节点，然后添加到DOM树 避免用JS实现固定布局 5.6 Develop Smart Event Handlers开发聪明的事件处理 有时候页面看起来不那么响应（响应速度慢），是因为绑定到不同元素的大量事件处理函数执行太多次。这是为什么使用事件委托是一种好方法。 另外，你不必等到onload事件来开始处理DOM树，DOMContentLoaded更快。大多时候你需要的只是想访问的元素已在DOM树中，所以你不必等到所有图片被下载。 6 Images6.1 Optimize Images优化图片 在设计师建好图片后，在上传图片到服务器前你仍可以做些事： 检查gif图片的调色板大小是否匹配图片颜色数。 可以把gif转成png看看有没有变小。除了动画，gif一般可以转成png8。 运行pngcrush或其它工具压缩png。 运行jpegtran或其它工具压缩jpeg。 6.2 Optimize CSS Sprites优化CSS雪碧图 把图片横向合并而不是纵向，横向更小。 把颜色近似的图片合并到一张雪碧图，这样可以让颜色数更少，如果低于256就可以用png8. “Be mobile-friendly”并且合并时图片间的间距不要太大。这对图片大小影响不是太大，但客户端解压时需要的内存更少。100×100是10000个像素，1000×1000是1000000个像素。 6.3 Don’t Scale Images in HTML不要在html中缩放图片 不要因为你可以设置图片的宽高就去用比你需要的大得多的图片。如果你需要 1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么，就用100x100px的图片，而不是500x500px的。 6.4 Make favicon.ico Small and Cacheablefavicon.ico小且缓存 favicon.ico是在你服务器根路径的图片。邪恶的是即使你不关心它，浏览器仍然会请求它。所以最好不要响应404。另外由于在同一服务器，每次请求favicon.ico时也会带上cookie。这个图片还会影响下载顺序，比如在IE，如果你在onload时下载额外的组件，fcvicon会在这些组件之前被下载。 怎么减轻favicon.ico的缺点？ 小，最好1K以下 设置Expires头部。也许可以安全地设置为几个月。 7 Mobile7.1 Keep Components under 25K保持组件小于25K 这个限制与iPhone不缓存大于25K的组件相关。注意，这是非压缩（uncompressed）的文件大小。在这里minification（压缩，不要与compress混淆）很重要，因为gzip无法满足（iPhone）。 7.2 Pack Components into a Multipart Document打包组件到一个多部父文档 打包组件到一个多部父文档类似于带附件的邮件。它帮助你在一个http请求中获取多个组件，但注意，iPhone不支持。","categories":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/categories/扩展阅读/"}],"tags":[{"name":"扩展阅读","slug":"扩展阅读","permalink":"/tags/扩展阅读/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-07T10:06:43.794Z","updated":"2019-05-07T09:50:07.152Z","comments":true,"path":"2019/05/07/hello-world/","link":"","permalink":"/2019/05/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}